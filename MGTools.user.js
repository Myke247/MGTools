// ==UserScript==
// @name         MGTools
// @namespace    http://tampermonkey.net/
// @version      2.0.0
// @description  All-in-one assistant for Magic Garden with beautiful unified UI (Enhanced Discord Support!)
// @author       Unified Script
// @updateURL    https://github.com/Myke247/MGTools/raw/refs/heads/Live-Beta/MGTools.user.js
// @downloadURL  https://github.com/Myke247/MGTools/raw/refs/heads/Live-Beta/MGTools.user.js
// @match        https://magiccircle.gg/r/*
// @match        https://magicgarden.gg/r/*
// @match        https://starweaver.org/r/*
// @match        https://1227719606223765687.discordsays.com/*
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_addStyle
// @grant        GM_addElement
// @grant        unsafeWindow
// @grant        GM_xmlhttpRequest
// @connect      raw.githubusercontent.com
// @connect      *
// @run-at       document-end
// ==/UserScript==

/*
 * ═══════════════════════════════════════════════════════════════════
 * ⚠️  THIS FILE IS AUTO-GENERATED - DO NOT EDIT DIRECTLY! ⚠️
 * ═══════════════════════════════════════════════════════════════════
 *
 * Source: https://github.com/Myke247/MGTools/tree/Live-Beta/src
 * Build: npm run build:production
 *
 * MGTools - Modular Architecture (TRUE 100% Extraction!)
 * ========================================================
 * This userscript is compiled from 55 ES6 modules using esbuild.
 * All source code is maintained in the src/ directory.
 *
 * Architecture:
 * - 55 modules across 7 layers (Utils, Core, State, UI, Features, Controllers, Init)
 * - Full dependency injection pattern
 * - 95.1% code extraction (32,798/34,361 lines)
 * - Remaining 4.9% is this build wrapper
 *
 * Development Workflow:
 * 1. Edit source code in src/ directory
 * 2. Run: npm run build:production
 * 3. Test: Install generated MGTools.user.js in Tampermonkey
 * 4. Deploy: Commit src/ changes (MGTools.user.js is generated)
 *
 * To contribute or report issues:
 * https://github.com/Myke247/MGTools
 *
 * ═══════════════════════════════════════════════════════════════════
 */


var MGTools = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/index.js
  var index_exports = {};
  __export(index_exports, {
    MGTools: () => MGTools
  });

  // src/core/storage.js
  var storage_exports = {};
  __export(storage_exports, {
    MGA_loadJSON: () => MGA_loadJSON,
    MGA_saveJSON: () => MGA_saveJSON,
    MGA_saveJSON_localStorage_fallback: () => MGA_saveJSON_localStorage_fallback,
    Storage: () => Storage2,
    StorageManager: () => StorageManager,
    _MGA_syncStorageBothWays: () => _MGA_syncStorageBothWays,
    _safeStorage: () => _safeStorage,
    isGMApiAvailable: () => isGMApiAvailable,
    localStorage: () => localStorage2
  });
  var Storage2 = /* @__PURE__ */ (() => {
    let initialized = false;
    let storageType = null;
    let gmApiAvailable = null;
    const _gmApiWarningShown = false;
    const memoryStore = {};
    const storageTypes = {
      GM: "gm",
      LOCAL: "local",
      SESSION: "session",
      MEMORY: "memory"
    };
    let localStorageRef = null;
    let sessionStorageRef = null;
    function testGMStorage() {
      if (gmApiAvailable !== null) return gmApiAvailable;
      try {
        if (typeof GM_setValue === "undefined" || typeof GM_getValue === "undefined") {
          gmApiAvailable = false;
          return false;
        }
        const testKey = "__mgtools_gm_test__";
        const testValue = "test_" + Date.now();
        GM_setValue(testKey, testValue);
        const retrieved = GM_getValue(testKey, null);
        if (typeof GM_deleteValue !== "undefined") {
          try {
            GM_deleteValue(testKey);
          } catch (e) {
          }
        }
        gmApiAvailable = retrieved === testValue;
        return gmApiAvailable;
      } catch (e) {
        gmApiAvailable = false;
        return false;
      }
    }
    function getLocalStorage() {
      if (localStorageRef) return localStorageRef;
      try {
        if (window.localStorage && typeof window.localStorage !== "undefined") {
          const test = "__localStorage_test__";
          window.localStorage.setItem(test, test);
          window.localStorage.removeItem(test);
          localStorageRef = window.localStorage;
          return localStorageRef;
        }
      } catch (e) {
        try {
          const iframe = document.createElement("iframe");
          iframe.style.display = "none";
          iframe.style.position = "absolute";
          iframe.style.width = "0";
          iframe.style.height = "0";
          if (document.body) {
            document.body.appendChild(iframe);
          } else {
            document.documentElement.appendChild(iframe);
          }
          const iframeStorage = iframe.contentWindow.localStorage;
          const test = "__mgtools_iframe_test__";
          iframeStorage.setItem(test, test);
          iframeStorage.removeItem(test);
          localStorageRef = iframeStorage;
          console.log("\u2705 [STORAGE] Using iframe localStorage workaround");
          return localStorageRef;
        } catch (iframeError) {
        }
      }
      return null;
    }
    function getSessionStorage() {
      if (sessionStorageRef) return sessionStorageRef;
      try {
        if (window.sessionStorage && typeof window.sessionStorage !== "undefined") {
          const test = "__sessionStorage_test__";
          window.sessionStorage.setItem(test, test);
          window.sessionStorage.removeItem(test);
          sessionStorageRef = window.sessionStorage;
          return sessionStorageRef;
        }
      } catch (e) {
      }
      return null;
    }
    function initialize() {
      if (initialized) return;
      if (testGMStorage()) {
        storageType = storageTypes.GM;
        console.log("\u2705 [STORAGE] Using GM storage (persistent across domains)");
      } else if (getLocalStorage()) {
        storageType = storageTypes.LOCAL;
        console.log("\u2705 [STORAGE] Using localStorage");
      } else if (getSessionStorage()) {
        storageType = storageTypes.SESSION;
        console.warn("\u26A0\uFE0F [STORAGE] Using sessionStorage (data lost on tab close)");
      } else {
        storageType = storageTypes.MEMORY;
        console.warn("\u26A0\uFE0F [STORAGE] Using memory storage (data lost on refresh)");
      }
      initialized = true;
    }
    function getItem(key, defaultValue = null) {
      initialize();
      try {
        let value = null;
        switch (storageType) {
          case storageTypes.GM:
            value = GM_getValue(key, null);
            break;
          case storageTypes.LOCAL:
            value = localStorageRef.getItem(key);
            break;
          case storageTypes.SESSION:
            value = sessionStorageRef.getItem(key);
            break;
          case storageTypes.MEMORY:
            value = memoryStore[key] || null;
            break;
        }
        if (value && typeof value === "string") {
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
        return value !== null ? value : defaultValue;
      } catch (e) {
        console.error("[STORAGE] getItem error:", e);
        return defaultValue;
      }
    }
    function setItem(key, value) {
      initialize();
      try {
        const stringValue = typeof value === "object" ? JSON.stringify(value) : String(value);
        switch (storageType) {
          case storageTypes.GM:
            GM_setValue(key, stringValue);
            break;
          case storageTypes.LOCAL:
            localStorageRef.setItem(key, stringValue);
            break;
          case storageTypes.SESSION:
            sessionStorageRef.setItem(key, stringValue);
            break;
          case storageTypes.MEMORY:
            memoryStore[key] = stringValue;
            break;
        }
        return true;
      } catch (e) {
        console.error("[STORAGE] setItem error:", e);
        if (storageType !== storageTypes.MEMORY) {
          try {
            memoryStore[key] = typeof value === "object" ? JSON.stringify(value) : String(value);
            console.warn("[STORAGE] Fallback to memory for key:", key);
            return true;
          } catch (e2) {
          }
        }
        return false;
      }
    }
    function removeItem(key) {
      initialize();
      try {
        switch (storageType) {
          case storageTypes.GM:
            if (typeof GM_deleteValue !== "undefined") {
              GM_deleteValue(key);
            } else {
              GM_setValue(key, void 0);
            }
            break;
          case storageTypes.LOCAL:
            localStorageRef.removeItem(key);
            break;
          case storageTypes.SESSION:
            sessionStorageRef.removeItem(key);
            break;
          case storageTypes.MEMORY:
            delete memoryStore[key];
            break;
        }
        return true;
      } catch (e) {
        console.error("[STORAGE] removeItem error:", e);
        return false;
      }
    }
    function clear() {
      initialize();
      try {
        switch (storageType) {
          case storageTypes.GM:
            console.warn("[STORAGE] GM storage clear not implemented");
            break;
          case storageTypes.LOCAL:
            localStorageRef.clear();
            break;
          case storageTypes.SESSION:
            sessionStorageRef.clear();
            break;
          case storageTypes.MEMORY:
            Object.keys(memoryStore).forEach((key) => delete memoryStore[key]);
            break;
        }
        return true;
      } catch (e) {
        console.error("[STORAGE] clear error:", e);
        return false;
      }
    }
    function getStorageType() {
      initialize();
      return storageType;
    }
    function getInfo() {
      initialize();
      return {
        type: storageType,
        gmAvailable: gmApiAvailable,
        localStorageAvailable: localStorageRef !== null,
        sessionStorageAvailable: sessionStorageRef !== null,
        memoryKeys: Object.keys(memoryStore).length
      };
    }
    return {
      get: getItem,
      set: setItem,
      remove: removeItem,
      clear,
      getType: getStorageType,
      getInfo,
      // Legacy compatibility
      getItem,
      setItem,
      removeItem,
      // Storage type constants
      TYPES: storageTypes
    };
  })();
  var _safeStorage = Storage2;
  var localStorage2 = {
    getItem: (key) => Storage2.get(key),
    setItem: (key, value) => Storage2.set(key, value),
    removeItem: (key) => Storage2.remove(key),
    clear: () => Storage2.clear(),
    get length() {
      console.warn("[STORAGE] localStorage.length not supported in unified storage");
      return 0;
    },
    key: (_index) => {
      console.warn("[STORAGE] localStorage.key() not supported in unified storage");
      return null;
    }
  };
  var StorageManager = Storage2;
  var gmApiCheckResult = null;
  var gmApiWarningShown = false;
  function isGMApiAvailable() {
    try {
      if (gmApiCheckResult !== null) {
        return gmApiCheckResult;
      }
      if (typeof GM_setValue === "undefined" || typeof GM_getValue === "undefined") {
        gmApiCheckResult = false;
        if (!gmApiWarningShown) {
          try {
            if (typeof logWarn === "function") {
              logWarn("GM-STORAGE", "GM API functions not defined - using localStorage fallback");
            } else {
              console.warn("\u26A0\uFE0F [GM-STORAGE] GM API not available - using localStorage fallback");
            }
          } catch (e) {
            console.warn("\u26A0\uFE0F [GM-STORAGE] GM API not available - using localStorage fallback");
          }
          gmApiWarningShown = true;
        }
        return false;
      }
      try {
        const testKey = "__mgtools_gm_test__";
        const testValue = "test_" + Date.now();
        GM_setValue(testKey, testValue);
        const retrieved = GM_getValue(testKey, null);
        try {
          if (typeof GM_deleteValue !== "undefined") {
            GM_deleteValue(testKey);
          }
        } catch (e) {
        }
        if (retrieved === testValue) {
          gmApiCheckResult = true;
          try {
            if (typeof logInfo === "function") {
              logInfo("GM-STORAGE", "GM API fully functional");
            } else {
              console.log("\u2705 [GM-STORAGE] GM API fully functional");
            }
          } catch (e) {
            console.log("\u2705 [GM-STORAGE] GM API fully functional");
          }
          return true;
        } else {
          throw new Error("GM_getValue returned incorrect value");
        }
      } catch (e) {
        gmApiCheckResult = false;
        if (!gmApiWarningShown) {
          try {
            if (typeof logWarn === "function") {
              logWarn("GM-STORAGE", "GM API blocked by security policy - using localStorage fallback");
            } else {
              console.warn("\u26A0\uFE0F [GM-STORAGE] GM API blocked - using localStorage fallback");
            }
          } catch (e2) {
            console.warn("\u26A0\uFE0F [GM-STORAGE] GM API blocked - using localStorage fallback");
          }
          gmApiWarningShown = true;
        }
        return false;
      }
    } catch (outerError) {
      gmApiCheckResult = false;
      gmApiWarningShown = true;
      try {
        console.warn("\u26A0\uFE0F [GM-STORAGE] Unexpected error testing GM API - using localStorage fallback");
      } catch (e) {
      }
      return false;
    }
  }
  function MGA_loadJSON(key, fallback = null) {
    let keyLocal = key;
    if (keyLocal && !String(keyLocal).startsWith("MGA_")) {
      console.error(`\u274C [MGA-ISOLATION] CRITICAL: Attempted to load with non-MGA key: ${keyLocal}`);
      try {
        console.trace();
      } catch (_) {
      }
      keyLocal = "MGA_" + keyLocal;
    }
    try {
      const gmAvailable = typeof GM_getValue === "function" && typeof GM_setValue === "function";
      const lsMain = typeof window !== "undefined" && window && window.localStorage ? window.localStorage : null;
      const lsTarg = typeof targetWindow !== "undefined" && targetWindow && targetWindow.localStorage ? targetWindow.localStorage : null;
      const readLS = (ls, k) => {
        if (!ls) return null;
        try {
          return ls.getItem(k);
        } catch (e) {
          return null;
        }
      };
      const toStr = (val) => val == null ? null : typeof val === "string" ? val : JSON.stringify(val);
      const tryParseDeep = (val) => {
        if (val == null) return null;
        if (typeof val === "string") {
          const s = val;
          if (s === "" || s === "null" || s === "undefined") return null;
          try {
            let first = JSON.parse(s);
            if (typeof first === "string") {
              try {
                first = JSON.parse(first);
              } catch (e) {
              }
            }
            return first;
          } catch (e) {
            return null;
          }
        }
        if (typeof val === "object") return val;
        return null;
      };
      const score = (obj) => {
        if (!obj) return -1;
        if (Array.isArray(obj)) return obj.length;
        if (typeof obj === "object") return Object.keys(obj).length;
        return 0;
      };
      const isEmpty = (obj) => {
        if (!obj) return true;
        if (Array.isArray(obj)) return obj.length === 0;
        if (typeof obj === "object") return Object.keys(obj).length === 0;
        return false;
      };
      let gmRaw = null;
      try {
        gmRaw = gmAvailable ? GM_getValue(keyLocal, null) : null;
      } catch (e) {
      }
      const mainRaw = readLS(lsMain, keyLocal);
      const targRaw = readLS(lsTarg, keyLocal);
      const gmParsed = typeof gmRaw === "string" ? tryParseDeep(gmRaw) : tryParseDeep(toStr(gmRaw));
      const mainParsed = tryParseDeep(mainRaw) || tryParseDeep(toStr(mainRaw));
      const targParsed = tryParseDeep(targRaw) || tryParseDeep(toStr(targRaw));
      const gmScore = score(gmParsed);
      const mnScore = score(mainParsed);
      const tgScore = score(targParsed);
      let best = null;
      let bestSrc = "none";
      if (gmParsed && !isEmpty(gmParsed)) {
        best = gmParsed;
        bestSrc = "GM";
      } else if (mainParsed && !isEmpty(mainParsed)) {
        best = mainParsed;
        bestSrc = "WIN";
      } else if (targParsed && !isEmpty(targParsed)) {
        best = targParsed;
        bestSrc = "TGT";
      }
      try {
        if (typeof productionLog === "function") {
          productionLog(`[STORAGE-CHOICE] ${keyLocal}: gm=${gmScore} win=${mnScore} tgt=${tgScore} chosen=${bestSrc}`);
        }
      } catch (_) {
      }
      if (best && (typeof best === "object" || Array.isArray(best))) {
        return best;
      }
      return typeof fallback === "undefined" ? null : fallback;
    } catch (err) {
      console.error("[MGA_loadJSON] Unexpected failure for key", keyLocal, err);
      return typeof fallback === "undefined" ? null : fallback;
    }
  }
  function MGA_saveJSON(key, value, retryCount = 0) {
    let keyLocal = key;
    let valueLocal = value;
    try {
      if (keyLocal === "MGA_petAbilityLogs" && Array.isArray(valueLocal)) {
        const fp = (l) => {
          const t = l && l.abilityType || "", p = l && l.petName || "", ts = l && l.timestamp || 0;
          return t + "|" + p + "|" + String(ts);
        };
        const map = /* @__PURE__ */ new Map();
        for (const l of valueLocal) {
          const id = l.id || fp(l);
          if (!map.has(id)) map.set(id, Object.assign({ id }, l));
        }
        valueLocal = Array.from(map.values()).sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      }
    } catch {
    }
    if (keyLocal && !keyLocal.startsWith("MGA_")) {
      console.error(`\u274C [MGA-ISOLATION] CRITICAL: Attempted to save with non-MGA key: ${keyLocal}`);
      console.error(`\u274C [MGA-ISOLATION] This would conflict with MainScript! Adding MGA_ prefix.`);
      console.trace();
      keyLocal = "MGA_" + keyLocal;
    }
    if (typeof window !== "undefined" && window.MGA_PERSISTENCE_GUARD?.initializationSavesBlocked && keyLocal === "MGA_data") {
      const stack = new Error().stack;
      if (stack && stack.includes("loadSavedData")) {
        if (typeof productionLog === "function") {
          productionLog("[PERSISTENCE-GUARD] Blocked premature save during initialization");
          productionLog("[PERSISTENCE-GUARD] This protects user data from being overwritten");
          productionLog("[PERSISTENCE-GUARD] Save will execute after initialization completes");
        }
        if (typeof UnifiedState !== "undefined" && UnifiedState?.data?.settings?.debugMode) {
          console.trace("Blocked save location:");
        }
        return false;
      }
    }
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 100;
    try {
      if (!isGMApiAvailable()) {
        return MGA_saveJSON_localStorage_fallback(keyLocal, valueLocal);
      }
      if (keyLocal === "MGA_petPresets" || keyLocal === "MGA_seedsToDelete") {
        if (typeof productionLog === "function") {
          productionLog(
            `[GM-STORAGE] Attempting to save critical data: ${keyLocal} (attempt ${retryCount + 1}/${MAX_RETRIES})`
          );
          productionLog(`[GM-STORAGE] Data type:`, typeof valueLocal);
          productionLog(`[GM-STORAGE] Data content:`, valueLocal);
        }
      }
      const jsonString = JSON.stringify(valueLocal);
      GM_setValue(keyLocal, jsonString);
      if (typeof productionLog === "function") {
        productionLog(`[GM-STORAGE] GM_setValue executed for ${keyLocal}`);
      }
      try {
        if (typeof localStorage2 !== "undefined" && localStorage2) {
          localStorage2.setItem(keyLocal, jsonString);
          if (typeof productionLog === "function") {
            productionLog(`[GM-STORAGE] Also synced to localStorage for consistency`);
          }
        }
      } catch (lsErr) {
        if (typeof productionWarn === "function") {
          productionWarn(`\u26A0\uFE0F [GM-STORAGE] Could not sync to localStorage (non-fatal):`, lsErr.message);
        }
      }
      const verification = GM_getValue(keyLocal, null);
      if (!verification) {
        console.error(`\u274C [GM-STORAGE] Save verification failed for ${keyLocal} - no data retrieved!`);
        if (retryCount < MAX_RETRIES - 1) {
          if (typeof productionLog === "function") {
            productionLog(`\u{1F504} [GM-STORAGE] Retrying save for ${keyLocal} in ${RETRY_DELAY}ms...`);
          }
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve(MGA_saveJSON(key, value, retryCount + 1));
            }, RETRY_DELAY);
          });
        }
        console.error(`\u274C [GM-STORAGE] All retry attempts failed for ${keyLocal}`);
        if (keyLocal === "MGA_petPresets" || keyLocal === "MGA_seedsToDelete") {
          alert(`\u26A0\uFE0F Failed to save ${keyLocal.replace("MGA_", "")}! Your changes may not persist.`);
        }
        return false;
      }
      if (keyLocal === "MGA_petPresets" || keyLocal === "MGA_seedsToDelete") {
        try {
          const parsedVerification = JSON.parse(verification);
          const originalKeys = Object.keys(valueLocal || {}).sort();
          const savedKeys = Object.keys(parsedVerification || {}).sort();
          if (JSON.stringify(originalKeys) !== JSON.stringify(savedKeys)) {
            if (typeof productionWarn === "function") {
              productionWarn(`\u26A0\uFE0F [GM-STORAGE] Data structure mismatch for ${keyLocal}, but save likely succeeded`);
            }
          }
          if (typeof productionLog === "function") {
            productionLog(`\u2705 [GM-STORAGE] Critical data verification passed for ${keyLocal}`);
          }
        } catch (e) {
          if (typeof productionWarn === "function") {
            productionWarn(`\u26A0\uFE0F [GM-STORAGE] Could not deep verify ${keyLocal}, but data exists`);
          }
        }
      }
      if (typeof productionLog === "function") {
        if (keyLocal === "MGA_petPresets") {
          productionLog("[GM-STORAGE] Pet presets saved successfully");
        } else if (keyLocal.startsWith("MGA_")) {
          productionLog(`[GM-STORAGE] Saved ${keyLocal}`);
        }
      }
      return true;
    } catch (error) {
      console.error(`\u274C [GM-STORAGE] Failed to save ${keyLocal}:`, error);
      console.error(`\u274C [GM-STORAGE] Error details:`, {
        name: error.name,
        message: error.message,
        gmApiAvailable: typeof GM_setValue !== "undefined",
        retryCount
      });
      const errorString = ("" + error).toLowerCase();
      if (errorString.indexOf("quota") >= 0 || errorString.indexOf("exceeded") >= 0) {
        if (typeof productionLog === "function") {
          productionLog("\u{1F9F9} [STORAGE-CLEANUP] Quota exceeded - auto-cleaning debug caches...");
        }
        const dropKeys = ["console-history", "mga-debug-cache", "mga-temp-cache"];
        for (let i = 0; i < dropKeys.length; i++) {
          try {
            localStorage2.removeItem(dropKeys[i]);
            if (typeof productionLog === "function") {
              productionLog(`\u{1F9F9} [STORAGE-CLEANUP] Removed: ${dropKeys[i]}`);
            }
          } catch (_e) {
          }
        }
        if (retryCount === 0) {
          if (typeof productionLog === "function") {
            productionLog(`\u{1F504} [STORAGE-CLEANUP] Retrying save after cleanup...`);
          }
          return MGA_saveJSON(key, value, 1);
        }
      }
      if (retryCount < MAX_RETRIES - 1) {
        if (typeof productionLog === "function") {
          productionLog(`\u{1F504} [GM-STORAGE] Retrying save for ${keyLocal} after error...`);
        }
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve(MGA_saveJSON(key, value, retryCount + 1));
          }, RETRY_DELAY);
        });
      }
      return false;
    }
  }
  function MGA_saveJSON_localStorage_fallback(key, value) {
    let valueLocal = value;
    try {
      if (key === "MGA_petAbilityLogs" && Array.isArray(valueLocal)) {
        const fp = (l) => {
          const t = l && l.abilityType || "", p = l && l.petName || "", ts = l && l.timestamp || 0;
          return t + "|" + p + "|" + String(ts);
        };
        const map = /* @__PURE__ */ new Map();
        for (const l of valueLocal) {
          const id = l.id || fp(l);
          if (!map.has(id)) map.set(id, Object.assign({ id }, l));
        }
        valueLocal = Array.from(map.values()).sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      }
    } catch {
    }
    try {
      const jsonString = JSON.stringify(valueLocal);
      StorageManager.setItem(key, jsonString);
      const verification = StorageManager.getItem(key);
      if (verification === jsonString) {
        if (typeof productionLog === "function") {
          productionLog(`[FALLBACK] Successfully saved ${key} to ${StorageManager.storageType}`);
        }
        return true;
      } else {
        console.error(`[FALLBACK] ${StorageManager.storageType} save verification failed for ${key}`);
        return false;
      }
    } catch (error) {
      const isQuotaError = error.name === "QuotaExceededError" || error.message.includes("quota") || error.message.includes("exceeded");
      if (isQuotaError) {
        console.error(`[FALLBACK] localStorage quota exceeded for ${key}!`);
        console.error(`[FALLBACK] Try clearing browser console history or other localStorage data`);
        console.error(`[FALLBACK] In Chrome DevTools: Application > Storage > Clear site data`);
        if (key === "MGA_petPresets" || key === "MGA_seedsToDelete" || key === "MGA_data") {
          alert(
            `\u26A0\uFE0F localStorage quota exceeded!

Your ${key.replace("MGA_", "")} cannot be saved.

Fix:
1. Open DevTools (F12)
2. Go to Application tab
3. Click "Clear site data"
4. Reload the page`
          );
        }
      } else {
        console.error(`[FALLBACK] localStorage save failed for ${key}:`, error);
      }
      return false;
    }
  }
  function _MGA_syncStorageBothWays() {
    try {
      const keys = [
        "MGA_data",
        "MGA_petPresets",
        "MGA_petPresetsOrder",
        "MGA_petAbilityLogs",
        "MGA_petAbilityLogs_archive",
        "MGA_seedsToDelete",
        "MGA_autoDeleteEnabled",
        "MGA_filterMode",
        "MGA_abilityFilters",
        "MGA_customMode",
        "MGA_petFilters",
        "MGA_petPresetHotkeys",
        "MGA_hotkeys"
      ];
      const gmAvailable = typeof GM_getValue === "function" && typeof GM_setValue === "function";
      const lsMain = typeof window !== "undefined" && window && window.localStorage ? window.localStorage : null;
      const lsTarg = typeof targetWindow !== "undefined" && targetWindow && targetWindow.localStorage ? targetWindow.localStorage : null;
      const readLS = (ls, k) => {
        if (!ls) return null;
        try {
          return ls.getItem(k);
        } catch (e) {
          return null;
        }
      };
      const writeLS = (ls, k, v) => {
        try {
          if (ls) ls.setItem(k, v);
        } catch (e) {
        }
      };
      const toStr = (val) => val == null ? null : typeof val === "string" ? val : JSON.stringify(val);
      const tryParse = (s) => {
        if (s == null) return null;
        try {
          const first = JSON.parse(s);
          if (typeof first === "string") {
            try {
              return JSON.parse(first);
            } catch (e) {
              return first;
            }
          }
          return first;
        } catch (e) {
          return null;
        }
      };
      const score = (obj) => {
        if (!obj) return -1;
        if (Array.isArray(obj)) return obj.length;
        if (typeof obj === "object") return Object.keys(obj).length;
        return 0;
      };
      const isEmpty = (obj) => {
        if (!obj) return true;
        if (Array.isArray(obj)) return obj.length === 0;
        if (typeof obj === "object") return Object.keys(obj).length === 0;
        return false;
      };
      keys.forEach((key) => {
        try {
          const gmRaw = gmAvailable ? GM_getValue(key, null) : null;
          const mainRaw = readLS(lsMain, key);
          const targRaw = readLS(lsTarg, key);
          const gmParsed = (typeof gmRaw === "string" ? tryParse(gmRaw) : gmRaw) || tryParse(toStr(gmRaw));
          const mainParsed = tryParse(mainRaw) || tryParse(toStr(mainRaw));
          const targParsed = tryParse(targRaw) || tryParse(toStr(targRaw));
          let best = null;
          if (gmParsed && !isEmpty(gmParsed)) best = gmParsed;
          else if (mainParsed && !isEmpty(mainParsed)) best = mainParsed;
          else if (targParsed && !isEmpty(targParsed)) best = targParsed;
          if (best && (typeof best === "object" || Array.isArray(best))) {
            const stable = JSON.stringify(best);
            try {
              if (gmAvailable) GM_setValue(key, stable);
            } catch (e) {
            }
            writeLS(lsMain, key, stable);
            writeLS(lsTarg, key, stable);
            if (typeof productionLog === "function") {
              productionLog(`[STORAGE-SYNC] ${key}: canonicalized across GM/WIN/TGT`);
            }
          }
        } catch (innerErr) {
          console.error("[STORAGE-SYNC] Error while syncing key", key, innerErr);
        }
      });
    } catch (err) {
      console.error("[STORAGE-SYNC] Sync failed:", err);
    }
  }

  // src/utils/constants.js
  var CONFIG = {
    // Version Information
    VERSION: {
      CURRENT: "2.0.0",
      CHECK_URL_STABLE: "https://raw.githubusercontent.com/Myke247/MGTools/main/MGTools.user.js",
      CHECK_URL_BETA: "https://raw.githubusercontent.com/Myke247/MGTools/Live-Beta/MGTools.user.js",
      DOWNLOAD_URL_STABLE: "https://github.com/Myke247/MGTools/raw/refs/heads/main/MGTools.user.js",
      DOWNLOAD_URL_BETA: "https://github.com/Myke247/MGTools/raw/refs/heads/Live-Beta/MGTools.user.js"
    },
    // Debug Settings
    DEBUG: {
      PRODUCTION: true,
      // Set to false for verbose debug logging
      FLAGS: {
        OVERLAY_LIFECYCLE: false,
        HANDLER_SETUP: false,
        THEME_APPLICATION: false,
        VALUE_CALCULATIONS: false,
        ABILITY_LOGS: false,
        BUTTON_INTERACTIONS: false,
        POP_OUT_DESIGN: false,
        ERROR_TRACKING: true,
        PERFORMANCE: false,
        FIX_VALIDATION: false
        // Enable to see fix debug logs during testing (now controlled by debugMode setting)
      }
    },
    // UI Settings
    UI: {
      DEFAULT_OPACITY: 95,
      DEFAULT_POPOUT_OPACITY: 50,
      DEFAULT_THEME: "default",
      DEFAULT_GRADIENT: "blue-purple",
      DEFAULT_EFFECT: "none",
      DOCK_WIDTH: 380,
      DOCK_MIN_WIDTH: 320,
      DOCK_MAX_WIDTH: 600,
      TAB_HEIGHT: 40,
      ANIMATION_DURATION: 300
    },
    // Timing Settings
    TIMERS: {
      AUTO_SAVE_INTERVAL: 3e4,
      // 30 seconds
      CONNECTION_CHECK_INTERVAL: 5e3,
      // 5 seconds
      HEARTBEAT_INTERVAL: 3e5,
      // 5 minutes
      SHOP_CHECK_INTERVAL: 3e3,
      // 3 seconds
      PET_HUNGER_CHECK_INTERVAL: 6e4
      // 1 minute
    },
    // API Settings
    API: {
      BASE_URL_PRIMARY: "https://magiccircle.gg",
      BASE_URL_FALLBACK: "https://magicgarden.gg",
      ENDPOINTS: {
        ROOMS: "/api/rooms",
        SHOP: "/api/shop",
        PETS: "/api/pets",
        INVENTORY: "/api/inventory"
      }
    },
    // Game Data - Decoration Items
    DECOR_ITEMS: [
      // Rocks
      { id: "SmallRock", name: "Small Garden Rock", category: "Rocks" },
      { id: "MediumRock", name: "Medium Garden Rock", category: "Rocks" },
      { id: "LargeRock", name: "Large Garden Rock", category: "Rocks" },
      // Wood Items
      { id: "WoodBench", name: "Wood Bench", category: "Wood" },
      { id: "WoodArch", name: "Wood Arch", category: "Wood" },
      { id: "WoodBridge", name: "Wood Bridge", category: "Wood" },
      { id: "WoodLampPost", name: "Wood Lamp Post", category: "Wood" },
      { id: "WoodOwl", name: "Wood Owl", category: "Wood" },
      { id: "WoodBirdhouse", name: "Wood Birdhouse", category: "Wood" },
      // Stone Items
      { id: "StoneBench", name: "Stone Bench", category: "Stone" },
      { id: "StoneArch", name: "Stone Arch", category: "Stone" },
      { id: "StoneBridge", name: "Stone Bridge", category: "Stone" },
      { id: "StoneLampPost", name: "Stone Lamp Post", category: "Stone" },
      { id: "StoneGnome", name: "Stone Gnome", category: "Stone" },
      { id: "StoneBirdbath", name: "Stone Birdbath", category: "Stone" },
      // Marble Items
      { id: "MarbleBench", name: "Marble Bench", category: "Marble" },
      { id: "MarbleArch", name: "Marble Arch", category: "Marble" },
      { id: "MarbleBridge", name: "Marble Bridge", category: "Marble" },
      { id: "MarbleLampPost", name: "Marble Lamp Post", category: "Marble" }
    ]
  };
  var CURRENT_VERSION = CONFIG.VERSION.CURRENT;
  var VERSION_CHECK_URL_STABLE = CONFIG.VERSION.CHECK_URL_STABLE;
  var VERSION_CHECK_URL_BETA = CONFIG.VERSION.CHECK_URL_BETA;
  var STABLE_DOWNLOAD_URL = CONFIG.VERSION.DOWNLOAD_URL_STABLE;
  var BETA_DOWNLOAD_URL = CONFIG.VERSION.DOWNLOAD_URL_BETA;
  var IS_LIVE_BETA = (() => {
    try {
      if (typeof GM_info === "undefined") {
        return false;
      }
      return GM_info?.script?.updateURL?.includes("Live-Beta") || false;
    } catch (e) {
      console.warn("[MGTOOLS] Branch detection failed:", e.message);
      return false;
    }
  })();
  var isRunningWithoutTampermonkey = typeof GM_info === "undefined";
  if (isRunningWithoutTampermonkey) {
    console.error("%c\u26A0\uFE0F MGTOOLS INSTALLATION ERROR", "font-size:16px;color:#ff0000;font-weight:bold");
    console.error("%cMGTools MUST be installed via Tampermonkey!", "font-size:14px;color:#ff9900");
    console.error("%cDo NOT paste the script in console - it will not work correctly!", "font-size:14px;color:#ff9900");
    console.error(
      '%c\n\u{1F4CB} Correct Installation:\n1. Install Tampermonkey: https://www.tampermonkey.net/\n2. Click: https://github.com/Myke247/MGTools/raw/main/MGTools.user.js\n3. Click "Install" button\n4. Refresh Magic Garden',
      "font-size:12px;color:#00ffff"
    );
    console.warn("%c\u26A0\uFE0F Attempting to run in fallback mode (limited functionality)...", "font-size:12px;color:#ffff00");
  }
  function compareVersions(v1, v2) {
    const parts1 = v1.split(".").map(Number);
    const parts2 = v2.split(".").map(Number);
    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const part1 = parts1[i] || 0;
      const part2 = parts2[i] || 0;
      if (part1 > part2) return 1;
      if (part1 < part2) return -1;
    }
    return 0;
  }

  // src/core/logging.js
  var logging_exports = {};
  __export(logging_exports, {
    Logger: () => Logger,
    debugError: () => debugError,
    debugLog: () => debugLog2,
    logDebug: () => logDebug,
    logError: () => logError,
    logInfo: () => logInfo2,
    logWarn: () => logWarn2,
    productionError: () => productionError,
    productionLog: () => productionLog2,
    productionWarn: () => productionWarn2
  });
  var Logger = (() => {
    const PRODUCTION = CONFIG.DEBUG.PRODUCTION;
    const DEBUG_FLAGS = CONFIG.DEBUG.FLAGS;
    const LogLevel = {
      NONE: 0,
      ERROR: 1,
      WARN: 2,
      INFO: 3,
      DEBUG: 4
    };
    const CURRENT_LOG_LEVEL = PRODUCTION ? LogLevel.WARN : LogLevel.DEBUG;
    const tooltipContainer = null;
    function log(level, category, message, data) {
      if (level > CURRENT_LOG_LEVEL) return;
      const prefix = `[${category}]`;
      const args = data !== void 0 ? [prefix, message, data] : [prefix, message];
      if (level === LogLevel.ERROR) console.error(...args);
      else if (level === LogLevel.WARN) console.warn(...args);
      else console.log(...args);
    }
    function debugLog3(flag, message, data = null) {
      if (!PRODUCTION && DEBUG_FLAGS[flag]) {
        const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
        log(LogLevel.DEBUG, `DEBUG-${flag}`, `${timestamp} ${message}`, data);
      }
    }
    function debugError2(flag, message, error, context = {}) {
      if (DEBUG_FLAGS[flag] || DEBUG_FLAGS.ERROR_TRACKING) {
        const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
        log(LogLevel.ERROR, `ERROR-${flag}`, `${timestamp} ${message}`, {
          error,
          context,
          stack: error?.stack
        });
      }
    }
    const api = {
      // Core logging methods
      error: (cat, msg, data) => log(LogLevel.ERROR, cat, msg, data),
      warn: (cat, msg, data) => log(LogLevel.WARN, cat, msg, data),
      info: (cat, msg, data) => log(LogLevel.INFO, cat, msg, data),
      debug: (cat, msg, data) => log(LogLevel.DEBUG, cat, msg, data),
      // Debug logging methods
      debugLog: debugLog3,
      debugError: debugError2,
      // Legacy support methods
      productionLog: (...args) => {
        const message = String(args[0] || "");
        const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
        const category = categoryMatch ? categoryMatch[1] : "LEGACY";
        api.info(category, ...args);
      },
      productionWarn: (...args) => {
        const message = String(args[0] || "");
        const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
        const category = categoryMatch ? categoryMatch[1] : "LEGACY";
        api.warn(category, ...args);
      },
      productionError: (...args) => {
        const message = String(args[0] || "");
        const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
        const category = categoryMatch ? categoryMatch[1] : "LEGACY";
        api.error(category, ...args);
      }
    };
    return api;
  })();
  var logError = Logger.error;
  var logWarn2 = Logger.warn;
  var logInfo2 = Logger.info;
  var logDebug = Logger.debug;
  var debugLog2 = Logger.debugLog;
  var debugError = Logger.debugError;
  var productionLog2 = Logger.productionLog;
  var productionWarn2 = Logger.productionWarn;
  var productionError = Logger.productionError;

  // src/core/compat.js
  var compat_exports = {};
  __export(compat_exports, {
    CompatibilityMode: () => CompatibilityMode,
    isUserscript: () => isUserscript,
    targetDocument: () => targetDocument,
    targetWindow: () => targetWindow2
  });
  (function() {
    try {
      const isDiscord = /discord|overlay|electron/i.test(navigator.userAgent) || window.DiscordNative || window.__discordApp;
      if (isDiscord) {
        console.log("\u{1F6E1}\uFE0F [CSP] External font loads disabled in Discord context.");
      }
      const origCreateElement = Document.prototype.createElement;
      Document.prototype.createElement = function(tag) {
        const el2 = origCreateElement.call(this, tag);
        try {
          if (isDiscord && tag && tag.toLowerCase() === "link") {
            const origSetAttribute = el2.setAttribute;
            el2.setAttribute = function(name, value) {
              if (name === "href" && typeof value === "string" && /fonts\.googleapis/i.test(value)) {
                console.log("\u{1F6E1}\uFE0F [CSP] Prevented external font link injection:", value);
                return;
              }
              return origSetAttribute.apply(this, arguments);
            };
          }
        } catch (_) {
        }
        return el2;
      };
    } catch (_) {
    }
  })();
  var CompatibilityMode = {
    flags: {
      enabled: false,
      blockExternalFonts: false,
      blockExternalBeacons: false,
      wsReconnectWhenHidden: false,
      strictNoEvalDynamicImport: false,
      inlineAssetsOnly: false,
      uiReducedMode: false,
      domOnlyStyles: false,
      bypassCSPNetworking: false
    },
    detectionComplete: false,
    cspViolations: [],
    detectionReason: null,
    detect() {
      try {
        const disabled = localStorage.getItem("mgtools_compat_disabled");
        if (disabled === "true") {
          console.log("[COMPAT] Compatibility mode disabled by user");
          this.detectionComplete = true;
          return;
        }
        const forced = localStorage.getItem("mgtools_compat_forced");
        if (forced === "true") {
          this.enableCompat("user-forced");
          this.detectionComplete = true;
          return;
        }
      } catch (e) {
        console.warn("[COMPAT] Unable to check localStorage for compat settings", e);
      }
      const host = window.location.host;
      const isDiscordEmbed = host.includes("discordsays.com") || host.includes("discordactivities.com") || host.includes("discord.gg") || host.includes("discord.com") || // Check for Discord SDK presence
      typeof window.DiscordSDK !== "undefined" || typeof window.__DISCORD__ !== "undefined" || typeof window.DiscordNative !== "undefined";
      if (isDiscordEmbed) {
        this.enableCompat("discord-embed");
        this.detectionComplete = true;
        return;
      }
      const originalError = console.error.bind(console);
      const self = this;
      const seenCSPMessages = /* @__PURE__ */ new Set();
      console.error = function(...args) {
        const msg = args.join(" ");
        if ((msg.includes("Content Security Policy") || msg.includes("Refused to load") || msg.includes("violates the following")) && !msg.includes("mgtools")) {
          if (seenCSPMessages.has(msg)) {
            return;
          }
          seenCSPMessages.add(msg);
          self.cspViolations.push(msg);
          if (self.cspViolations.length >= 2 && !self.flags.enabled) {
            self.enableCompat("csp-violations");
          }
        }
        return originalError.apply(console, args);
      };
      setTimeout(() => {
        if (!this.flags.enabled) {
          try {
            const testKey = "__mgtools_compat_test_" + Date.now();
            GM_setValue(testKey, "test");
            GM_deleteValue(testKey);
          } catch (e) {
            this.enableCompat("storage-failed");
          }
        }
        this.detectionComplete = true;
        if (this.flags.enabled) {
          console.log("[COMPAT] Compatibility mode ACTIVE", {
            reason: this.detectionReason,
            violations: this.cspViolations.length
          });
        } else {
          console.log("[COMPAT] Compatibility mode not needed, running in normal mode");
        }
      }, 500);
    },
    enableCompat(reason) {
      if (this.flags.enabled) return;
      console.log(`[COMPAT] Enabling compatibility mode: ${reason}`);
      const isDiscordReason = reason.includes("discord") || reason.includes("csp");
      if (isDiscordReason) {
        console.log("\u{1F3AE} [DISCORD] Compatibility mode activated for Discord environment");
        console.log("   \u{1F4CB} [DISCORD] Features enabled:");
        console.log("      \u2022 Inline styles only (no external CSS)");
        console.log("      \u2022 System fonts (no Google Fonts CDN)");
        console.log("      \u2022 GM_xmlhttpRequest for network requests");
        console.log("      \u2022 DOM mutation observer for UI persistence");
      }
      this.detectionReason = reason;
      this.flags.enabled = true;
      this.flags.blockExternalFonts = true;
      this.flags.blockExternalBeacons = true;
      this.flags.wsReconnectWhenHidden = true;
      this.flags.strictNoEvalDynamicImport = true;
      this.flags.inlineAssetsOnly = true;
      this.flags.uiReducedMode = true;
      this.flags.domOnlyStyles = true;
      this.flags.bypassCSPNetworking = true;
      try {
        localStorage.setItem("mgtools_compat_mode", "true");
        localStorage.setItem("mgtools_compat_reason", reason);
      } catch (e) {
      }
    },
    disableCompat() {
      this.flags.enabled = false;
      Object.keys(this.flags).forEach((key) => {
        if (key !== "enabled") this.flags[key] = false;
      });
      try {
        localStorage.setItem("mgtools_compat_disabled", "true");
        localStorage.removeItem("mgtools_compat_mode");
      } catch (e) {
      }
      console.log("[COMPAT] Compatibility mode disabled");
    },
    isEnabled() {
      return this.flags.enabled;
    }
  };
  CompatibilityMode.detect();
  var isUserscript = typeof unsafeWindow !== "undefined";
  var targetWindow2 = isUserscript ? unsafeWindow : window;
  var targetDocument = targetWindow2.document;
  console.log("[COMPAT] Context isolation initialized:", {
    isUserscript,
    targetWindowType: targetWindow2.constructor.name,
    sameAsWindow: targetWindow2 === window
  });

  // src/core/network.js
  var network_exports = {};
  __export(network_exports, {
    Network: () => Network,
    WebSocketManager: () => WebSocketManager,
    apiV1RoomInfoUrl: () => apiV1RoomInfoUrl,
    fetchLatestVersionMeta: () => fetchLatestVersionMeta,
    fetchRoomInfo: () => fetchRoomInfo,
    parsePlayerCount: () => parsePlayerCount
  });
  var Network = {
    /**
     * Make HTTP request with CSP-aware path selection
     * @param {string} url - Request URL
     * @param {Object} opts - Request options
     * @param {string} [opts.method='GET'] - HTTP method
     * @param {Object} [opts.headers={}] - Request headers
     * @param {*} [opts.body] - Request body
     * @param {number} [opts.timeout=10000] - Timeout in ms
     * @returns {Promise<Response>} - Fetch-compatible response object
     */
    async request(url, opts = {}) {
      const method = opts.method || "GET";
      const headers = opts.headers || {};
      const body = opts.body;
      const timeout = opts.timeout || 1e4;
      const isCrossOrigin = !url.startsWith(location.origin);
      const needsBypass = CompatibilityMode.flags.bypassCSPNetworking && isCrossOrigin && typeof GM_xmlhttpRequest === "function";
      if (needsBypass) {
        Logger.debug("NETWORK", `Using GM_xmlhttpRequest for: ${url}`);
        return new Promise((resolve, reject) => {
          GM_xmlhttpRequest({
            url,
            method,
            headers,
            data: body,
            responseType: "text",
            timeout,
            onload: (response) => {
              resolve({
                ok: response.status >= 200 && response.status < 300,
                status: response.status,
                statusText: response.statusText,
                headers: {
                  get: (name) => {
                    const match = response.responseHeaders.match(new RegExp(`^${name}:\\s*(.*)$`, "mi"));
                    return match ? match[1] : null;
                  }
                },
                text: () => Promise.resolve(response.responseText),
                json: () => Promise.resolve(JSON.parse(response.responseText))
              });
            },
            onerror: (error) => reject(new Error(error.statusText || "Network error")),
            ontimeout: () => reject(new Error("Request timeout"))
          });
        });
      } else {
        return fetch(url, {
          method,
          headers,
          body,
          signal: opts.signal
        });
      }
    },
    /**
     * Convenience GET method
     * @param {string} url - Request URL
     * @param {Object} opts - Request options
     * @returns {Promise<Response>}
     */
    get(url, opts = {}) {
      return this.request(url, { ...opts, method: "GET" });
    },
    /**
     * Convenience POST method
     * @param {string} url - Request URL
     * @param {*} body - Request body
     * @param {Object} opts - Request options
     * @returns {Promise<Response>}
     */
    post(url, body, opts = {}) {
      return this.request(url, { ...opts, method: "POST", body });
    }
  };
  function apiV1RoomInfoUrl(idOrCode, endpoint = "info") {
    const base = CONFIG.API.BASE_URL_PRIMARY;
    return `${base}/api/rooms/${encodeURIComponent(idOrCode)}/${endpoint}`;
  }
  async function fetchRoomInfo(idOrCode, opts = {}) {
    const endpoint = opts.endpoint ?? "info";
    const timeoutMs = opts.timeoutMs ?? 1e4;
    const url = apiV1RoomInfoUrl(idOrCode, endpoint);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await Network.request(url, {
        method: "GET",
        signal: controller.signal
      });
      const body = await res.text();
      const parsed = res.ok ? JSON.parse(body) : void 0;
      return {
        status: res.status,
        ok: res.ok,
        body,
        parsed
      };
    } catch (err) {
      throw new Error(`Room endpoint fetch failed: ${err.message}`);
    } finally {
      clearTimeout(timeout);
    }
  }
  function parsePlayerCount(data) {
    if (!data) return 0;
    const count = data?.numPlayers ?? data?.players?.online ?? data?.players?.count ?? data?.online ?? data?.count ?? data?.playerCount ?? 0;
    return Math.max(0, Number(count) || 0);
  }
  async function fetchLatestVersionMeta() {
    const IS_LIVE_BETA2 = CONFIG.VERSION.CURRENT.includes("beta") || typeof GM_info !== "undefined" && GM_info?.script?.updateURL?.includes("Live-Beta");
    const branch = IS_LIVE_BETA2 ? "Live-Beta" : "main";
    const branchName = IS_LIVE_BETA2 ? "Live Beta" : "Stable";
    const cacheBust = `?t=${Date.now()}`;
    const urls = [
      `${CONFIG.VERSION.CHECK_URL_STABLE.replace("/main/", `/${branch}/`)}${cacheBust}`,
      `${CONFIG.VERSION.CHECK_URL_STABLE}${cacheBust}`,
      // fallback to main
      "https://api.github.com/repos/Myke247/MGTools/contents/MGTools.user.js"
      // API endpoint
    ];
    for (let i = 0; i < urls.length; i++) {
      try {
        const url = urls[i];
        const isGitHubAPI = url.includes("api.github.com");
        const response = await fetch(url, {
          method: "GET",
          cache: "no-cache",
          headers: isGitHubAPI ? { Accept: "application/vnd.github.v3.raw" } : {}
        });
        if (!response.ok) {
          if (i === urls.length - 1) {
            throw new Error(`All URLs failed. Last: ${response.status}`);
          }
          continue;
        }
        const text = await response.text();
        const match = text.match(/@version\s+([\d.]+)/);
        if (match) {
          return {
            version: match[1],
            branch: branchName
          };
        } else {
          throw new Error("Version not found in response");
        }
      } catch (e) {
        if (i === urls.length - 1) {
          throw new Error(`Failed to fetch version metadata: ${e.message}`);
        }
      }
    }
    throw new Error("All version fetch attempts failed");
  }
  var WebSocketManager = (() => {
    const Native = typeof window !== "undefined" ? window.WebSocket : null;
    let socket = null;
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    const eventHandlers5 = {
      open: [],
      close: [],
      error: [],
      message: [],
      reconnect: []
    };
    const MAX_ATTEMPTS = 6;
    const BACKOFF_MS = [1e3, 2e3, 4e3, 8e3, 16e3, 32e3];
    function getBackoffDelay(attempt) {
      const index = Math.min(attempt, BACKOFF_MS.length - 1);
      return BACKOFF_MS[index];
    }
    function emit3(event, data) {
      if (eventHandlers5[event]) {
        eventHandlers5[event].forEach((handler) => {
          try {
            handler(data);
          } catch (e) {
            Logger.error("WEBSOCKET", `Event handler error for ${event}`, e);
          }
        });
      }
    }
    function handleClose(event) {
      const { code, wasClean, reason } = event;
      Logger.info("WEBSOCKET", `Closed - Code: ${code}, Clean: ${wasClean}, Reason: "${reason || "none"}"`);
      emit3("close", { code, wasClean, reason });
      if (code === 4710 || /version.?expired/i.test(reason || "")) {
        Logger.info("WEBSOCKET", "Version expired detected (code 4710)");
        emit3("reconnect", { type: "version_expired", code, reason });
        return;
      }
      if (wasClean && code !== 1006 && !/update/i.test(reason || "")) {
        Logger.info("WEBSOCKET", "Clean close detected - no reconnect needed");
        return;
      }
      if (reconnectAttempts >= MAX_ATTEMPTS) {
        Logger.warn("WEBSOCKET", `Max reconnect attempts (${MAX_ATTEMPTS}) reached`);
        emit3("reconnect", { type: "max_attempts", attempts: reconnectAttempts });
        return;
      }
      reconnectAttempts++;
      const delay = getBackoffDelay(reconnectAttempts);
      Logger.info("WEBSOCKET", `Reconnect attempt ${reconnectAttempts}/${MAX_ATTEMPTS} in ${delay}ms (code: ${code})`);
      emit3("reconnect", {
        type: "scheduled",
        attempt: reconnectAttempts,
        maxAttempts: MAX_ATTEMPTS,
        delayMs: delay,
        code,
        reason
      });
      reconnectTimer = setTimeout(() => {
        Logger.info("WEBSOCKET", `Attempting reconnect (${reconnectAttempts}/${MAX_ATTEMPTS})`);
      }, delay);
    }
    function handleOpen() {
      Logger.info("WEBSOCKET", "Connection established successfully");
      reconnectAttempts = 0;
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      emit3("open", {});
    }
    function handleError(event) {
      Logger.error("WEBSOCKET", "Error detected", event);
      emit3("error", event);
    }
    function handleMessage(event) {
      emit3("message", event.data);
    }
    return {
      /**
       * Connect to WebSocket with auto-reconnect
       * @param {string} url - WebSocket URL
       * @param {Object} opts - Options
       * @param {Array<string>} [opts.protocols] - WebSocket protocols
       * @returns {WebSocket} - WebSocket instance
       */
      connect(url, opts = {}) {
        if (!Native) {
          throw new Error("WebSocket not available");
        }
        socket = new Native(url, opts.protocols);
        socket.addEventListener("open", handleOpen);
        socket.addEventListener("close", handleClose);
        socket.addEventListener("error", handleError);
        socket.addEventListener("message", handleMessage);
        Logger.info("WEBSOCKET", `Connecting to ${url}`);
        return socket;
      },
      /**
       * Send data via WebSocket
       * @param {*} data - Data to send
       */
      send(data) {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
          Logger.warn("WEBSOCKET", "Cannot send - socket not open");
          return false;
        }
        socket.send(data);
        return true;
      },
      /**
       * Close WebSocket connection
       * @param {number} [code=1000] - Close code
       * @param {string} [reason=''] - Close reason
       */
      close(code = 1e3, reason = "") {
        if (socket) {
          socket.close(code, reason);
        }
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
      },
      /**
       * Register event handler
       * @param {string} event - Event name ('open', 'close', 'error', 'message', 'reconnect')
       * @param {Function} handler - Event handler function
       */
      on(event, handler) {
        if (eventHandlers5[event]) {
          eventHandlers5[event].push(handler);
        }
      },
      /**
       * Unregister event handler
       * @param {string} event - Event name
       * @param {Function} handler - Event handler function
       */
      off(event, handler) {
        if (eventHandlers5[event]) {
          eventHandlers5[event] = eventHandlers5[event].filter((h) => h !== handler);
        }
      },
      /**
       * Get current connection status
       * @returns {Object} - { connected: boolean, attempts: number }
       */
      getStatus() {
        return {
          connected: socket && socket.readyState === WebSocket.OPEN,
          attempts: reconnectAttempts,
          maxAttempts: MAX_ATTEMPTS
        };
      }
    };
  })();

  // src/core/atoms.js
  var atoms_exports = {};
  __export(atoms_exports, {
    default: () => atoms_default,
    getAtomValueFresh: () => getAtomValueFresh,
    getCropHash: () => getCropHash,
    hookAtom: () => hookAtom,
    listenToSlotIndexAtom: () => listenToSlotIndexAtom,
    readAtom: () => readAtom
  });
  var hookedAtoms = /* @__PURE__ */ new Set();
  var atomReferences = /* @__PURE__ */ new Map();
  function readAtom(atomName, dependencies = {}) {
    const { window: win = typeof window !== "undefined" ? window : null, unsafeWindow: unsafeWin = null } = dependencies;
    const globalUnsafeWindow = typeof unsafeWindow !== "undefined" ? unsafeWindow : null;
    const gw = unsafeWin || globalUnsafeWindow || win;
    try {
      if (gw?.MGTools?.store?.getAtomValue) {
        return gw.MGTools.store.getAtomValue(atomName);
      }
    } catch (e) {
    }
    return null;
  }
  function getAtomValueFresh(windowKey, dependencies = {}) {
    const {
      atomReferences: atomRefs = atomReferences,
      console: consoleObj = typeof console !== "undefined" ? console : null
    } = dependencies;
    const ref = atomRefs.get(windowKey);
    if (!ref) {
      consoleObj?.warn(`[MGTools] No atom reference stored for '${windowKey}'`);
      return null;
    }
    try {
      const currentState = ref.atomCache.get(ref.atomPath);
      if (!currentState || !currentState.v) {
        consoleObj?.warn(`[MGTools] Atom '${windowKey}' has no current state`);
        return null;
      }
      consoleObj?.log(`[MGTools] \u{1F504} Got fresh data for '${windowKey}' from atom cache`);
      return currentState.v;
    } catch (error) {
      consoleObj?.error(`[MGTools] Error getting fresh atom value for '${windowKey}':`, error);
      return null;
    }
  }
  function hookAtom(atomPath, windowKey, callback = null, retryCount = 0, dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      hookedAtoms: hookedAtomsSet = hookedAtoms,
      atomReferences: atomRefs = atomReferences,
      productionLog: productionLog3 = () => {
      },
      productionWarn: productionWarn3 = () => {
      },
      console: consoleObj = typeof console !== "undefined" ? console : null
    } = dependencies;
    const maxRetries = 60;
    const hookKey = `${atomPath}_${windowKey}`;
    if (retryCount === 0 && hookedAtomsSet.has(hookKey)) {
      productionLog3(`[HOOK] Already hooked: ${windowKey} - skipping duplicate`);
      return;
    }
    if (retryCount === 0) {
      consoleObj?.log(
        "  - targetWindow.jotaiAtomCache:",
        typeof targetWindow3.jotaiAtomCache,
        targetWindow3.jotaiAtomCache
      );
      consoleObj?.log(
        "  - isUserscript:",
        typeof unsafeWindow !== "undefined",
        "(using unsafeWindow:",
        typeof unsafeWindow !== "undefined" ? "YES" : "NO)"
      );
      const jotaiKeys = Object.keys(targetWindow3).filter((k) => k.toLowerCase().includes("jotai"));
      consoleObj?.log('  - Keys with "jotai" on targetWindow:', jotaiKeys);
    }
    let atomCache = null;
    if (targetWindow3.jotaiAtomCache) {
      atomCache = targetWindow3.jotaiAtomCache.cache || targetWindow3.jotaiAtomCache;
    }
    if (!atomCache && window.jotaiAtomCache) {
      atomCache = window.jotaiAtomCache.cache || window.jotaiAtomCache;
    }
    if (!atomCache && window.top && window.top.jotaiAtomCache) {
      atomCache = window.top.jotaiAtomCache.cache || window.top.jotaiAtomCache;
    }
    if (!atomCache || !atomCache.get) {
      if (retryCount >= maxRetries) {
        consoleObj?.error(
          `\u274C [ATOM-HOOK] Gave up waiting for atom store for ${windowKey} after ${maxRetries} retries (${maxRetries / 2}s)`
        );
        consoleObj?.error(`\u274C [ATOM-HOOK] Final check - targetWindow.jotaiAtomCache:`, targetWindow3.jotaiAtomCache);
        consoleObj?.error(`\u274C [ATOM-HOOK] Using unsafeWindow:`, typeof unsafeWindow !== "undefined");
        consoleObj?.error(`\u274C [ATOM-HOOK] Script will continue with reduced functionality`);
        productionWarn3(`\u26A0\uFE0F [ATOM-HOOK] Gave up waiting for atom store for ${windowKey} after ${maxRetries} retries`);
        productionWarn3(`\u26A0\uFE0F [ATOM-HOOK] Script will continue with reduced functionality`);
        return;
      }
      const delay = Math.min(50 * Math.pow(2, Math.min(retryCount, 3)), 500);
      setTimeout(() => hookAtom(atomPath, windowKey, callback, retryCount + 1, dependencies), delay);
      return;
    }
    productionLog3(`\u{1F517} Attempting to hook atom: ${windowKey} at path: ${atomPath}`);
    try {
      const atom = atomCache.get(atomPath);
      if (!atom || !atom.read) {
        productionWarn3(`\u274C Could not find atom for ${atomPath}`);
        const allAtoms = Array.from(atomCache.keys());
        const petAtoms = allAtoms.filter((key) => key.includes("Pet") || key.includes("pet") || key.includes("Slot"));
        productionLog3("\u{1F50D} Pet-related atoms:", petAtoms);
        productionLog3("\u{1F50D} All atoms (first 20):", allAtoms.slice(0, 20));
        return;
      }
      const originalRead = atom.read;
      atom.read = function(get) {
        const rawValue = originalRead.call(this, get);
        if (windowKey === "activePets" && UnifiedState3?.data?.settings?.debugMode) {
          productionLog3(`\u{1F43E} [ATOM-DEBUG] ${windowKey} raw value:`, {
            value: rawValue,
            type: typeof rawValue,
            isArray: Array.isArray(rawValue),
            length: rawValue?.length,
            firstItem: rawValue?.[0]
          });
        }
        let finalValue = rawValue;
        if (callback) {
          const callbackResult = callback(rawValue);
          if (callbackResult !== void 0) {
            finalValue = callbackResult;
            if (windowKey === "activePets" && UnifiedState3?.data?.settings?.debugMode) {
              productionLog3(`\u{1F43E} [ATOM-DEBUG] ${windowKey} transformed by callback:`, finalValue);
            }
          }
        }
        UnifiedState3.atoms[windowKey] = finalValue;
        window[windowKey] = finalValue;
        if (windowKey === "activePets" && UnifiedState3?.data?.settings?.debugMode) {
          productionLog3(`\u{1F43E} [ATOM-DEBUG] ${windowKey} stored in UnifiedState:`, {
            count: finalValue?.length || 0,
            value: finalValue
          });
        }
        return rawValue;
      };
      productionLog3(`\u2705 hookAtom: Successfully hooked ${windowKey}`);
      hookedAtomsSet.add(hookKey);
      atomRefs.set(windowKey, {
        atom,
        atomCache,
        atomPath
      });
      productionLog3(`\u{1F4E6} Stored atom reference for ${windowKey} (can now re-query for fresh data)`);
    } catch (error) {
      consoleObj?.error(`\u274C Error hooking ${atomPath}:`, error);
    }
  }
  function getCropHash(crop) {
    try {
      return JSON.stringify(crop);
    } catch (e) {
      return "__ref_changed__" + Date.now();
    }
  }
  function listenToSlotIndexAtom(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      productionLog: productionLog3 = () => {
      },
      console: consoleObj = typeof console !== "undefined" ? console : null,
      insertTurtleEstimate: insertTurtleEstimate3 = null,
      CONFIG: CONFIG2 = { DEBUG: { FLAGS: { FIX_VALIDATION: false } } },
      queueMicrotask: qmt = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn),
      getCropHash: getCropHashFn = getCropHash
    } = dependencies;
    productionLog3("\u{1F50D} [SLOT-ATOM] Starting slot index atom listener...");
    if (typeof targetWindow3._mgtools_currentSlotIndex === "undefined") {
      targetWindow3._mgtools_currentSlotIndex = 0;
      consoleObj?.log("\u{1F3AF} [SLOT-ATOM] Initialized slot index to 0");
    }
    const tryHookingViaCache = () => {
      const atomCache = targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache;
      if (!atomCache || !atomCache.get) {
        productionLog3("\u23F3 [SLOT-ATOM] Waiting for jotaiAtomCache...");
        return false;
      }
      const possiblePaths = [
        "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotIndexAtom",
        "myCurrentGrowSlotIndexAtom",
        "myCurrentGrowSlotIndex"
      ];
      for (const path of possiblePaths) {
        const atom = atomCache.get(path);
        if (atom && atom.read) {
          productionLog3(`\u2705 [SLOT-ATOM] Found slot atom at: ${path}`);
          const originalRead = atom.read;
          atom.read = function(get) {
            const value = originalRead.call(this, get);
            const idx = Number.isFinite(value) ? value : 0;
            if (targetWindow3._mgtools_currentSlotIndex !== idx) {
              targetWindow3._mgtools_currentSlotIndex = idx;
              consoleObj?.log(`\u{1F3AF} [SLOT-ATOM-CACHE] Slot index changed to: ${idx}`);
              if (insertTurtleEstimate3 && typeof insertTurtleEstimate3 === "function") {
                requestAnimationFrame(() => insertTurtleEstimate3(dependencies));
              }
            }
            return value;
          };
          return true;
        }
      }
      const allAtoms = Array.from(atomCache.keys());
      const slotAtoms = allAtoms.filter(
        (key) => key.includes("Slot") || key.includes("slot") || key.includes("Index") || key.includes("index")
      );
      productionLog3("\u{1F50D} [SLOT-ATOM] Slot-related atoms found:", slotAtoms);
      const slotIndexAtom = slotAtoms.find((key) => key.includes("GrowSlotIndex") || key.includes("CurrentGrowSlotIndex"));
      if (slotIndexAtom) {
        productionLog3(`\u{1F3AF} [SLOT-ATOM] Found potential slot atom: ${slotIndexAtom}`);
        return tryHookingViaCache();
      }
      return false;
    };
    const setupKeyWatcher = () => {
      productionLog3("\u{1F3AE} [SLOT-ATOM] Setting up X/C key and arrow click watcher as fallback...");
      let lastCropHash = "";
      const getCropHashSimple = (crops) => {
        if (!crops || !crops.length) return "";
        return crops.map((c) => `${c.species}_${c.endTime}`).join("|");
      };
      function findAtom(cache, names = ["myCurrentGrowSlotIndexAtom"]) {
        if (!cache) return null;
        if (cache.get) {
          for (const n of names) {
            if (cache.get(n)) return cache.get(n);
          }
          for (const [k, v] of cache.entries?.() ?? []) {
            if (names.some((n) => k.endsWith(n))) return v;
          }
        } else {
          for (const k of Object.keys(cache)) {
            if (names.some((n) => k === n || k.endsWith(n))) return cache[k];
          }
        }
        return null;
      }
      function readAtomValue(atom) {
        try {
          if (typeof atom?.lastValue !== "undefined") return atom.lastValue;
          if (typeof atom?.read === "function" && typeof atom?.init !== "undefined") {
            const ctx = { get: (a) => a === atom ? atom.init : void 0 };
            return atom.read(ctx);
          }
        } catch (e) {
        }
        return void 0;
      }
      function setSlotIndex(idx) {
        targetWindow3._mgtools_currentSlotIndex = idx;
        if (CONFIG2.DEBUG.FLAGS.FIX_VALIDATION) {
          consoleObj?.log("[FIX_SLOT] Set slot index to:", idx);
        }
      }
      function syncSlotIndexFromGame() {
        const atomCache = targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache;
        if (!atomCache) return null;
        const slotAtom = findAtom(atomCache, ["myCurrentGrowSlotIndexAtom"]);
        if (!slotAtom) return null;
        const gameIndex = readAtomValue(slotAtom);
        if (!Number.isFinite(gameIndex)) return null;
        const currentIndex = targetWindow3._mgtools_currentSlotIndex || 0;
        if (gameIndex !== currentIndex) {
          setSlotIndex(gameIndex);
          qmt(() => {
            requestAnimationFrame(() => {
              if (insertTurtleEstimate3 && typeof insertTurtleEstimate3 === "function") {
                insertTurtleEstimate3(dependencies);
              }
            });
          });
          if (CONFIG2.DEBUG.FLAGS.FIX_VALIDATION) {
            targetWindow3._mgtools_syncCount = (targetWindow3._mgtools_syncCount || 0) + 1;
            consoleObj?.log("[FIX_HARVEST] Synced to game slot:", {
              from: currentIndex,
              to: gameIndex,
              syncCount: targetWindow3._mgtools_syncCount
            });
          }
          return gameIndex;
        }
        return null;
      }
      targetWindow3.syncSlotIndexFromGame = syncSlotIndexFromGame;
      const updateSlotIndex = (direction) => {
        const currentCrop = UnifiedState3.atoms.currentCrop || targetWindow3.currentCrop || [];
        const sortedIndices = UnifiedState3.atoms.sortedSlotIndices || targetWindow3.sortedSlotIndices;
        if (!currentCrop || currentCrop.length <= 1) return;
        const maxIndex = sortedIndices?.length || currentCrop.length;
        if (direction === "forward") {
          targetWindow3._mgtools_currentSlotIndex = (targetWindow3._mgtools_currentSlotIndex + 1) % maxIndex;
        } else if (direction === "backward") {
          targetWindow3._mgtools_currentSlotIndex = (targetWindow3._mgtools_currentSlotIndex - 1 + maxIndex) % maxIndex;
        }
        consoleObj?.log(
          `\u{1F3AF} [SLOT-KEY] Cycled ${direction} - slot index: ${targetWindow3._mgtools_currentSlotIndex}/${maxIndex}`
        );
        setTimeout(() => {
          if (insertTurtleEstimate3 && typeof insertTurtleEstimate3 === "function") {
            insertTurtleEstimate3(dependencies);
          }
        }, 100);
      };
      targetDocument2.addEventListener(
        "keydown",
        (e) => {
          const active = targetDocument2.activeElement;
          if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) return;
          const currentCrop = UnifiedState3.atoms.currentCrop || targetWindow3.currentCrop || [];
          if (!currentCrop || currentCrop.length <= 1) return;
          const currentHash = getCropHashSimple(currentCrop);
          if (currentHash !== lastCropHash) {
            targetWindow3._mgtools_currentSlotIndex = 0;
            lastCropHash = currentHash;
            consoleObj?.log(`\u{1F504} [SLOT-KEY] New crop detected, reset index to 0`);
          }
          if (e.key.toLowerCase() === "x") {
            updateSlotIndex("forward");
          } else if (e.key.toLowerCase() === "c") {
            updateSlotIndex("backward");
          }
        },
        true
      );
      targetDocument2.addEventListener(
        "click",
        (e) => {
          const target = e.target;
          if (!target) return;
          const button = target.closest("button");
          if (!button) return;
          const hasLeftArrow = button.querySelector('svg[data-icon="chevron-left"]') || button.innerHTML.includes("chevron-left") || button.getAttribute("aria-label")?.includes("Previous");
          const hasRightArrow = button.querySelector('svg[data-icon="chevron-right"]') || button.innerHTML.includes("chevron-right") || button.getAttribute("aria-label")?.includes("Next");
          if (hasLeftArrow) {
            consoleObj?.log("\u2B05\uFE0F [SLOT-ARROW] Left arrow clicked");
            updateSlotIndex("backward");
          } else if (hasRightArrow) {
            consoleObj?.log("\u27A1\uFE0F [SLOT-ARROW] Right arrow clicked");
            updateSlotIndex("forward");
          }
        },
        true
      );
      consoleObj?.log("\u2705 [SLOT-ATOM] Key and arrow watchers installed");
    };
    setupKeyWatcher();
    let attempts = 0;
    const checkInterval = setInterval(() => {
      attempts++;
      if (tryHookingViaCache()) {
        clearInterval(checkInterval);
        productionLog3("\u2705 [SLOT-ATOM] Successfully hooked slot index atom via cache!");
      } else if (attempts >= 10) {
        clearInterval(checkInterval);
        productionLog3("\u2139\uFE0F [SLOT-ATOM] Using key watcher for slot tracking");
      }
    }, 1e3);
  }
  var atoms_default = {
    // State
    hookedAtoms,
    atomReferences,
    // Reading Functions
    readAtom,
    getAtomValueFresh,
    // Hooking System
    hookAtom,
    listenToSlotIndexAtom,
    // Utilities
    getCropHash
  };

  // src/core/environment.js
  var environment_exports = {};
  __export(environment_exports, {
    createPlatformDetection: () => createPlatformDetection,
    detectEnvironment: () => detectEnvironment,
    initializePlatformDetection: () => initializePlatformDetection
  });
  function detectEnvironment(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof unsafeWindow !== "undefined" ? unsafeWindow : typeof window !== "undefined" ? window : null,
      document: doc = typeof document !== "undefined" ? document : null,
      window: win = typeof window !== "undefined" ? window : null,
      productionLog: productionLog3 = console.log.bind(console)
    } = dependencies;
    if (!targetWindow3 || !doc || !win) {
      return {
        isGameEnvironment: false,
        isStandalone: true,
        isDiscordEmbed: false,
        gameReady: false,
        url: "",
        hasJotaiAtoms: false,
        hasMagicCircleConnection: false,
        domain: "",
        readyState: "loading",
        initStrategy: "error"
      };
    }
    const environment = {
      isGameEnvironment: false,
      isStandalone: false,
      isDiscordEmbed: false,
      gameReady: false,
      url: targetWindow3.location.href,
      hasJotaiAtoms: !!((targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache)?.size > 0),
      hasMagicCircleConnection: !!(targetWindow3.MagicCircle_RoomConnection && typeof targetWindow3.MagicCircle_RoomConnection === "object"),
      domain: targetWindow3.location.hostname,
      readyState: doc.readyState
    };
    productionLog3("\u{1F50D} [ENV-DEBUG] Detecting environment:", {
      domain: environment.domain,
      pathname: targetWindow3.location.pathname,
      url: environment.url,
      hasAtoms: environment.hasJotaiAtoms,
      hasConnection: environment.hasMagicCircleConnection
    });
    const gameHosts = ["magiccircle.gg", "magicgarden.gg", "starweaver.org", "discordsays.com"];
    const isGameDomain = gameHosts.some((host) => environment.domain.includes(host));
    const hasGamePath = targetWindow3.location.pathname.includes("/r/");
    const isDiscordActivity = environment.domain.includes("discordsays.com");
    productionLog3("\u{1F50D} [ENV-DEBUG] Game checks:", {
      isGameDomain,
      hasGamePath,
      isDiscordActivity,
      willEnterGameMode: isGameDomain && (hasGamePath || isDiscordActivity)
    });
    if (isGameDomain && (hasGamePath || isDiscordActivity)) {
      const isInIframe = win.location !== win.parent.location;
      const isDiscordDesktopApp = win.DiscordNative !== void 0;
      productionLog3("\u{1F3AE} [ENV] Running in game environment:", environment.domain);
      if (isDiscordActivity) {
        productionLog3("\u{1F3AE} [DISCORD-ACTIVITY] Detected Discord Activity iframe!");
      }
      productionLog3("\u{1F3AE} [ENV] IsIframe:", isInIframe, "| DiscordNative:", isDiscordDesktopApp);
      environment.isGameEnvironment = true;
      environment.isStandalone = false;
      environment.gameReady = environment.hasJotaiAtoms && environment.hasMagicCircleConnection && doc.readyState === "complete";
      let initStrategy2 = "unknown";
      if (environment.gameReady) {
        initStrategy2 = "game-ready";
      } else {
        initStrategy2 = "game-wait";
      }
      environment.initStrategy = initStrategy2;
      return environment;
    }
    const isDiscordDomain = environment.domain.includes("discord.com");
    if (isDiscordDomain) {
      environment.isDiscordEmbed = true;
      productionLog3("\u{1F3AE} [DISCORD] Running on Discord page - looking for game iframe...");
      const gameIframes = doc.querySelectorAll("iframe");
      let foundGameIframe = false;
      for (const iframe of gameIframes) {
        try {
          const iframeSrc = iframe.src || "";
          if (gameHosts.some((host) => iframeSrc.includes(host))) {
            productionLog3("\u2705 [DISCORD] Found game iframe:", iframeSrc);
            productionLog3("\u{1F4A1} [DISCORD] Script should be running inside that iframe");
            foundGameIframe = true;
          }
        } catch (e) {
        }
      }
      if (foundGameIframe) {
        productionLog3(
          "\u26A0\uFE0F [DISCORD] On Discord page - script will only run inside the game iframe, not on Discord page itself"
        );
      } else {
        productionLog3("\u26A0\uFE0F [DISCORD] On Discord page but no game iframe found yet");
      }
      environment.isStandalone = false;
      environment.initStrategy = "skip";
      return environment;
    }
    environment.isGameEnvironment = false;
    environment.isStandalone = true;
    environment.gameReady = false;
    let initStrategy = "unknown";
    if (environment.gameReady) {
      initStrategy = "game-ready";
    } else if (environment.isGameEnvironment) {
      initStrategy = "game-wait";
    } else {
      initStrategy = "standalone";
    }
    environment.initStrategy = initStrategy;
    return environment;
  }
  function createPlatformDetection(dependencies = {}) {
    const {
      window: win = typeof window !== "undefined" ? window : null,
      navigator: nav = typeof navigator !== "undefined" ? navigator : null,
      document: doc = typeof document !== "undefined" ? document : null,
      productionLog: productionLog3 = console.log.bind(console)
    } = dependencies;
    if (!win || !nav || !doc) {
      return {
        isDiscord: false,
        isMobile: false,
        isIframe: false,
        isTouch: false,
        getLayout: () => "desktop",
        getScaleFactor: () => 1,
        applyResponsiveStyles: () => {
        },
        getFetchTimeout: () => 5e3,
        getAnimationDuration: () => 300
      };
    }
    const platform = {
      // Platform detection
      isDiscord: /discord|overlay|electron/i.test(nav.userAgent) || !!(win.DiscordNative || win.__discordApp),
      isMobile: /Mobile|Android|iPhone|iPad|iPod/i.test(nav.userAgent) || win.matchMedia?.("(max-width: 768px)").matches,
      isIframe: win !== win.top,
      isTouch: "ontouchstart" in win || nav.maxTouchPoints > 0,
      // Get current layout mode
      getLayout() {
        if (this.isMobile) return "mobile";
        if (this.isDiscord) return "discord";
        return "desktop";
      },
      // Get UI scale factor based on platform
      getScaleFactor() {
        if (this.isMobile) return 0.85;
        if (this.isDiscord) return 0.95;
        return 1;
      },
      // Apply responsive styles based on platform
      applyResponsiveStyles() {
        const layout = this.getLayout();
        const scale = this.getScaleFactor();
        const root = doc.documentElement;
        root.style.setProperty("--mga-scale", scale.toString());
        root.style.setProperty("--mga-layout", layout);
        root.setAttribute("data-mga-platform", layout);
        productionLog3(`[Platform] Detected: ${layout} (scale: ${scale}, touch: ${this.isTouch})`);
      },
      // Get optimized fetch timeout based on platform
      getFetchTimeout() {
        if (this.isMobile) return 8e3;
        if (this.isDiscord) return 6e3;
        return 5e3;
      },
      // Get UI animation duration based on platform
      getAnimationDuration() {
        if (this.isMobile) return 200;
        return 300;
      }
    };
    return platform;
  }
  function initializePlatformDetection(platformObject, dependencies = {}) {
    const {
      window: win = typeof window !== "undefined" ? window : null,
      navigator: nav = typeof navigator !== "undefined" ? navigator : null,
      productionLog: productionLog3 = console.log.bind(console)
    } = dependencies;
    if (!platformObject || !win || !nav) return;
    platformObject.applyResponsiveStyles();
    let resizeTimer;
    win.addEventListener("resize", () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        platformObject.isMobile = /Mobile|Android|iPhone|iPad|iPod/i.test(nav.userAgent) || win.matchMedia?.("(max-width: 768px)").matches;
        platformObject.applyResponsiveStyles();
      }, 250);
    });
    if (platformObject.isDiscord) {
      productionLog3("[Platform] Discord mode: External resources restricted, using bundled assets");
    }
    if (platformObject.isMobile) {
      productionLog3("[Platform] Mobile mode: Touch-optimized UI enabled");
    }
    if (platformObject.isTouch) {
      productionLog3("[Platform] Touch device detected: Increasing button tap targets");
    }
  }

  // src/core/modal-detection.js
  var modal_detection_exports = {};
  __export(modal_detection_exports, {
    checkForGameModals: () => checkForGameModals,
    createDebugLogger: () => createDebugLogger,
    initializeDebugSystem: () => initializeDebugSystem,
    logModalSystemStatus: () => logModalSystemStatus
  });
  function checkForGameModals(dependencies = {}) {
    const {
      document: doc = typeof document !== "undefined" ? document : null,
      window: win = typeof window !== "undefined" ? window : null,
      logInfo: logInfo3 = console.log.bind(console)
    } = dependencies;
    if (!doc || !win) return true;
    try {
      const modals = doc.querySelectorAll('[class*="modal"], [class*="dialog"], [role="dialog"]');
      const overlays = doc.querySelectorAll(
        '[class*="overlay"]:not(.mga-overlay):not(.top-drag-overlay):not(.bottom-drag-overlay)'
      );
      const popups = doc.querySelectorAll('[class*="popup"]:not(.mga-panel)');
      const mgcModals = doc.querySelectorAll('[class*="MGC"], [class*="magic-circle"]');
      const totalModalElements = modals.length + overlays.length + popups.length + mgcModals.length;
      const dragOverlays = doc.querySelectorAll(".top-drag-overlay, .bottom-drag-overlay");
      const modalDetails = {
        modals: modals.length,
        overlays: overlays.length,
        popups: popups.length,
        mgcElements: mgcModals.length,
        dragOverlaysExcluded: dragOverlays.length,
        total: totalModalElements,
        modalClasses: Array.from(modals).map((m) => m.className),
        overlayClasses: Array.from(overlays).map((o) => o.className),
        mgcClasses: Array.from(mgcModals).map((m) => m.className)
      };
      if (win.MGA_DEBUG) {
        win.MGA_DEBUG.logModalEvent("MODAL_CHECK_PERFORMED", modalDetails);
      }
      if (dragOverlays.length > 0) {
        logInfo3("INIT", `Excluding ${dragOverlays.length} game drag overlays (normal game UI, not blocking modals)`);
      }
      if (false) {
        logInfo3("INIT", "Game modal system active - deferring MGA interactions", modalDetails);
        if (win.MGA_DEBUG) {
          win.MGA_DEBUG.logModalEvent("MODAL_SYSTEM_ACTIVE", modalDetails);
        }
        return false;
      }
      logInfo3("INIT", "No blocking modals detected - MGA initialization allowed");
      return true;
    } catch (error) {
      console.error("\u274C [MODAL-CHECK] Error in modal detection:", error);
      if (win.MGA_DEBUG) {
        win.MGA_DEBUG.logError(error, "checkForGameModals");
      }
      return true;
    }
  }
  function logModalSystemStatus(dependencies = {}) {
    const {
      checkForGameModals: checkFn = () => true,
      isMGAEvent = null,
      createMGAElement = null,
      targetDocument: targetDocument2 = null,
      document: doc = typeof document !== "undefined" ? document : null,
      logInfo: logInfo3 = console.log.bind(console),
      logDebug: logDebug2 = console.log.bind(console)
    } = dependencies;
    if (!doc) return;
    const initialModalCheck = checkFn(dependencies);
    logInfo3("INIT", "Modal isolation verification:", {
      gameModalsActive: !initialModalCheck,
      eventIsolationActive: typeof isMGAEvent === "function",
      contextIsolationActive: typeof createMGAElement === "function",
      targetDocumentAvailable: !!targetDocument2,
      regularDocumentIntact: !!doc
    });
    const testEvent = { target: doc.body };
    const testMGAEvent = { target: { closest: () => null } };
    logDebug2("INIT", "Event isolation test:", {
      gameEventBlocked: isMGAEvent ? !isMGAEvent(testEvent) : false,
      mgaEventAllowed: isMGAEvent ? !isMGAEvent(testMGAEvent) : false
      // Should be false since closest returns null
    });
  }
  function createDebugLogger(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      document: doc = typeof document !== "undefined" ? document : null,
      window: win = typeof window !== "undefined" ? window : null,
      navigator: nav = typeof navigator !== "undefined" ? navigator : null,
      performance: perf = typeof performance !== "undefined" ? performance : null,
      isGMApiAvailable: isGMApiAvailable2 = () => false,
      logDebug: logDebug2 = console.log.bind(console),
      logInfo: logInfo3 = console.log.bind(console),
      logWarn: logWarn3 = console.warn.bind(console),
      logError: logError2 = console.error.bind(console),
      productionLog: productionLog3 = console.log.bind(console)
    } = dependencies;
    if (!win || !doc || !perf) {
      return {
        logStage: () => {
        },
        logModalEvent: () => {
        },
        logContextIssue: () => {
        },
        logError: () => {
        },
        getData: () => ({ error: "Missing dependencies" }),
        exportDebug: () => {
        }
      };
    }
    const debugData = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      loadingStages: [],
      modalEvents: [],
      contextIssues: [],
      errorLogs: [],
      performanceMetrics: {
        scriptStart: perf.now(),
        domReady: null,
        gameReady: null,
        uiCreated: null,
        fullyLoaded: null
      }
    };
    function logStage(stage, details = {}) {
      const entry = {
        timestamp: perf.now(),
        stage,
        details,
        domState: doc.readyState,
        gameElements: {
          jotaiAtoms: !!(targetWindow3 && targetWindow3.jotaiAtomCache),
          magicCircle: !!(targetWindow3 && targetWindow3.MagicCircle_RoomConnection),
          canvas: !!doc.querySelector("canvas"),
          gameContainer: !!doc.querySelector("#game-container, #app, .game-wrapper, main")
        }
      };
      debugData.loadingStages.push(entry);
      logDebug2("DEBUG-SYSTEM", `Stage: ${stage}`, entry);
    }
    function logModalEvent(event, details = {}) {
      const entry = {
        timestamp: perf.now(),
        event,
        details,
        gameModals: doc.querySelectorAll('[class*="modal"], [class*="dialog"], [role="dialog"]').length,
        mgaElements: targetDocument2.querySelectorAll(".mga-panel, .mga-toggle-btn").length
      };
      debugData.modalEvents.push(entry);
      logDebug2("DEBUG-SYSTEM", `Modal Event: ${event}`, entry);
    }
    function logContextIssue(issue, details = {}) {
      const entry = {
        timestamp: perf.now(),
        issue,
        details,
        context: {
          targetWindow: targetWindow3 === win ? "same" : "different",
          targetDocument: targetDocument2 === doc ? "same" : "different",
          gmApiAvailable: isGMApiAvailable2()
        }
      };
      debugData.contextIssues.push(entry);
      logDebug2("DEBUG-SYSTEM", `Context Issue: ${issue}`, entry);
    }
    function logErrorEntry(error, context = "") {
      const entry = {
        timestamp: perf.now(),
        error: error.toString(),
        stack: error.stack,
        context
      };
      debugData.errorLogs.push(entry);
      console.error(`\u{1F41B} [DEBUG-ERROR] ${context}:`, entry);
    }
    const debugLogger = {
      logStage,
      logModalEvent,
      logContextIssue,
      logError: logErrorEntry,
      getData: () => debugData,
      exportDebug: () => {
        logInfo3("DEBUG-SYSTEM", "Complete debug data:", JSON.stringify(debugData, null, 2));
        return debugData;
      }
    };
    logStage("DEBUG_SYSTEM_INITIALIZED", {
      userAgent: nav.userAgent,
      url: win.location.href,
      contextDetection: { targetWindow: targetWindow3.constructor.name }
    });
    return debugLogger;
  }
  function initializeDebugSystem(debugLogger, dependencies = {}) {
    const {
      window: win = typeof window !== "undefined" ? window : null,
      logInfo: logInfo3 = console.log.bind(console),
      logError: logError2 = console.error.bind(console),
      logWarn: logWarn3 = console.warn.bind(console),
      logDebug: logDebug2 = console.log.bind(console),
      productionLog: productionLog3 = console.log.bind(console)
    } = dependencies;
    if (!win || !debugLogger) return;
    win.MGA_DEBUG = debugLogger;
    logInfo3("DEBUG-SYSTEM", "Debug system initialized successfully");
    win.addEventListener("error", (event) => {
      if (win.MGA_DEBUG) {
        win.MGA_DEBUG.logError(event.error || new Error(event.message), "GLOBAL_ERROR_HANDLER");
      }
    });
    win.addEventListener("unhandledrejection", (event) => {
      if (win.MGA_DEBUG) {
        win.MGA_DEBUG.logError(event.reason || new Error("Unhandled Promise Rejection"), "UNHANDLED_REJECTION");
      }
    });
    setTimeout(() => {
      if (win.MGA_DEBUG) {
        const debugData = win.MGA_DEBUG.getData();
        const hasErrors = debugData.errorLogs.length > 0;
        const hasModalIssues = debugData.modalEvents.some((e) => e.event === "MODAL_SYSTEM_ACTIVE");
        const uiNotCreated = !debugData.loadingStages.some((s) => s.stage === "CREATE_UI_COMPLETED");
        if (hasErrors || hasModalIssues || uiNotCreated) {
          productionLog3("\u{1F6A8} [AUTO-DEBUG] Issues detected - exporting debug data...");
          win.MGA_DEBUG.exportDebug();
          productionLog3("\u{1F4CB} [AUTO-DEBUG] Copy the debug data above and paste it into mgdebug.txt");
        } else {
          productionLog3("\u2705 [AUTO-DEBUG] No issues detected in first 30 seconds");
        }
      }
    }, 3e4);
  }

  // src/core/websocket-manager.js
  var websocket_manager_exports = {};
  __export(websocket_manager_exports, {
    getReconnectionState: () => getReconnectionState,
    initializeWebSocketReconnect: () => initializeWebSocketReconnect,
    isWebSocketPatched: () => isWebSocketPatched
  });
  function initializeWebSocketReconnect(dependencies = {}, config2 = {}) {
    const {
      window: win = typeof window !== "undefined" ? window : null,
      document: doc = typeof document !== "undefined" ? document : null,
      navigator: nav = typeof navigator !== "undefined" ? navigator : null,
      CompatibilityMode: CompatibilityMode2 = null,
      productionLog: productionLog3 = console.log.bind(console),
      productionWarn: productionWarn3 = console.warn.bind(console),
      productionError: productionError2 = console.error.bind(console),
      logInfo: logInfo3 = console.log.bind(console),
      logWarn: logWarn3 = console.warn.bind(console)
    } = dependencies;
    const { maxAttempts = 6, enableToasts = true, enableNetworkListeners = true } = config2;
    if (!win || !doc || !nav) {
      productionWarn3("[WebSocket] Missing required dependencies - skipping initialization");
      return;
    }
    const Native = win.WebSocket;
    if (!Native || Native.__mgtoolsPatched) {
      productionWarn3("[WebSocket] Already patched or WebSocket not available");
      return;
    }
    let attempts = 0;
    let reconnectTimer = null;
    let _userNotified = false;
    const isDiscord = /discord|overlay|electron/i.test(nav.userAgent) || !!(win.DiscordNative || win.__discordApp);
    const isIframe = win !== win.top;
    const isMobile = /Mobile|Android|iPhone|iPad|iPod/i.test(nav.userAgent);
    if (CompatibilityMode2 && CompatibilityMode2.flags && CompatibilityMode2.flags.wsReconnectWhenHidden) {
      try {
        const originalDescriptor = Object.getOwnPropertyDescriptor(doc.constructor.prototype, "hidden") || Object.getOwnPropertyDescriptor(doc, "hidden");
        if (originalDescriptor && originalDescriptor.get) {
          Object.defineProperty(doc, "hidden", {
            get: function() {
              return false;
            },
            configurable: true
          });
          logInfo3("COMPAT-WS", "Overrode document.hidden to enable reconnection in hidden state");
        }
        const originalVisibilityDescriptor = Object.getOwnPropertyDescriptor(doc.constructor.prototype, "visibilityState") || Object.getOwnPropertyDescriptor(doc, "visibilityState");
        if (originalVisibilityDescriptor && originalVisibilityDescriptor.get) {
          Object.defineProperty(doc, "visibilityState", {
            get: function() {
              return "visible";
            },
            configurable: true
          });
        }
      } catch (e) {
        logWarn3("COMPAT-WS", "Failed to override document.hidden", e);
      }
    }
    if (enableToasts) {
      const style = doc.createElement("style");
      style.textContent = `
      @keyframes slideInRight {
        from { transform: translateX(400px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes slideOutRight {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(400px); opacity: 0; }
      }
    `;
      doc.head.appendChild(style);
    }
    function showReconnectToast(attemptNum, maxAttemptsLimit, nextWait) {
      if (!enableToasts) return;
      let toast2 = doc.getElementById("mga-reconnect-toast");
      const toastHTML = `
      <div style="display: flex; align-items: center; gap: 12px;">
        <div style="font-size: 24px;">\u{1F504}</div>
        <div>
          <div style="font-weight: 600; margin-bottom: 4px;">Connection Lost</div>
          <div style="font-size: 12px; opacity: 0.9;">
            Reconnecting... (${attemptNum}/${maxAttemptsLimit})
            <br>Next attempt in ${Math.round(nextWait / 1e3)}s
          </div>
        </div>
      </div>
    `;
      if (!toast2) {
        toast2 = doc.createElement("div");
        toast2.id = "mga-reconnect-toast";
        toast2.style.cssText = `
        position: fixed; top: 20px; right: 20px; z-index: 2147483647;
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.95), rgba(37, 99, 235, 0.95));
        color: white; padding: 16px 24px; border-radius: 12px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        font-size: 14px; font-weight: 500; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        animation: slideInRight 0.3s ease-out; max-width: 320px; pointer-events: auto;
      `;
        doc.body.appendChild(toast2);
      }
      toast2.innerHTML = toastHTML;
      _userNotified = true;
      setTimeout(() => {
        if (toast2 && toast2.parentNode) {
          toast2.style.animation = "slideOutRight 0.3s ease-out";
          setTimeout(() => toast2.remove(), 300);
        }
      }, 5e3);
    }
    function showFailureToast() {
      if (!enableToasts) return;
      const failToast = doc.createElement("div");
      failToast.id = "mga-reconnect-fail-toast";
      failToast.style.cssText = `
      position: fixed; top: 20px; right: 20px; z-index: 2147483647;
      background: linear-gradient(135deg, rgba(220, 38, 38, 0.95), rgba(185, 28, 28, 0.95));
      color: white; padding: 16px 24px; border-radius: 12px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); max-width: 320px;
    `;
      failToast.innerHTML = `
      <div style="font-weight: 600; margin-bottom: 8px;">\u26A0\uFE0F Connection Failed</div>
      <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
        Unable to reconnect after ${maxAttempts} attempts
      </div>
      <button onclick="location.reload()" style="
        background: white; color: #dc2626; border: none; padding: 8px 16px;
        border-radius: 6px; cursor: pointer; font-weight: 600; width: 100%; font-size: 13px;
      ">Reload Page</button>
    `;
      doc.body.appendChild(failToast);
    }
    function showUpdateToast(countdownSeconds) {
      if (!enableToasts) return;
      let countdown = countdownSeconds;
      const updateToast = doc.createElement("div");
      updateToast.id = "mga-update-toast";
      updateToast.style.cssText = `
      position: fixed; top: 20px; right: 20px; z-index: 2147483647;
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
      color: white; padding: 16px 24px; border-radius: 12px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      animation: slideInRight 0.3s ease-out; max-width: 320px;
    `;
      updateToast.innerHTML = `
      <div style="display: flex; align-items: center; gap: 12px;">
        <div style="font-size: 24px;">\u{1F3AE}</div>
        <div>
          <div style="font-weight: 600; margin-bottom: 4px;">Game Update Available</div>
          <div style="font-size: 12px; opacity: 0.9;">
            Refreshing in <span id="mga-countdown">${countdown}</span>s...
          </div>
        </div>
      </div>
    `;
      doc.body.appendChild(updateToast);
      const countdownInterval = setInterval(() => {
        countdown -= 1;
        const countdownEl = doc.getElementById("mga-countdown");
        if (countdownEl) {
          countdownEl.textContent = countdown;
        }
        if (countdown <= 0) {
          clearInterval(countdownInterval);
        }
      }, 1e3);
      return countdownInterval;
    }
    function scheduleReload(code, wasClean, reason) {
      if (code === 4710 || /version.?expired/i.test(reason || "")) {
        productionLog3("[WebSocket] Version expired detected (code 4710) - auto-refreshing in 5 seconds");
        showUpdateToast(5);
        setTimeout(() => {
          productionLog3("[WebSocket] Auto-refreshing for game update...");
          win.location.reload();
        }, 5e3);
        return;
      }
      if (wasClean && code !== 1006 && !/update/i.test(reason || "")) {
        productionLog3("[WebSocket] Clean close detected - no reconnect needed");
        return;
      }
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      if (attempts >= maxAttempts) {
        productionWarn3(`[WebSocket] Max reconnect attempts (${maxAttempts}) reached - manual refresh required`);
        showFailureToast();
        return;
      }
      const wait = Math.min(1e3 * Math.pow(2, attempts), 15e3);
      attempts += 1;
      productionLog3(
        `[WebSocket] Reconnect attempt ${attempts}/${maxAttempts} in ${wait}ms (code: ${code}, reason: "${reason || "none"}")`
      );
      showReconnectToast(attempts, maxAttempts, wait);
      reconnectTimer = setTimeout(() => {
        try {
          const u = new URL(win.location.href);
          u.searchParams.set("_mgtp", Date.now().toString());
          if (isDiscord && isIframe) {
            try {
              win.parent.location.reload();
            } catch (e) {
              win.location.replace(u.toString());
            }
          } else if (isMobile) {
            win.location.href = u.toString();
          } else {
            win.location.replace(u.toString());
          }
        } catch (e) {
          productionError2("[WebSocket] Reload failed:", e);
          win.location.href = win.location.href + "?_t=" + Date.now();
        }
      }, wait);
    }
    win.WebSocket = function(url, protocols) {
      const ws = new Native(url, protocols);
      ws.addEventListener("open", () => {
        productionLog3("[WebSocket] Connection established successfully");
        attempts = 0;
        _userNotified = false;
        const toast2 = doc.getElementById("mga-reconnect-toast");
        if (toast2) toast2.remove();
      });
      ws.addEventListener("close", (e) => {
        productionLog3(`[WebSocket] Closed - Code: ${e.code}, Clean: ${e.wasClean}, Reason: "${e.reason || "none"}"`);
        scheduleReload(e.code, e.wasClean, e.reason);
      });
      ws.addEventListener("error", (e) => {
        productionError2("[WebSocket] Error detected:", e);
      });
      return ws;
    };
    Object.setPrototypeOf(win.WebSocket, Native);
    win.WebSocket.prototype = Native.prototype;
    win.WebSocket.__mgtoolsPatched = true;
    if (enableNetworkListeners) {
      win.addEventListener("online", () => {
        productionLog3("[Network] Back online - reducing reconnect attempt counter");
        attempts = Math.max(0, attempts - 2);
        const toast2 = doc.getElementById("mga-reconnect-toast");
        if (toast2) toast2.remove();
      });
      win.addEventListener("offline", () => {
        productionWarn3("[Network] Offline detected - pausing reconnection attempts");
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        const toast2 = doc.getElementById("mga-reconnect-toast");
        if (toast2 && enableToasts) {
          toast2.innerHTML = `
          <div style="display: flex; align-items: center; gap: 12px;">
            <div style="font-size: 24px;">\u{1F4E1}</div>
            <div>
              <div style="font-weight: 600; margin-bottom: 4px;">Network Offline</div>
              <div style="font-size: 12px; opacity: 0.9;">
                Reconnection paused<br>Waiting for network...
              </div>
            </div>
          </div>
        `;
        }
      });
    }
    productionLog3("\u2705 [WebSocket] Enhanced auto-reconnect system initialized (max attempts: " + maxAttempts + ")");
  }
  function isWebSocketPatched(win = typeof window !== "undefined" ? window : null) {
    if (!win || !win.WebSocket) return false;
    return !!win.WebSocket.__mgtoolsPatched;
  }
  function getReconnectionState() {
    return {
      note: "Reconnection state is encapsulated and not exposed",
      isPatched: isWebSocketPatched()
    };
  }

  // src/core/storage-recovery.js
  var storage_recovery_exports = {};
  __export(storage_recovery_exports, {
    KNOWN_ABILITY_TYPES: () => KNOWN_ABILITY_TYPES,
    diagnoseAbilityLogStorage: () => diagnoseAbilityLogStorage,
    emergencyStorageScan: () => emergencyStorageScan,
    exportPetPresets: () => exportPetPresets,
    getMigrationStatus: () => getMigrationStatus,
    importPetPresets: () => importPetPresets,
    isKnownAbilityType: () => isKnownAbilityType,
    migrateFromLocalStorage: () => migrateFromLocalStorage,
    normalizeAbilityName: () => normalizeAbilityName,
    performStorageHealthCheck: () => performStorageHealthCheck
  });
  var KNOWN_ABILITY_TYPES = [
    // XP Boosts
    "XP Boost I",
    "XP Boost II",
    "XP Boost III",
    "Hatch XP Boost I",
    "Hatch XP Boost II",
    // Crop Size Boosts
    "Crop Size Boost I",
    "Crop Size Boost II",
    // Selling
    "Sell Boost I",
    "Sell Boost II",
    "Sell Boost III",
    "Coin Finder I",
    "Coin Finder II",
    // Harvesting
    "Harvesting",
    "Auto Harvest",
    // Growth Speed
    "Plant Growth Boost I",
    "Plant Growth Boost II",
    "Plant Growth Boost III",
    "Egg Growth Boost I",
    "Egg Growth Boost II",
    // Seeds
    "Seed Finder I",
    "Seed Finder II",
    "Special Mutations",
    // Other
    "Hunger Boost I",
    "Hunger Boost II",
    "Max Strength Boost I",
    "Max Strength Boost II"
  ];
  function normalizeAbilityName(name, dependencies = {}) {
    const { UnifiedState: UnifiedState3, logDebug: logDebug2 = console.log.bind(console) } = dependencies;
    if (!name || typeof name !== "string") return name;
    const normalized = name.replace(/([a-z])III$/i, "$1 III").replace(/([a-z])II$/i, "$1 II").replace(/([a-z])I$/i, "$1 I").replace(/produce\s*scale\s*boost/gi, "Crop Size Boost").trim();
    if (normalized !== name && UnifiedState3?.data?.settings?.debugMode) {
      logDebug2("ABILITY-LOGS", `\u{1F4DD} Normalized ability name: "${name}" \u2192 "${normalized}"`);
    }
    return normalized;
  }
  function isKnownAbilityType(abilityType) {
    if (!abilityType) return false;
    return KNOWN_ABILITY_TYPES.includes(abilityType);
  }
  function emergencyStorageScan(key, dependencies = {}) {
    const {
      GM_getValue: GM_getValue2 = null,
      window: win = typeof window !== "undefined" ? window : null,
      targetWindow: targetWindow3 = null
    } = dependencies;
    const report = {
      key,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      locations: {}
    };
    try {
      if (typeof GM_getValue2 === "function") {
        const gmValue = GM_getValue2(key, null);
        if (gmValue) {
          const parsed = typeof gmValue === "string" ? JSON.parse(gmValue) : gmValue;
          const itemCount = Array.isArray(parsed) ? parsed.length : Object.keys(parsed || {}).length;
          report.locations.GM = {
            found: true,
            itemCount,
            dataType: Array.isArray(parsed) ? "array" : typeof parsed,
            preview: JSON.stringify(parsed).substring(0, 200)
          };
        } else {
          report.locations.GM = { found: false };
        }
      }
    } catch (e) {
      report.locations.GM = { error: e.message };
    }
    try {
      if (win && win.localStorage) {
        const lsValue = win.localStorage.getItem(key);
        if (lsValue) {
          try {
            const parsed = JSON.parse(lsValue);
            const itemCount = Array.isArray(parsed) ? parsed.length : Object.keys(parsed || {}).length;
            report.locations.windowLocalStorage = {
              found: true,
              itemCount,
              dataType: Array.isArray(parsed) ? "array" : typeof parsed,
              preview: lsValue.substring(0, 200)
            };
          } catch (parseErr) {
            report.locations.windowLocalStorage = {
              found: true,
              corrupted: true,
              rawValue: lsValue.substring(0, 200)
            };
          }
        } else {
          report.locations.windowLocalStorage = { found: false };
        }
      }
    } catch (e) {
      report.locations.windowLocalStorage = { error: e.message };
    }
    try {
      if (targetWindow3 && targetWindow3 !== win && targetWindow3.localStorage) {
        const tgValue = targetWindow3.localStorage.getItem(key);
        if (tgValue) {
          try {
            const parsed = JSON.parse(tgValue);
            const itemCount = Array.isArray(parsed) ? parsed.length : Object.keys(parsed || {}).length;
            report.locations.targetLocalStorage = {
              found: true,
              itemCount,
              dataType: Array.isArray(parsed) ? "array" : typeof parsed,
              preview: tgValue.substring(0, 200)
            };
          } catch (parseErr) {
            report.locations.targetLocalStorage = {
              found: true,
              corrupted: true,
              rawValue: tgValue.substring(0, 200)
            };
          }
        } else {
          report.locations.targetLocalStorage = { found: false };
        }
      }
    } catch (e) {
      report.locations.targetLocalStorage = { error: e.message };
    }
    return report;
  }
  function exportPetPresets(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3,
      document: doc = typeof document !== "undefined" ? document : null,
      window: win = typeof window !== "undefined" ? window : null,
      productionLog: productionLog3 = console.log.bind(console),
      alert: alertFn = typeof alert !== "undefined" ? alert : console.log.bind(console)
    } = dependencies;
    try {
      const presets = UnifiedState3.data.petPresets || {};
      const presetCount = Object.keys(presets).length;
      if (presetCount === 0) {
        alertFn("\u26A0\uFE0F No pet presets to export!\n\nCreate some presets first.");
        return;
      }
      const exportData = {
        version: "3.8.8",
        exportDate: (/* @__PURE__ */ new Date()).toISOString(),
        presetCount,
        presets,
        presetsOrder: UnifiedState3.data.petPresetsOrder || []
      };
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: "application/json" });
      const url = win.URL.createObjectURL(dataBlob);
      const link = doc.createElement("a");
      link.href = url;
      link.download = `mgtools-presets-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
      link.click();
      win.URL.revokeObjectURL(url);
      productionLog3(`\u2705 [EXPORT] Successfully exported ${presetCount} pet presets`);
      alertFn(`\u2705 Exported ${presetCount} pet presets!

File saved to Downloads folder.`);
    } catch (error) {
      console.error("\u274C [EXPORT] Failed to export presets:", error);
      alertFn(`\u274C Export failed!

Error: ${error.message}`);
    }
  }
  function importPetPresets(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3,
      document: doc = typeof document !== "undefined" ? document : null,
      window: win = typeof window !== "undefined" ? window : null,
      MGA_saveJSON: MGA_saveJSON2 = () => {
      },
      productionLog: productionLog3 = console.log.bind(console),
      alert: alertFn = typeof alert !== "undefined" ? alert : console.log.bind(console),
      confirm: confirmFn = typeof confirm !== "undefined" ? confirm : () => true
    } = dependencies;
    try {
      const input = doc.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = async (e) => {
        try {
          const file = e.target.files[0];
          if (!file) return;
          const text = await file.text();
          const importData = JSON.parse(text);
          if (!importData.presets || typeof importData.presets !== "object") {
            throw new Error("Invalid preset file format");
          }
          const importCount = Object.keys(importData.presets).length;
          const currentCount = Object.keys(UnifiedState3.data.petPresets || {}).length;
          const confirmed = confirmFn(
            `\u{1F4E5} Import ${importCount} presets?

Current presets: ${currentCount}
Import date: ${importData.exportDate || "Unknown"}
Version: ${importData.version || "Unknown"}

\u26A0\uFE0F This will OVERWRITE your current presets!`
          );
          if (!confirmed) {
            productionLog3("\u23F8\uFE0F [IMPORT] User cancelled import");
            return;
          }
          UnifiedState3.data.petPresets = importData.presets;
          UnifiedState3.data.petPresetsOrder = importData.presetsOrder || [];
          MGA_saveJSON2("MGA_petPresets", importData.presets);
          MGA_saveJSON2("MGA_petPresetsOrder", importData.presetsOrder || []);
          productionLog3(`\u2705 [IMPORT] Successfully imported ${importCount} pet presets`);
          alertFn(`\u2705 Imported ${importCount} presets!

Page will reload to apply changes.`);
          setTimeout(() => win.location.reload(), 1e3);
        } catch (error) {
          console.error("\u274C [IMPORT] Failed to import presets:", error);
          alertFn(
            `\u274C Import failed!

Error: ${error.message}

Make sure you're importing a valid MGTools preset file.`
          );
        }
      };
      input.click();
    } catch (error) {
      console.error("\u274C [IMPORT] Failed to create import dialog:", error);
      alertFn(`\u274C Import failed!

Error: ${error.message}`);
    }
  }
  function performStorageHealthCheck(dependencies = {}) {
    const {
      GM_setValue: GM_setValue2 = null,
      GM_getValue: GM_getValue2 = null,
      GM_deleteValue: GM_deleteValue2 = null,
      window: win = typeof window !== "undefined" ? window : null,
      navigator: nav = typeof navigator !== "undefined" ? navigator : null
    } = dependencies;
    const report = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      gmAvailable: false,
      localStorageAvailable: false,
      writeTest: {},
      quotaCheck: {},
      issues: []
    };
    try {
      if (typeof GM_setValue2 === "function" && typeof GM_getValue2 === "function") {
        report.gmAvailable = true;
        const testKey = "MGA_health_check_test";
        const testValue = { test: true, timestamp: Date.now() };
        GM_setValue2(testKey, JSON.stringify(testValue));
        const retrieved = GM_getValue2(testKey, null);
        if (retrieved) {
          report.writeTest.GM = "PASS";
          if (typeof GM_deleteValue2 === "function") {
            GM_deleteValue2(testKey);
          }
        } else {
          report.writeTest.GM = "FAIL";
          report.issues.push("GM_setValue/GM_getValue not working properly");
        }
      } else {
        report.issues.push("GM API not available - will use localStorage fallback");
      }
    } catch (e) {
      report.writeTest.GM = "ERROR: " + e.message;
      report.issues.push("GM API error: " + e.message);
    }
    try {
      if (win && typeof win.localStorage !== "undefined") {
        report.localStorageAvailable = true;
        const testKey = "MGA_health_check_test";
        const testValue = JSON.stringify({ test: true, timestamp: Date.now() });
        win.localStorage.setItem(testKey, testValue);
        const retrieved = win.localStorage.getItem(testKey);
        try {
          const retrievedObj = JSON.parse(retrieved);
          const testObj = JSON.parse(testValue);
          if (retrievedObj && retrievedObj.test === testObj.test) {
            report.writeTest.localStorage = "PASS";
            win.localStorage.removeItem(testKey);
          } else {
            report.writeTest.localStorage = "FAIL";
            report.issues.push("localStorage read/write mismatch");
          }
        } catch (e) {
          if (retrieved === testValue) {
            report.writeTest.localStorage = "PASS";
            win.localStorage.removeItem(testKey);
          } else {
            report.writeTest.localStorage = "FAIL";
            report.issues.push("localStorage read/write mismatch");
          }
        }
        if (nav && "storage" in nav && "estimate" in nav.storage) {
          nav.storage.estimate().then((estimate) => {
            const percentUsed = (estimate.usage / estimate.quota * 100).toFixed(2);
            report.quotaCheck = {
              used: estimate.usage,
              quota: estimate.quota,
              percentUsed,
              warning: percentUsed > 80
            };
            if (percentUsed > 80) {
              report.issues.push(`Storage ${percentUsed}% full - may cause save failures`);
            }
          });
        }
      } else {
        report.issues.push("localStorage not available");
      }
    } catch (e) {
      report.writeTest.localStorage = "ERROR: " + e.message;
      report.issues.push("localStorage error: " + e.message);
    }
    return report;
  }
  function diagnoseAbilityLogStorage(dependencies = {}) {
    const {
      GM_getValue: GM_getValue2 = null,
      window: win = typeof window !== "undefined" ? window : null,
      targetWindow: targetWindow3 = null,
      UnifiedState: UnifiedState3,
      logDebug: logDebug2 = console.log.bind(console),
      normalizeAbilityName: normalizeFn = normalizeAbilityName,
      isKnownAbilityType: isKnownFn = isKnownAbilityType
    } = dependencies;
    logDebug2("ABILITY-LOGS", "\u{1F50D} Starting comprehensive ability log storage diagnostic...");
    const report = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      sources: {}
    };
    const safeGet = (fn, label) => {
      try {
        return fn();
      } catch (e) {
        logDebug2("ABILITY-LOGS", `  \u274C ${label}: Error - ${e.message}`);
        return null;
      }
    };
    const parseAndCount = (raw, _label) => {
      if (!raw) return { exists: false, count: 0, logs: [] };
      try {
        const parsed = typeof raw === "string" ? JSON.parse(raw) : raw;
        const count = Array.isArray(parsed) ? parsed.length : 0;
        if (Array.isArray(parsed)) {
          const logs = parsed.map((l) => {
            const abilityType = l.abilityType || "unknown";
            const normalizedAbility = normalizeFn(abilityType, dependencies);
            const isKnown = isKnownFn(normalizedAbility);
            const isMalformed = abilityType !== normalizedAbility;
            return {
              ability: abilityType,
              normalizedAbility: isMalformed ? normalizedAbility : null,
              isKnown,
              isMalformed,
              pet: l.petName || l.petSpecies || "unknown",
              timestamp: l.timestamp,
              time: new Date(l.timestamp).toLocaleString(),
              // Create a unique fingerprint for this log
              fingerprint: `${abilityType}_${l.petName}_${l.timestamp}`.substring(0, 50)
            };
          });
          const malformedCount = logs.filter((l) => l.isMalformed).length;
          const unknownCount = logs.filter((l) => !l.isKnown).length;
          return {
            exists: true,
            count,
            logs,
            malformedCount,
            unknownCount
          };
        }
        return { exists: true, count: "not-an-array", logs: [] };
      } catch (e) {
        return { exists: true, count: "parse-error", logs: [], error: e.message };
      }
    };
    const gmMain = safeGet(() => GM_getValue2 ? GM_getValue2("MGA_petAbilityLogs", null) : null, "GM Main");
    const gmArchive = safeGet(() => GM_getValue2 ? GM_getValue2("MGA_petAbilityLogs_archive", null) : null, "GM Archive");
    report.sources.gmStorage = {
      main: parseAndCount(gmMain, "GM Main"),
      archive: parseAndCount(gmArchive, "GM Archive")
    };
    const lsMain = safeGet(() => win?.localStorage?.getItem("MGA_petAbilityLogs"), "LS Main");
    const lsArchive = safeGet(() => win?.localStorage?.getItem("MGA_petAbilityLogs_archive"), "LS Archive");
    const lsClearFlag = safeGet(() => win?.localStorage?.getItem("MGA_logs_manually_cleared"), "LS Clear Flag");
    report.sources.windowLocalStorage = {
      main: parseAndCount(lsMain, "LS Main"),
      archive: parseAndCount(lsArchive, "LS Archive"),
      clearFlag: lsClearFlag
    };
    if (targetWindow3 && targetWindow3 !== win) {
      const tgMain = safeGet(() => targetWindow3.localStorage?.getItem("MGA_petAbilityLogs"), "TG Main");
      const tgArchive = safeGet(() => targetWindow3.localStorage?.getItem("MGA_petAbilityLogs_archive"), "TG Archive");
      report.sources.targetWindowLocalStorage = {
        main: parseAndCount(tgMain, "TG Main"),
        archive: parseAndCount(tgArchive, "TG Archive")
      };
    }
    const mgaData = safeGet(() => GM_getValue2 ? GM_getValue2("MGA_data", null) : null, "MGA_data");
    if (mgaData) {
      try {
        const parsed = typeof mgaData === "string" ? JSON.parse(mgaData) : mgaData;
        const nestedLogs = parsed?.petAbilityLogs;
        report.sources.mgaDataNested = {
          logs: parseAndCount(nestedLogs, "MGA_data nested")
        };
      } catch (e) {
        report.sources.mgaDataNested = { error: e.message };
      }
    }
    if (win && typeof win.petAbilityLogs !== "undefined") {
      report.sources.compatibilityArray = {
        count: Array.isArray(win.petAbilityLogs) ? win.petAbilityLogs.length : "not-an-array",
        sample: Array.isArray(win.petAbilityLogs) ? win.petAbilityLogs.slice(0, 3) : null
      };
    }
    const memoryLogs = (UnifiedState3.data?.petAbilityLogs || []).map((l) => {
      const abilityType = l.abilityType || "unknown";
      const normalizedAbility = normalizeFn(abilityType, dependencies);
      const isKnown = isKnownFn(normalizedAbility);
      const isMalformed = abilityType !== normalizedAbility;
      return {
        ability: abilityType,
        normalizedAbility: isMalformed ? normalizedAbility : null,
        isKnown,
        isMalformed,
        pet: l.petName || l.petSpecies || "unknown",
        timestamp: l.timestamp,
        time: new Date(l.timestamp).toLocaleString(),
        fingerprint: `${abilityType}_${l.petName}_${l.timestamp}`.substring(0, 50)
      };
    });
    report.sources.memory = {
      unifiedState: {
        count: memoryLogs.length,
        sample: memoryLogs
        // Now includes all logs with fingerprints
      }
    };
    const totals = {
      gmMain: report.sources.gmStorage.main.count || 0,
      gmArchive: report.sources.gmStorage.archive.count || 0,
      lsMain: report.sources.windowLocalStorage.main.count || 0,
      lsArchive: report.sources.windowLocalStorage.archive.count || 0,
      memory: report.sources.memory.unifiedState.count
    };
    report.summary = {
      totalLocationsWithLogs: Object.values(totals).filter((c) => c > 0).length,
      totals,
      suspectSources: Object.entries(totals).filter(([_k, v]) => v > 0).map(([k]) => k)
    };
    console.log("\u{1F50D} ========== ABILITY LOGS STORAGE DIAGNOSTIC ==========");
    console.log("\u{1F4CA} Summary:", report.summary);
    console.log("");
    console.log("\u{1F4C1} GM Storage:");
    console.log("  Main:", report.sources.gmStorage.main.count, "logs");
    console.log("  Archive:", report.sources.gmStorage.archive.count, "logs");
    console.log("\u{1F4C1} Window localStorage:");
    console.log("  Main:", report.sources.windowLocalStorage.main.count, "logs");
    console.log("  Archive:", report.sources.windowLocalStorage.archive.count, "logs");
    console.log("  Clear flag:", report.sources.windowLocalStorage.clearFlag);
    if (report.sources.targetWindowLocalStorage) {
      console.log("\u{1F4C1} Target Window localStorage:");
      console.log("  Main:", report.sources.targetWindowLocalStorage.main.count, "logs");
      console.log("  Archive:", report.sources.targetWindowLocalStorage.archive.count, "logs");
    }
    if (report.sources.mgaDataNested) {
      console.log("\u{1F4C1} MGA_data nested:", report.sources.mgaDataNested);
    }
    if (report.sources.compatibilityArray) {
      console.log("\u{1F4C1} Compatibility array:", report.sources.compatibilityArray);
    }
    console.log("\u{1F4BE} Memory:", report.sources.memory.unifiedState.count, "logs");
    console.log("");
    console.log("\u{1F4CB} ========== DETAILED LOG LISTING ==========");
    const showLogs = (title, logs) => {
      if (logs && logs.length > 0) {
        console.log(`
${title}:`);
        logs.forEach((log, i) => {
          const prefix = log.isMalformed ? "\u26A0\uFE0F MALFORMED" : log.isKnown ? "\u2705" : "\u2753 UNKNOWN";
          console.log(`  ${i + 1}. ${prefix} [${log.fingerprint}]`);
          console.log(`     ${log.ability} - ${log.pet}`);
          if (log.isMalformed) {
            console.log(`     \u2192 Should be: "${log.normalizedAbility}"`);
          }
          console.log(`     ${log.time}`);
        });
      }
    };
    showLogs("GM Storage (Main)", report.sources.gmStorage.main.logs);
    showLogs("GM Storage (Archive)", report.sources.gmStorage.archive.logs);
    showLogs("Window localStorage (Main)", report.sources.windowLocalStorage.main.logs);
    showLogs("Window localStorage (Archive)", report.sources.windowLocalStorage.archive.logs);
    if (report.sources.targetWindowLocalStorage) {
      showLogs("TargetWindow localStorage (Main)", report.sources.targetWindowLocalStorage.main.logs);
      showLogs("TargetWindow localStorage (Archive)", report.sources.targetWindowLocalStorage.archive.logs);
    }
    if (report.sources.mgaDataNested?.logs?.logs) {
      showLogs("MGA_data nested", report.sources.mgaDataNested.logs.logs);
    }
    showLogs("Memory (UnifiedState)", report.sources.memory.unifiedState.sample);
    const allSources = [
      report.sources.gmStorage.main,
      report.sources.gmStorage.archive,
      report.sources.windowLocalStorage.main,
      report.sources.windowLocalStorage.archive
    ];
    if (report.sources.targetWindowLocalStorage) {
      allSources.push(report.sources.targetWindowLocalStorage.main);
      allSources.push(report.sources.targetWindowLocalStorage.archive);
    }
    const totalMalformed = allSources.reduce((sum, src) => sum + (src.malformedCount || 0), 0);
    const totalUnknown = allSources.reduce((sum, src) => sum + (src.unknownCount || 0), 0);
    console.log("\n=======================================================");
    console.log("\u{1F4A1} TIPS:");
    console.log("  \u2022 Look for logs with identical fingerprints across multiple storage locations");
    console.log("  \u2022 If a log persists after clear, check which storage still contains it");
    if (totalMalformed > 0) {
      console.log(`  \u2022 \u26A0\uFE0F Found ${totalMalformed} MALFORMED ability name(s) - missing spaces before roman numerals`);
      console.log('  \u2022 Malformed logs may not clear properly. Enable Debug Mode and click "Clear Logs".');
    }
    if (totalUnknown > 0) {
      console.log(`  \u2022 \u2753 Found ${totalUnknown} UNKNOWN ability type(s) - not in known abilities list`);
    }
    console.log("=======================================================");
    logDebug2("ABILITY-LOGS", "\u2705 Diagnostic complete - see console for full report");
    return report;
  }
  function migrateFromLocalStorage(dependencies = {}) {
    const {
      GM_setValue: GM_setValue2 = null,
      GM_getValue: GM_getValue2 = null,
      window: win = typeof window !== "undefined" ? window : null,
      productionLog: productionLog3 = console.log.bind(console),
      requestIdleCallback: ric = typeof requestIdleCallback !== "undefined" ? requestIdleCallback : null
    } = dependencies;
    try {
      productionLog3("\u{1F504} [MIGRATION] Starting data migration from localStorage to GM storage...");
      const migrationComplete = GM_getValue2 ? GM_getValue2("MGA_migration_completed", false) : false;
      if (migrationComplete === true || migrationComplete === "true") {
        productionLog3("\u2705 [MIGRATION] Migration already completed, skipping...");
        return { success: true, alreadyCompleted: true };
      }
      const keysToMigrate = [
        "MGA_petPresets",
        "MGA_seedsToDelete",
        "MGA_autoDeleteEnabled",
        "MGA_petAbilityLogs",
        "MGA_settings",
        "MGA_mainHUDPosition",
        "MGA_toggleButtonPosition",
        "MGA_overlayDimensions",
        "MGA_overlayPositions",
        "MGA_overlayStates",
        "MGA_abilityFilters",
        "MGA_petFilters",
        "MGA_customMode",
        "MGA_filterMode",
        "MGA_timerStates"
      ];
      let migratedCount = 0;
      let totalDataSize = 0;
      const migrateKeys = (keyIndex = 0) => {
        if (keyIndex >= keysToMigrate.length) {
          if (GM_setValue2) {
            GM_setValue2("MGA_migration_completed", true);
            GM_setValue2("MGA_migration_timestamp", Date.now());
            GM_setValue2("MGA_migration_stats", {
              migratedCount,
              totalDataSize,
              timestamp: Date.now()
            });
          }
          productionLog3(`\u2705 [MIGRATION] Data migration completed!`);
          productionLog3(`\u{1F4CA} [MIGRATION] Statistics:`, {
            migratedKeys: migratedCount,
            totalDataSize: totalDataSize + " chars",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
          return;
        }
        const key = keysToMigrate[keyIndex];
        try {
          const localStorageData = win?.localStorage?.getItem(key);
          if (localStorageData && GM_setValue2 && GM_getValue2) {
            GM_setValue2(key, localStorageData);
            migratedCount += 1;
            totalDataSize += localStorageData.length;
            productionLog3(`\u{1F4E6} [MIGRATION] Migrated ${key} (${localStorageData.length} chars)`);
            const verification = GM_getValue2(key, null);
            if (verification === localStorageData) {
              productionLog3(`\u2705 [MIGRATION] Successfully verified ${key}`);
              win.localStorage.removeItem(key);
              productionLog3(`\u{1F5D1}\uFE0F [MIGRATION] Removed ${key} from localStorage`);
            } else {
              console.error(`\u274C [MIGRATION] Verification failed for ${key} - keeping localStorage version`);
            }
          } else {
            productionLog3(`\u{1F4DD} [MIGRATION] No data found for ${key} in localStorage`);
          }
        } catch (error) {
          console.error(`\u274C [MIGRATION] Failed to migrate ${key}:`, error);
        }
        if (ric) {
          ric(() => migrateKeys(keyIndex + 1));
        } else {
          setTimeout(() => migrateKeys(keyIndex + 1), 0);
        }
      };
      migrateKeys();
      return { success: true, migratedCount, totalDataSize };
    } catch (error) {
      console.error(`\u274C [MIGRATION] Migration process failed:`, error);
      return { success: false, error: error.message };
    }
  }
  function getMigrationStatus(dependencies = {}) {
    const { GM_getValue: GM_getValue2 = null } = dependencies;
    const migrationComplete = GM_getValue2 ? GM_getValue2("MGA_migration_completed", false) : false;
    const migrationStats = GM_getValue2 ? GM_getValue2("MGA_migration_stats", null) : null;
    const migrationTimestamp = GM_getValue2 ? GM_getValue2("MGA_migration_timestamp", null) : null;
    return {
      completed: migrationComplete,
      stats: migrationStats,
      timestamp: migrationTimestamp ? new Date(migrationTimestamp).toISOString() : null
    };
  }

  // src/utils/runtime-utilities.js
  var runtime_utilities_exports = {};
  __export(runtime_utilities_exports, {
    RuntimeUtilities: () => RuntimeUtilities,
    clearAllManagedIntervals: () => clearAllManagedIntervals,
    clearManagedInterval: () => clearManagedInterval,
    closeAllPopoutWindows: () => closeAllPopoutWindows,
    getCachedElement: () => getCachedElement,
    getCachedElements: () => getCachedElements,
    hookAtom: () => hookAtom2,
    invalidateCache: () => invalidateCache,
    listenToSlotIndexAtom: () => listenToSlotIndexAtom2,
    readAtom: () => readAtom2,
    safeSendMessage: () => safeSendMessage,
    sendToGame: () => sendToGame,
    setManagedInterval: () => setManagedInterval,
    trackPopoutWindow: () => trackPopoutWindow
  });
  function setManagedInterval(name, callback, delay, dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState, debugLog: debugLog3 = console.log } = dependencies;
    if (UnifiedState3?.intervals?.[name]) {
      clearInterval(UnifiedState3.intervals[name]);
    }
    const intervalId = setInterval(callback, delay);
    if (UnifiedState3 && UnifiedState3.intervals) {
      UnifiedState3.intervals[name] = intervalId;
    }
    debugLog3("PERFORMANCE", `Created managed interval: ${name} (${delay}ms)`);
    return intervalId;
  }
  function clearManagedInterval(name, dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState, debugLog: debugLog3 = console.log } = dependencies;
    if (UnifiedState3?.intervals?.[name]) {
      clearInterval(UnifiedState3.intervals[name]);
      UnifiedState3.intervals[name] = null;
      debugLog3("PERFORMANCE", `Cleared managed interval: ${name}`);
    }
  }
  function clearAllManagedIntervals(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState, debugLog: debugLog3 = console.log } = dependencies;
    if (UnifiedState3 && UnifiedState3.intervals) {
      Object.keys(UnifiedState3.intervals).forEach((name) => {
        clearManagedInterval(name, dependencies);
      });
      debugLog3("PERFORMANCE", "Cleared all managed intervals");
    }
  }
  function trackPopoutWindow(popoutWindow, dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    if (UnifiedState3 && UnifiedState3.popoutWindows) {
      UnifiedState3.popoutWindows.add(popoutWindow);
      popoutWindow.addEventListener("beforeunload", () => {
        UnifiedState3.popoutWindows.delete(popoutWindow);
      });
    }
  }
  function closeAllPopoutWindows(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState, debugError: debugError2 = console.error } = dependencies;
    if (UnifiedState3 && UnifiedState3.popoutWindows) {
      UnifiedState3.popoutWindows.forEach((window2) => {
        try {
          window2.close();
        } catch (e) {
          debugError2("PERFORMANCE", "Error closing popout window", e);
        }
      });
      UnifiedState3.popoutWindows.clear();
    }
  }
  var elementCache = /* @__PURE__ */ new WeakMap();
  var CACHE_DURATION = 1e3;
  function getCachedElement(selector, context = document) {
    const now = Date.now();
    const key = `${selector}_${context.id || "document"}`;
    let cached = elementCache.get(context);
    if (cached && cached[key] && now - cached[key].time < CACHE_DURATION) {
      return cached[key].element;
    }
    const element = context.querySelector(selector);
    if (!cached) cached = {};
    cached[key] = { element, time: now };
    elementCache.set(context, cached);
    return element;
  }
  function getCachedElements(selector, context = document) {
    const now = Date.now();
    const key = `${selector}_all_${context.id || "document"}`;
    let cached = elementCache.get(context);
    if (cached && cached[key] && now - cached[key].time < CACHE_DURATION) {
      return cached[key].elements;
    }
    const elements = context.querySelectorAll(selector);
    if (!cached) cached = {};
    cached[key] = { elements, time: now };
    elementCache.set(context, cached);
    return elements;
  }
  function invalidateCache(context = document) {
    elementCache.delete(context);
  }
  function safeSendMessage(message, dependencies = {}) {
    const { targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null, productionWarn: productionWarn3 = console.warn } = dependencies;
    try {
      if (!targetWindow3.MagicCircle_RoomConnection) {
        productionWarn3("\u26A0\uFE0F MagicCircle_RoomConnection not available");
        return false;
      }
      if (typeof targetWindow3.MagicCircle_RoomConnection.sendMessage !== "function") {
        productionWarn3("\u26A0\uFE0F sendMessage is not a function or not available");
        return false;
      }
      targetWindow3.MagicCircle_RoomConnection.sendMessage(message);
      return true;
    } catch (error) {
      console.error("\u274C Error sending message:", error);
      return false;
    }
  }
  function sendToGame(payloadObj, dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      productionLog: productionLog3 = console.log,
      productionWarn: productionWarn3 = console.warn
    } = dependencies;
    const msg = { scopePath: ["Room", "Quinoa"], ...payloadObj };
    try {
      if (!targetWindow3.MagicCircle_RoomConnection || !targetWindow3.MagicCircle_RoomConnection.sendMessage) {
        productionWarn3("\u26A0\uFE0F MagicCircle_RoomConnection not available for sendToGame");
        return false;
      }
      productionLog3("\u{1F3AE} sendToGame:", msg);
      targetWindow3.MagicCircle_RoomConnection.sendMessage(msg);
      return true;
    } catch (error) {
      console.error("\u274C sendToGame error:", error);
      return false;
    }
  }
  function readAtom2(atomName, dependencies = {}) {
    const {
      unsafeWindow: unsafeWin = typeof unsafeWindow !== "undefined" ? unsafeWindow : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null
    } = dependencies;
    const gw = unsafeWin || targetWindow3;
    try {
      if (gw.MGTools?.store?.getAtomValue) return gw.MGTools.store.getAtomValue(atomName);
    } catch {
    }
    return null;
  }
  function hookAtom2(atomPath, windowKey, callback, retryCount = 0, dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      productionLog: productionLog3 = console.log,
      productionWarn: productionWarn3 = console.warn,
      isUserscript: isUserscript2 = typeof unsafeWindow !== "undefined",
      hookedAtoms: hookedAtoms2 = /* @__PURE__ */ new Set(),
      atomReferences: atomReferences2 = /* @__PURE__ */ new Map()
    } = dependencies;
    const maxRetries = 60;
    const hookKey = `${atomPath}_${windowKey}`;
    if (retryCount === 0 && hookedAtoms2.has(hookKey)) {
      productionLog3(`[HOOK] Already hooked: ${windowKey} - skipping duplicate`);
      return;
    }
    if (retryCount === 0) {
      console.log("  - targetWindow.jotaiAtomCache:", typeof targetWindow3.jotaiAtomCache, targetWindow3.jotaiAtomCache);
      console.log("  - isUserscript:", isUserscript2, "(using unsafeWindow:", isUserscript2 ? "YES" : "NO)");
      const jotaiKeys = Object.keys(targetWindow3).filter((k) => k.toLowerCase().includes("jotai"));
      console.log('  - Keys with "jotai" on targetWindow:', jotaiKeys);
    }
    let atomCache = null;
    if (targetWindow3.jotaiAtomCache) {
      atomCache = targetWindow3.jotaiAtomCache.cache || targetWindow3.jotaiAtomCache;
    }
    if (!atomCache && typeof window !== "undefined" && window.jotaiAtomCache) {
      atomCache = window.jotaiAtomCache.cache || window.jotaiAtomCache;
    }
    if (!atomCache && typeof window !== "undefined" && window.top && window.top.jotaiAtomCache) {
      atomCache = window.top.jotaiAtomCache.cache || window.top.jotaiAtomCache;
    }
    if (!atomCache || !atomCache.get) {
      if (retryCount >= maxRetries) {
        console.error(
          `\u274C [ATOM-HOOK] Gave up waiting for atom store for ${windowKey} after ${maxRetries} retries (${maxRetries / 2}s)`
        );
        console.error(`\u274C [ATOM-HOOK] Final check - targetWindow.jotaiAtomCache:`, targetWindow3.jotaiAtomCache);
        console.error(`\u274C [ATOM-HOOK] Using unsafeWindow:`, isUserscript2);
        console.error(`\u274C [ATOM-HOOK] Script will continue with reduced functionality`);
        productionWarn3(`\u26A0\uFE0F [ATOM-HOOK] Gave up waiting for atom store for ${windowKey} after ${maxRetries} retries`);
        productionWarn3(`\u26A0\uFE0F [ATOM-HOOK] Script will continue with reduced functionality`);
        return;
      }
      const delay = Math.min(50 * Math.pow(2, Math.min(retryCount, 3)), 500);
      setTimeout(() => hookAtom2(atomPath, windowKey, callback, retryCount + 1, dependencies), delay);
      return;
    }
    productionLog3(`\u{1F517} Attempting to hook atom: ${windowKey} at path: ${atomPath}`);
    try {
      const atom = atomCache.get(atomPath);
      if (!atom || !atom.read) {
        productionWarn3(`\u274C Could not find atom for ${atomPath}`);
        const allAtoms = Array.from(atomCache.keys());
        const petAtoms = allAtoms.filter((key) => key.includes("Pet") || key.includes("pet") || key.includes("Slot"));
        productionLog3("\u{1F50D} Pet-related atoms:", petAtoms);
        productionLog3("\u{1F50D} All atoms (first 20):", allAtoms.slice(0, 20));
        return;
      }
      const originalRead = atom.read;
      atom.read = function(get) {
        const rawValue = originalRead.call(this, get);
        if (windowKey === "activePets" && UnifiedState3?.data?.settings?.debugMode) {
          productionLog3(`\u{1F43E} [ATOM-DEBUG] ${windowKey} raw value:`, {
            value: rawValue,
            type: typeof rawValue,
            isArray: Array.isArray(rawValue),
            length: rawValue?.length,
            firstItem: rawValue?.[0]
          });
        }
        let finalValue = rawValue;
        if (callback) {
          const callbackResult = callback(rawValue);
          if (callbackResult !== void 0) {
            finalValue = callbackResult;
            if (windowKey === "activePets" && UnifiedState3?.data?.settings?.debugMode) {
              productionLog3(`\u{1F43E} [ATOM-DEBUG] ${windowKey} transformed by callback:`, finalValue);
            }
          }
        }
        if (UnifiedState3 && UnifiedState3.atoms) {
          UnifiedState3.atoms[windowKey] = finalValue;
        }
        if (typeof window !== "undefined") {
          window[windowKey] = finalValue;
        }
        if (windowKey === "activePets" && UnifiedState3?.data?.settings?.debugMode) {
          productionLog3(`\u{1F43E} [ATOM-DEBUG] ${windowKey} stored in UnifiedState:`, {
            count: finalValue?.length || 0,
            value: finalValue
          });
        }
        return rawValue;
      };
      productionLog3(`\u2705 hookAtom: Successfully hooked ${windowKey}`);
      hookedAtoms2.add(hookKey);
      atomReferences2.set(windowKey, {
        atom,
        atomCache,
        atomPath
      });
      productionLog3(`\u{1F4E6} Stored atom reference for ${windowKey} (can now re-query for fresh data)`);
    } catch (error) {
      console.error(`\u274C Error hooking ${atomPath}:`, error);
    }
  }
  function listenToSlotIndexAtom2(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      CONFIG: CONFIG2 = { DEBUG: { FLAGS: { FIX_VALIDATION: false } } },
      productionLog: productionLog3 = console.log,
      insertTurtleEstimate: insertTurtleEstimate3 = null
    } = dependencies;
    productionLog3("\u{1F50D} [SLOT-ATOM] Starting slot index atom listener...");
    if (typeof targetWindow3._mgtools_currentSlotIndex === "undefined") {
      targetWindow3._mgtools_currentSlotIndex = 0;
      console.log("\u{1F3AF} [SLOT-ATOM] Initialized slot index to 0");
    }
    const tryHookingViaCache = () => {
      const atomCache = targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache;
      if (!atomCache || !atomCache.get) {
        productionLog3("\u23F3 [SLOT-ATOM] Waiting for jotaiAtomCache...");
        return false;
      }
      const possiblePaths = [
        "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotIndexAtom",
        "myCurrentGrowSlotIndexAtom",
        "myCurrentGrowSlotIndex"
      ];
      for (const path of possiblePaths) {
        const atom = atomCache.get(path);
        if (atom && atom.read) {
          productionLog3(`\u2705 [SLOT-ATOM] Found slot atom at: ${path}`);
          const originalRead = atom.read;
          atom.read = function(get) {
            const value = originalRead.call(this, get);
            const idx = Number.isFinite(value) ? value : 0;
            if (targetWindow3._mgtools_currentSlotIndex !== idx) {
              targetWindow3._mgtools_currentSlotIndex = idx;
              console.log(`\u{1F3AF} [SLOT-ATOM-CACHE] Slot index changed to: ${idx}`);
              if (typeof insertTurtleEstimate3 === "function") {
                requestAnimationFrame(() => insertTurtleEstimate3());
              }
            }
            return value;
          };
          return true;
        }
      }
      const allAtoms = Array.from(atomCache.keys());
      const slotAtoms = allAtoms.filter(
        (key) => key.includes("Slot") || key.includes("slot") || key.includes("Index") || key.includes("index")
      );
      productionLog3("\u{1F50D} [SLOT-ATOM] Slot-related atoms found:", slotAtoms);
      const slotIndexAtom = slotAtoms.find((key) => key.includes("GrowSlotIndex") || key.includes("CurrentGrowSlotIndex"));
      if (slotIndexAtom) {
        productionLog3(`\u{1F3AF} [SLOT-ATOM] Found potential slot atom: ${slotIndexAtom}`);
        return tryHookingViaCache();
      }
      return false;
    };
    const setupKeyWatcher = () => {
      productionLog3("\u{1F3AE} [SLOT-ATOM] Setting up X/C key and arrow click watcher as fallback...");
      let lastCropHash = "";
      const getCropHashSimple = (crops) => {
        if (!crops || !crops.length) return "";
        return crops.map((c) => `${c.species}_${c.endTime}`).join("|");
      };
      const qmt = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
      function findAtom(cache, names = ["myCurrentGrowSlotIndexAtom"]) {
        if (!cache) return null;
        if (cache.get) {
          for (const n of names) {
            if (cache.get(n)) return cache.get(n);
          }
          for (const [k, v] of cache.entries?.() ?? []) {
            if (names.some((n) => k.endsWith(n))) return v;
          }
        } else {
          for (const k of Object.keys(cache)) {
            if (names.some((n) => k === n || k.endsWith(n))) return cache[k];
          }
        }
        return null;
      }
      function readAtomValue(atom) {
        try {
          if (typeof atom?.lastValue !== "undefined") return atom.lastValue;
          if (typeof atom?.read === "function" && typeof atom?.init !== "undefined") {
            const ctx = { get: (a) => a === atom ? atom.init : void 0 };
            return atom.read(ctx);
          }
        } catch {
        }
        return void 0;
      }
      function setSlotIndex(idx) {
        targetWindow3._mgtools_currentSlotIndex = idx;
        if (CONFIG2.DEBUG.FLAGS.FIX_VALIDATION) {
          console.log("[FIX_SLOT] Set slot index to:", idx);
        }
      }
      function syncSlotIndexFromGame() {
        const atomCache = targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache;
        if (!atomCache) return null;
        const slotAtom = findAtom(atomCache, ["myCurrentGrowSlotIndexAtom"]);
        if (!slotAtom) return null;
        const gameIndex = readAtomValue(slotAtom);
        if (!Number.isFinite(gameIndex)) return null;
        const currentIndex = targetWindow3._mgtools_currentSlotIndex || 0;
        if (gameIndex !== currentIndex) {
          setSlotIndex(gameIndex);
          qmt(() => {
            requestAnimationFrame(() => {
              if (typeof insertTurtleEstimate3 === "function") {
                insertTurtleEstimate3();
              }
            });
          });
          if (CONFIG2.DEBUG.FLAGS.FIX_VALIDATION) {
            targetWindow3._mgtools_syncCount = (targetWindow3._mgtools_syncCount || 0) + 1;
            console.log("[FIX_HARVEST] Synced to game slot:", {
              from: currentIndex,
              to: gameIndex,
              syncCount: targetWindow3._mgtools_syncCount
            });
          }
          return gameIndex;
        }
        return null;
      }
      targetWindow3.syncSlotIndexFromGame = syncSlotIndexFromGame;
      const updateSlotIndex = (direction) => {
        const currentCrop = UnifiedState3?.atoms?.currentCrop || targetWindow3.currentCrop || [];
        const sortedIndices = UnifiedState3?.atoms?.sortedSlotIndices || targetWindow3.sortedSlotIndices;
        if (!currentCrop || currentCrop.length <= 1) return;
        const maxIndex = sortedIndices?.length || currentCrop.length;
        if (direction === "forward") {
          targetWindow3._mgtools_currentSlotIndex = (targetWindow3._mgtools_currentSlotIndex + 1) % maxIndex;
        } else if (direction === "backward") {
          targetWindow3._mgtools_currentSlotIndex = (targetWindow3._mgtools_currentSlotIndex - 1 + maxIndex) % maxIndex;
        }
        console.log(
          `\u{1F3AF} [SLOT-KEY] Cycled ${direction} - slot index: ${targetWindow3._mgtools_currentSlotIndex}/${maxIndex}`
        );
        setTimeout(() => {
          if (typeof insertTurtleEstimate3 === "function") {
            insertTurtleEstimate3();
          }
        }, 100);
      };
      targetDocument2.addEventListener(
        "keydown",
        (e) => {
          const active = targetDocument2.activeElement;
          if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) return;
          const currentCrop = UnifiedState3?.atoms?.currentCrop || targetWindow3.currentCrop || [];
          if (!currentCrop || currentCrop.length <= 1) return;
          const currentHash = getCropHashSimple(currentCrop);
          if (currentHash !== lastCropHash) {
            targetWindow3._mgtools_currentSlotIndex = 0;
            lastCropHash = currentHash;
            console.log(`\u{1F504} [SLOT-KEY] New crop detected, reset index to 0`);
          }
          if (e.key.toLowerCase() === "x") {
            updateSlotIndex("forward");
          } else if (e.key.toLowerCase() === "c") {
            updateSlotIndex("backward");
          }
        },
        true
      );
      targetDocument2.addEventListener(
        "click",
        (e) => {
          const target = e.target;
          if (!target) return;
          const button = target.closest("button");
          if (!button) return;
          const hasLeftArrow = button.querySelector('svg[data-icon="chevron-left"]') || button.innerHTML.includes("chevron-left") || button.getAttribute("aria-label")?.includes("Previous");
          const hasRightArrow = button.querySelector('svg[data-icon="chevron-right"]') || button.innerHTML.includes("chevron-right") || button.getAttribute("aria-label")?.includes("Next");
          if (hasLeftArrow) {
            console.log("\u2B05\uFE0F [SLOT-ARROW] Left arrow clicked");
            updateSlotIndex("backward");
          } else if (hasRightArrow) {
            console.log("\u27A1\uFE0F [SLOT-ARROW] Right arrow clicked");
            updateSlotIndex("forward");
          }
        },
        true
      );
      console.log("\u2705 [SLOT-ATOM] Key and arrow watchers installed");
    };
    setupKeyWatcher();
    let attempts = 0;
    const checkInterval = setInterval(() => {
      attempts++;
      if (tryHookingViaCache()) {
        clearInterval(checkInterval);
        productionLog3("\u2705 [SLOT-ATOM] Successfully hooked slot index atom via cache!");
      } else if (attempts >= 10) {
        clearInterval(checkInterval);
        productionLog3("\u2139\uFE0F [SLOT-ATOM] Using key watcher for slot tracking");
      }
    }, 1e3);
  }
  var RuntimeUtilities = {
    // Interval Management
    setManagedInterval,
    clearManagedInterval,
    clearAllManagedIntervals,
    // Popout Window Tracking
    trackPopoutWindow,
    closeAllPopoutWindows,
    // DOM Query Cache
    getCachedElement,
    getCachedElements,
    invalidateCache,
    // Game Communication
    safeSendMessage,
    sendToGame,
    // Atom Utilities
    readAtom: readAtom2,
    hookAtom: hookAtom2,
    listenToSlotIndexAtom: listenToSlotIndexAtom2
  };

  // src/utils/memory-management.js
  var memory_management_exports = {};
  __export(memory_management_exports, {
    MemoryManagement: () => MemoryManagement,
    initializeMemoryManagement: () => initializeMemoryManagement
  });
  function initializeMemoryManagement(dependencies = {}) {
    const {
      productionLog: productionLog3 = console.log,
      productionWarn: productionWarn3 = console.warn,
      MGA_saveJSON: MGA_saveJSON2,
      MGA_loadJSON: MGA_loadJSON2,
      UnifiedState: UnifiedState3,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null
    } = dependencies;
    const mgaCleanupHandlers = [];
    let mgaIntervals = [];
    let mgaTimeouts = [];
    const saveTimeouts = /* @__PURE__ */ new Map();
    const MGA_MemoryConfig = {
      maxLogsInMemory: 1e3,
      // Keep latest 1000 logs in memory
      maxLogsInStorage: 1e4,
      // Archive up to 10000 logs in storage
      saveDebounceMs: 2e3,
      // Debounce saves by 2 seconds
      domPoolSize: 50
      // Pool size for DOM elements
    };
    function MGA_addCleanupHandler(handler) {
      if (typeof handler === "function") {
        mgaCleanupHandlers.push(handler);
      }
    }
    function MGA_addInterval(interval) {
      mgaIntervals.push(interval);
      return interval;
    }
    function MGA_addTimeout(timeout) {
      mgaTimeouts.push(timeout);
      return timeout;
    }
    function MGA_cleanup() {
      productionLog3("\u{1F9F9} [MEMORY] Starting MGA cleanup...");
      try {
        mgaIntervals.forEach((interval) => {
          if (interval) {
            clearInterval(interval);
          }
        });
        productionLog3(`\u{1F9F9} [MEMORY] Cleared ${mgaIntervals.length} intervals`);
        mgaIntervals = [];
        mgaTimeouts.forEach((timeout) => {
          if (timeout) {
            clearTimeout(timeout);
          }
        });
        productionLog3(`\u{1F9F9} [MEMORY] Cleared ${mgaTimeouts.length} timeouts`);
        mgaTimeouts = [];
        mgaCleanupHandlers.forEach((handler, index) => {
          try {
            handler();
            productionLog3(`\u{1F9F9} [MEMORY] Executed cleanup handler ${index + 1}`);
          } catch (error) {
            console.error(`\u274C [MEMORY] Cleanup handler ${index + 1} failed:`, error);
          }
        });
        if (targetWindow3 && targetWindow3.MGA_Internal && targetWindow3.MGA_Internal.eventListeners) {
          targetWindow3.MGA_Internal.eventListeners.forEach(({ element, event, handler }) => {
            try {
              element.removeEventListener(event, handler);
            } catch (error) {
              productionWarn3(`\u26A0\uFE0F [MEMORY] Failed to remove event listener:`, error);
            }
          });
          productionLog3(`\u{1F9F9} [MEMORY] Removed ${targetWindow3.MGA_Internal.eventListeners.length} event listeners`);
          targetWindow3.MGA_Internal.eventListeners = [];
        }
        if (targetWindow3 && targetWindow3.UnifiedState && MGA_saveJSON2) {
          const criticalData = {
            petPresets: targetWindow3.UnifiedState.data?.petPresets,
            seedsToDelete: targetWindow3.UnifiedState.data?.seedsToDelete,
            settings: targetWindow3.UnifiedState.data?.settings
          };
          Object.keys(criticalData).forEach((key) => {
            if (criticalData[key] !== void 0) {
              MGA_saveJSON2(`MGA_${key}`, criticalData[key]);
            }
          });
        }
        productionLog3("\u2705 [MEMORY] MGA cleanup completed successfully");
      } catch (error) {
        console.error("\u274C [MEMORY] MGA cleanup failed:", error);
      }
    }
    function MGA_debouncedSave(key, data) {
      if (saveTimeouts.has(key)) {
        clearTimeout(saveTimeouts.get(key));
      }
      const timeout = setTimeout(() => {
        try {
          if (MGA_saveJSON2) {
            MGA_saveJSON2(key, data);
            productionLog3(`\u{1F4BE} [MEMORY] Debounced save completed for ${key}`);
          }
        } catch (error) {
          console.error(`\u274C [MEMORY] Debounced save failed for ${key}:`, error);
        }
        saveTimeouts.delete(key);
      }, MGA_MemoryConfig.saveDebounceMs);
      saveTimeouts.set(key, timeout);
    }
    function MGA_manageLogMemory2(logs) {
      if (!Array.isArray(logs) || logs.length <= MGA_MemoryConfig.maxLogsInMemory) {
        return logs;
      }
      productionLog3(
        `\u{1F9E0} [MEMORY] Managing log memory: ${logs.length} logs, keeping ${MGA_MemoryConfig.maxLogsInMemory} in memory`
      );
      const recentLogs = logs.slice(0, MGA_MemoryConfig.maxLogsInMemory);
      const archivedLogs = logs.slice(MGA_MemoryConfig.maxLogsInMemory);
      if (archivedLogs.length > 0 && MGA_loadJSON2 && MGA_saveJSON2) {
        const existingArchive = MGA_loadJSON2("MGA_petAbilityLogs_archive", []);
        const combinedArchive = [...archivedLogs, ...existingArchive].slice(0, MGA_MemoryConfig.maxLogsInStorage);
        MGA_debouncedSave("MGA_petAbilityLogs_archive", combinedArchive);
        productionLog3(`\u{1F4E6} [MEMORY] Archived ${archivedLogs.length} logs to storage`);
      }
      const wrapLogsArray2 = dependencies.wrapLogsArray;
      return typeof wrapLogsArray2 === "function" ? wrapLogsArray2(recentLogs) : recentLogs;
    }
    function MGA_getAllLogs2() {
      const memoryLogs = UnifiedState3?.data?.petAbilityLogs || [];
      const archivedLogs = MGA_loadJSON2 ? MGA_loadJSON2("MGA_petAbilityLogs_archive", []) : [];
      const allLogs = [...memoryLogs, ...archivedLogs];
      allLogs.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      productionLog3(
        `\u{1F4DC} [MEMORY] Retrieved ${memoryLogs.length} memory logs + ${archivedLogs.length} archived logs = ${allLogs.length} total`
      );
      return allLogs;
    }
    const MGA_DOMPool = {
      pools: /* @__PURE__ */ new Map(),
      /**
       * Get element from pool or create new one
       *
       * @param {string} tagName - HTML tag name
       * @param {string} className - CSS class name
       * @returns {HTMLElement} DOM element
       *
       * @example
       * const div = MGA_DOMPool.getElement('div', 'my-class');
       */
      getElement: function(tagName, className = "") {
        const key = `${tagName}:${className}`;
        if (!this.pools.has(key)) {
          this.pools.set(key, []);
        }
        const pool = this.pools.get(key);
        if (pool.length > 0) {
          const element2 = pool.pop();
          element2.innerHTML = "";
          element2.removeAttribute("style");
          element2.className = className;
          return element2;
        }
        if (!targetDocument2) return null;
        const element = targetDocument2.createElement(tagName);
        if (className) element.className = className;
        return element;
      },
      /**
       * Return element to pool for reuse
       *
       * @param {HTMLElement} element - Element to return
       *
       * @example
       * MGA_DOMPool.returnElement(myDiv);
       */
      returnElement: function(element) {
        if (!element || !element.tagName) return;
        const key = `${element.tagName.toLowerCase()}:${element.className || ""}`;
        if (!this.pools.has(key)) {
          this.pools.set(key, []);
        }
        const pool = this.pools.get(key);
        if (pool.length < MGA_MemoryConfig.domPoolSize) {
          element.innerHTML = "";
          element.removeAttribute("style");
          element.onclick = null;
          element.onmouseover = null;
          element.onmouseout = null;
          pool.push(element);
        }
      },
      /**
       * Clean up DOM element pools
       *
       * @example
       * MGA_DOMPool.cleanup();
       */
      cleanup: function() {
        productionLog3("\u{1F9F9} [MEMORY] Cleaning DOM element pools");
        this.pools.clear();
      }
    };
    MGA_addCleanupHandler(() => {
      MGA_DOMPool.cleanup();
      saveTimeouts.forEach((timeout) => clearTimeout(timeout));
      saveTimeouts.clear();
    });
    function setupCleanupListeners() {
      if (!targetWindow3) return;
      targetWindow3.addEventListener("beforeunload", () => {
        productionLog3("\u{1F504} [MEMORY] Page unloading, starting cleanup...");
        MGA_cleanup();
      });
      targetWindow3.addEventListener("pagehide", () => {
        productionLog3("\u{1F504} [MEMORY] Page hiding, starting cleanup...");
        MGA_cleanup();
      });
    }
    return {
      // Cleanup handlers
      MGA_addCleanupHandler,
      MGA_addInterval,
      MGA_addTimeout,
      MGA_cleanup,
      // Debounced save
      MGA_debouncedSave,
      // Log management
      MGA_manageLogMemory: MGA_manageLogMemory2,
      MGA_getAllLogs: MGA_getAllLogs2,
      // DOM pooling
      MGA_DOMPool,
      // Configuration
      MGA_MemoryConfig,
      // Setup
      setupCleanupListeners
    };
  }
  var MemoryManagement = {
    initializeMemoryManagement
  };

  // src/utils/platform-detection.js
  var platform_detection_exports = {};
  __export(platform_detection_exports, {
    PlatformDetection: () => PlatformDetection,
    checkBrowserFeatures: () => checkBrowserFeatures,
    createPlatformDetection: () => createPlatformDetection2,
    detectEnvironment: () => detectEnvironment2,
    getBrowserInfo: () => getBrowserInfo
  });
  function detectEnvironment2(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      document: doc = typeof document !== "undefined" ? document : null,
      productionLog: productionLog3 = console.log
    } = dependencies;
    if (!targetWindow3) {
      return { isGameEnvironment: false, isStandalone: true, gameReady: false };
    }
    const environment = {
      isGameEnvironment: false,
      isStandalone: false,
      isDiscordEmbed: false,
      gameReady: false,
      url: targetWindow3.location.href,
      hasJotaiAtoms: !!((targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache)?.size > 0),
      hasMagicCircleConnection: !!(targetWindow3.MagicCircle_RoomConnection && typeof targetWindow3.MagicCircle_RoomConnection === "object"),
      domain: targetWindow3.location.hostname,
      readyState: doc ? doc.readyState : "unknown"
    };
    productionLog3("\u{1F50D} [ENV-DEBUG] Detecting environment:", {
      domain: environment.domain,
      pathname: targetWindow3.location.pathname,
      url: environment.url,
      hasAtoms: environment.hasJotaiAtoms,
      hasConnection: environment.hasMagicCircleConnection
    });
    const gameHosts = ["magiccircle.gg", "magicgarden.gg", "starweaver.org", "discordsays.com"];
    const isGameDomain = gameHosts.some((host) => environment.domain.includes(host));
    const hasGamePath = targetWindow3.location.pathname.includes("/r/");
    const isDiscordActivity = environment.domain.includes("discordsays.com");
    productionLog3("\u{1F50D} [ENV-DEBUG] Game checks:", {
      isGameDomain,
      hasGamePath,
      isDiscordActivity,
      willEnterGameMode: isGameDomain && (hasGamePath || isDiscordActivity)
    });
    if (isGameDomain && (hasGamePath || isDiscordActivity)) {
      const isInIframe = targetWindow3.location !== targetWindow3.parent.location;
      const isDiscordDesktopApp = targetWindow3.DiscordNative !== void 0;
      productionLog3("\u{1F3AE} [ENV] Running in game environment:", environment.domain);
      if (isDiscordActivity) {
        productionLog3("\u{1F3AE} [DISCORD-ACTIVITY] Detected Discord Activity iframe!");
      }
      productionLog3("\u{1F3AE} [ENV] IsIframe:", isInIframe, "| DiscordNative:", isDiscordDesktopApp);
      environment.isGameEnvironment = true;
      environment.isStandalone = false;
      environment.gameReady = environment.hasJotaiAtoms && environment.hasMagicCircleConnection && doc && doc.readyState === "complete";
      let initStrategy2 = "unknown";
      if (environment.gameReady) {
        initStrategy2 = "game-ready";
      } else {
        initStrategy2 = "game-wait";
      }
      environment.initStrategy = initStrategy2;
      return environment;
    }
    const isDiscordDomain = environment.domain.includes("discord.com");
    if (isDiscordDomain) {
      environment.isDiscordEmbed = true;
      productionLog3("\u{1F3AE} [DISCORD] Running on Discord page - looking for game iframe...");
      if (doc) {
        const gameIframes = doc.querySelectorAll("iframe");
        let foundGameIframe = false;
        for (const iframe of gameIframes) {
          try {
            const iframeSrc = iframe.src || "";
            if (gameHosts.some((host) => iframeSrc.includes(host))) {
              productionLog3("\u2705 [DISCORD] Found game iframe:", iframeSrc);
              productionLog3("\u{1F4A1} [DISCORD] Script should be running inside that iframe");
              foundGameIframe = true;
            }
          } catch (e) {
          }
        }
        if (foundGameIframe) {
          productionLog3(
            "\u26A0\uFE0F [DISCORD] On Discord page - script will only run inside the game iframe, not on Discord page itself"
          );
        } else {
          productionLog3("\u26A0\uFE0F [DISCORD] On Discord page but no game iframe found yet");
        }
      }
      environment.isStandalone = false;
      environment.initStrategy = "skip";
      return environment;
    }
    environment.isGameEnvironment = false;
    environment.isStandalone = true;
    environment.gameReady = false;
    let initStrategy = "unknown";
    if (environment.gameReady) {
      initStrategy = "game-ready";
    } else if (environment.isGameEnvironment) {
      initStrategy = "game-wait";
    } else {
      initStrategy = "standalone";
    }
    environment.initStrategy = initStrategy;
    return environment;
  }
  function createPlatformDetection2(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      navigator: nav = typeof navigator !== "undefined" ? navigator : null
    } = dependencies;
    if (!targetWindow3 || !nav) {
      return {
        isDiscord: false,
        isMobile: false,
        isIframe: false,
        isTouch: false,
        getLayout: () => "desktop",
        getScaleFactor: () => 1,
        getSafeArea: () => ({ top: 0, bottom: 0, left: 0, right: 0 })
      };
    }
    const MGA_Platform = {
      // Platform detection
      isDiscord: /discord|overlay|electron/i.test(nav.userAgent) || !!(targetWindow3.DiscordNative || targetWindow3.__discordApp),
      isMobile: /Mobile|Android|iPhone|iPad|iPod/i.test(nav.userAgent) || targetWindow3.matchMedia?.("(max-width: 768px)").matches,
      isIframe: targetWindow3 !== targetWindow3.top,
      isTouch: "ontouchstart" in targetWindow3 || nav.maxTouchPoints > 0,
      /**
       * Get current layout mode
       *
       * @returns {string} Layout mode ('mobile' | 'discord' | 'desktop')
       *
       * @example
       * const layout = MGA_Platform.getLayout();
       */
      getLayout() {
        if (this.isMobile) return "mobile";
        if (this.isDiscord) return "discord";
        return "desktop";
      },
      /**
       * Get UI scale factor based on platform
       *
       * @returns {number} Scale factor (0.85 - 1.0)
       *
       * @example
       * const scale = MGA_Platform.getScaleFactor();
       */
      getScaleFactor() {
        if (this.isMobile) return 0.85;
        if (this.isDiscord) return 0.95;
        return 1;
      },
      /**
       * Get safe area insets for mobile devices
       *
       * @returns {object} Safe area insets
       *
       * @example
       * const safeArea = MGA_Platform.getSafeArea();
       */
      getSafeArea() {
        if (!this.isMobile) {
          return { top: 0, bottom: 0, left: 0, right: 0 };
        }
        const computedStyle = targetWindow3.getComputedStyle?.(targetWindow3.document.documentElement);
        if (computedStyle) {
          return {
            top: parseInt(computedStyle.getPropertyValue("env(safe-area-inset-top)") || "0"),
            bottom: parseInt(computedStyle.getPropertyValue("env(safe-area-inset-bottom)") || "0"),
            left: parseInt(computedStyle.getPropertyValue("env(safe-area-inset-left)") || "0"),
            right: parseInt(computedStyle.getPropertyValue("env(safe-area-inset-right)") || "0")
          };
        }
        return { top: 0, bottom: 0, left: 0, right: 0 };
      }
    };
    return MGA_Platform;
  }
  function getBrowserInfo(dependencies = {}) {
    const { navigator: nav = typeof navigator !== "undefined" ? navigator : null } = dependencies;
    if (!nav) {
      return { name: "unknown", version: "unknown", userAgent: "" };
    }
    const userAgent = nav.userAgent;
    let browserName = "unknown";
    let browserVersion = "unknown";
    if (userAgent.indexOf("Firefox") > -1) {
      browserName = "Firefox";
      browserVersion = userAgent.match(/Firefox\/(\d+)/)?.[1] || "unknown";
    } else if (userAgent.indexOf("Chrome") > -1) {
      browserName = "Chrome";
      browserVersion = userAgent.match(/Chrome\/(\d+)/)?.[1] || "unknown";
    } else if (userAgent.indexOf("Safari") > -1) {
      browserName = "Safari";
      browserVersion = userAgent.match(/Version\/(\d+)/)?.[1] || "unknown";
    } else if (userAgent.indexOf("Edge") > -1) {
      browserName = "Edge";
      browserVersion = userAgent.match(/Edge\/(\d+)/)?.[1] || "unknown";
    }
    return {
      name: browserName,
      version: browserVersion,
      userAgent
    };
  }
  function checkBrowserFeatures(dependencies = {}) {
    const { targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null } = dependencies;
    if (!targetWindow3) {
      return {
        localStorage: false,
        sessionStorage: false,
        indexedDB: false,
        webWorkers: false,
        serviceWorkers: false,
        webSockets: false
      };
    }
    return {
      localStorage: typeof targetWindow3.localStorage !== "undefined",
      sessionStorage: typeof targetWindow3.sessionStorage !== "undefined",
      indexedDB: typeof targetWindow3.indexedDB !== "undefined",
      webWorkers: typeof targetWindow3.Worker !== "undefined",
      serviceWorkers: "serviceWorker" in targetWindow3.navigator,
      webSockets: typeof targetWindow3.WebSocket !== "undefined"
    };
  }
  var PlatformDetection = {
    detectEnvironment: detectEnvironment2,
    createPlatformDetection: createPlatformDetection2,
    getBrowserInfo,
    checkBrowserFeatures
  };

  // src/state/unified-state.js
  var unified_state_exports = {};
  __export(unified_state_exports, {
    UnifiedState: () => UnifiedState2,
    initState: () => initState,
    restoreState: () => restoreState,
    snapshotState: () => snapshotState
  });
  var UnifiedState2 = {
    // ==================== METADATA ====================
    initialized: false,
    jotaiReady: false,
    // Track when Jotai store is ready
    atomsSubscribed: false,
    // Track when atom subscriptions are active
    connectionStatus: false,
    // ==================== UI STATE ====================
    panels: {
      main: null,
      // Main panel reference (structure only, no DOM)
      toggle: null
      // Toggle button reference (structure only, no DOM)
    },
    activeTab: "pets",
    // ==================== INTERVAL MANAGEMENT ====================
    // Structure only - actual timers managed by init module
    intervals: {
      autoDelete: null,
      heartbeat: null,
      activitySimulator: null,
      gameCheck: null,
      connectionCheck: null,
      autoSave: null
    },
    // ==================== POPOUT WINDOWS ====================
    popoutWindows: /* @__PURE__ */ new Set(),
    // Track all popout windows
    // ==================== FIREBASE CONNECTION ====================
    // Structure only - actual connection managed by network/init modules
    firebase: {
      app: null,
      database: null,
      reportInterval: null,
      unsubscribe: null
    },
    // ==================== APPLICATION DATA ====================
    data: {
      // Pet Management
      petPresets: {},
      petPresetsOrder: [],
      // Array to maintain preset display order
      currentPresetIndex: -1,
      // Track position for cycling through presets
      petAbilityLogs: [],
      lastAbilityTimestamps: {},
      // Seeds & Auto-delete
      seedsToDelete: [],
      autoDeleteEnabled: false,
      // Values
      inventoryValue: 0,
      gardenValue: 0,
      tileValue: 0,
      // Room Status
      roomStatus: {
        counts: {},
        // Store room counts {MG1: 3, MG2: 2, ...}
        currentRoom: null,
        reporterId: null
      },
      customRooms: [],
      // Dynamic list of tracked rooms
      // Timers
      timers: {
        seed: null,
        egg: null,
        tool: null,
        lunar: null
      },
      // Settings
      settings: {
        opacity: 95,
        popoutOpacity: 50,
        theme: "default",
        gradientStyle: "blue-purple",
        effectStyle: "none",
        compactMode: false,
        ultraCompactMode: false,
        useInGameOverlays: true,
        // Notifications
        notifications: {
          enabled: true,
          volume: 0.3,
          notificationType: "epic",
          // 'simple', 'triple', 'alarm', 'epic', 'continuous'
          requiresAcknowledgment: false,
          continuousEnabled: false,
          watchedSeeds: ["Carrot", "Sunflower", "Moonbinder", "Dawnbinder", "Starweaver"],
          watchedEggs: ["CommonEgg", "MythicalEgg"],
          watchedDecor: [],
          // Pet hunger notifications
          petHungerEnabled: false,
          petHungerThreshold: 25,
          // Notify when hunger drops below this %
          petHungerSound: "double",
          // Ability trigger notifications
          abilityNotificationsEnabled: false,
          watchedAbilities: [],
          // Legacy - kept for backward compatibility
          watchedAbilityCategories: {
            xpBoost: true,
            cropSizeBoost: true,
            selling: true,
            harvesting: true,
            growthSpeed: true,
            specialMutations: true,
            other: true
          },
          abilityNotificationSound: "single",
          abilityNotificationVolume: 0.2,
          // Weather event notifications
          weatherNotificationsEnabled: false,
          watchedWeatherEvents: ["Snow", "Rain", "AmberMoon", "Dawn"],
          // Shop Firebase integration toggle
          shopFirebaseEnabled: false,
          lastSeenTimestamps: {}
        },
        detailedTimestamps: true,
        // Show HH:MM:SS 24-hour format
        debugMode: false,
        // Enable debug logging
        roomDebugMode: false,
        // Enable detailed room API logging
        hideWeather: false,
        // Hide weather visual effects
        // Auto-favorite
        autoFavorite: {
          enabled: false,
          species: [],
          // List of species names to auto-favorite
          mutations: []
          // List of mutations to auto-favorite
        },
        // UI Settings
        hideFeedButtons: false
        // Default: show feed buttons
      },
      // Hotkeys
      hotkeys: {
        enabled: true,
        gameKeys: {
          inventory: { name: "Open Inventory", original: "e", custom: null },
          harvest: { name: "Harvest/Select", original: " ", custom: null },
          selectLeft: { name: "Select Left Crop", original: "x", custom: null },
          selectRight: { name: "Select Right Crop", original: "c", custom: null },
          hotbar1: { name: "Hotbar Slot 1", original: "1", custom: null },
          hotbar2: { name: "Hotbar Slot 2", original: "2", custom: null },
          hotbar3: { name: "Hotbar Slot 3", original: "3", custom: null },
          hotbar4: { name: "Hotbar Slot 4", original: "4", custom: null },
          hotbar5: { name: "Hotbar Slot 5", original: "5", custom: null },
          hotbar6: { name: "Hotbar Slot 6", original: "6", custom: null },
          hotbar7: { name: "Hotbar Slot 7", original: "7", custom: null },
          hotbar8: { name: "Hotbar Slot 8", original: "8", custom: null },
          hotbar9: { name: "Hotbar Slot 9", original: "9", custom: null },
          teleportShop: { name: "Teleport to Shop", original: "shift+1", custom: null },
          teleportGarden: { name: "Teleport to Garden", original: "shift+2", custom: null },
          teleportSell: { name: "Teleport to Sell", original: "shift+3", custom: null },
          toggleQuickShop: { name: "Toggle Quick Shop", original: "ctrl+b", custom: null }
        },
        mgToolsKeys: {
          openPets: { name: "Open Pets Tab", custom: null },
          openAbilities: { name: "Open Abilities Tab", custom: null },
          openSeeds: { name: "Open Seeds Tab", custom: null },
          openValues: { name: "Open Values Tab", custom: null },
          openTimers: { name: "Open Timers Tab", custom: null },
          openRooms: { name: "Open Rooms Tab", custom: null },
          openShop: { name: "Open Shop Tab", custom: null },
          cyclePresets: { name: "Cycle Pet Presets", custom: null }
        }
      },
      petPresetHotkeys: {},
      // Popouts
      popouts: {
        overlays: /* @__PURE__ */ new Map(),
        // Track in-game overlays (Alt+key)
        windows: /* @__PURE__ */ new Map(),
        // Track separate windows
        widgets: /* @__PURE__ */ new Map()
        // Track shift+click popout widgets
      },
      // Ability Filters
      filterMode: "categories",
      // 'categories', 'byPet', 'custom'
      abilityFilters: {
        xpBoost: true,
        cropSizeBoost: true,
        selling: true,
        harvesting: true,
        growthSpeed: true,
        specialMutations: true,
        other: true
      },
      customMode: {
        selectedAbilities: {}
      },
      petFilters: {
        selectedPets: {}
      }
    },
    // ==================== GAME STATE ATOMS ====================
    // References to game state atoms (managed by init module)
    atoms: {
      activePets: [],
      // Initialize as empty array to prevent null errors
      petAbility: null,
      inventory: null,
      currentCrop: null,
      friendBonus: 1,
      myGarden: null,
      quinoaData: null
    }
  };
  function initState(initial = {}) {
    Logger.info("STATE", "Initializing UnifiedState");
    if (initial && typeof initial === "object") {
      if (initial.data) {
        Object.assign(UnifiedState2.data, initial.data);
      }
      if (initial.settings) {
        Object.assign(UnifiedState2.data.settings, initial.settings);
      }
    }
    try {
      const saved = Storage2.get("MGA_data");
      if (saved) {
        Logger.info("STATE", "Restored state from storage");
        Object.assign(UnifiedState2.data, saved);
      }
    } catch (error) {
      Logger.warn("STATE", "Failed to load saved state", error);
    }
    UnifiedState2.initialized = true;
    Logger.info("STATE", "UnifiedState initialized");
    return UnifiedState2;
  }
  function snapshotState() {
    return {
      initialized: UnifiedState2.initialized,
      jotaiReady: UnifiedState2.jotaiReady,
      atomsSubscribed: UnifiedState2.atomsSubscribed,
      activeTab: UnifiedState2.activeTab,
      data: JSON.parse(JSON.stringify(UnifiedState2.data))
      // Deep copy
    };
  }
  function restoreState(snapshot) {
    if (!snapshot || typeof snapshot !== "object") {
      Logger.warn("STATE", "Invalid snapshot provided to restoreState");
      return false;
    }
    try {
      if (snapshot.initialized !== void 0) {
        UnifiedState2.initialized = snapshot.initialized;
      }
      if (snapshot.jotaiReady !== void 0) {
        UnifiedState2.jotaiReady = snapshot.jotaiReady;
      }
      if (snapshot.atomsSubscribed !== void 0) {
        UnifiedState2.atomsSubscribed = snapshot.atomsSubscribed;
      }
      if (snapshot.activeTab) {
        UnifiedState2.activeTab = snapshot.activeTab;
      }
      if (snapshot.data) {
        Object.assign(UnifiedState2.data, snapshot.data);
      }
      Logger.info("STATE", "State restored from snapshot");
      return true;
    } catch (error) {
      Logger.error("STATE", "Failed to restore state from snapshot", error);
      return false;
    }
  }

  // src/ui/draggable.js
  var draggable_exports = {};
  __export(draggable_exports, {
    default: () => draggable_default,
    loadMainHUDPosition: () => loadMainHUDPosition,
    loadToggleButtonPosition: () => loadToggleButtonPosition,
    makeDraggable: () => makeDraggable,
    makeElementResizable: () => makeElementResizable,
    makeResizable: () => makeResizable,
    makeToggleButtonDraggable: () => makeToggleButtonDraggable,
    saveMainHUDPosition: () => saveMainHUDPosition,
    saveToggleButtonPosition: () => saveToggleButtonPosition
  });
  function makeDraggable(element, handle, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      debugLog: debugLog3 = () => {
      },
      saveMainHUDPosition: savePositionFn = null
    } = dependencies;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;
    handle.style.cursor = "grab";
    const startDrag = (clientX, clientY, event) => {
      if (event.target.tagName === "BUTTON") return;
      if (event.target.classList && event.target.classList.contains("mga-resize-handle")) return;
      event.preventDefault();
      event.stopPropagation();
      isDragging = true;
      startX = clientX;
      startY = clientY;
      const rect = element.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      element.style.willChange = "transform";
      element.style.transition = "none";
      element.style.transform = "scale(1.01)";
      element.style.boxShadow = "0 8px 32px rgba(0, 0, 0, 0.3)";
      element.style.zIndex = "999999";
      handle.style.cursor = "grabbing";
      targetDocument2.body.style.userSelect = "none";
      debugLog3("OVERLAY_LIFECYCLE", "Started dragging main HUD", {
        elementClass: element.className,
        startPosition: { left: startLeft, top: startTop }
      });
    };
    const handleDragMove = (clientX, clientY) => {
      if (!isDragging) return;
      const deltaX = clientX - startX;
      const deltaY = clientY - startY;
      const snapZone = 15;
      let newLeft = startLeft + deltaX;
      let newTop = startTop + deltaY;
      newLeft = Math.max(0, Math.min(window.innerWidth - element.offsetWidth, newLeft));
      newTop = Math.max(0, Math.min(window.innerHeight - element.offsetHeight, newTop));
      if (newLeft < snapZone) {
        newLeft = 0;
        element.style.borderLeft = "2px solid rgba(74, 158, 255, 0.5)";
      } else if (newLeft > window.innerWidth - element.offsetWidth - snapZone) {
        newLeft = window.innerWidth - element.offsetWidth;
        element.style.borderRight = "2px solid rgba(74, 158, 255, 0.5)";
      } else {
        element.style.borderLeft = "";
        element.style.borderRight = "";
      }
      if (newTop < snapZone) {
        newTop = 0;
        element.style.borderTop = "2px solid rgba(74, 158, 255, 0.5)";
      } else if (newTop > window.innerHeight - element.offsetHeight - snapZone) {
        newTop = window.innerHeight - element.offsetHeight;
        element.style.borderBottom = "2px solid rgba(74, 158, 255, 0.5)";
      } else {
        element.style.borderTop = "";
        element.style.borderBottom = "";
      }
      element.style.left = `${newLeft}px`;
      element.style.top = `${newTop}px`;
    };
    const endDrag = () => {
      if (isDragging) {
        isDragging = false;
        element.style.transition = "all 0.2s ease";
        element.style.transform = "scale(1)";
        element.style.boxShadow = "var(--panel-shadow, 0 4px 12px rgba(0, 0, 0, 0.40))";
        element.style.zIndex = "";
        element.style.borderTop = "";
        element.style.borderBottom = "";
        element.style.borderLeft = "";
        element.style.borderRight = "";
        element.style.willChange = "auto";
        handle.style.cursor = "grab";
        targetDocument2.body.style.userSelect = "";
        const finalPosition = {
          left: element.style.left,
          top: element.style.top
        };
        if (savePositionFn) {
          savePositionFn(finalPosition);
        }
        debugLog3("OVERLAY_LIFECYCLE", "Finished dragging main HUD", {
          elementClass: element.className,
          finalPosition
        });
      }
    };
    handle.addEventListener("mousedown", (e) => {
      startDrag(e.clientX, e.clientY, e);
    });
    targetDocument2.addEventListener("mousemove", (e) => {
      handleDragMove(e.clientX, e.clientY);
    });
    targetDocument2.addEventListener("mouseup", () => {
      endDrag();
    });
    handle.addEventListener(
      "touchstart",
      (e) => {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          startDrag(touch.clientX, touch.clientY, e);
        }
      },
      { passive: false }
    );
    targetDocument2.addEventListener(
      "touchmove",
      (e) => {
        if (isDragging && e.touches.length === 1) {
          const touch = e.touches[0];
          handleDragMove(touch.clientX, touch.clientY);
          e.preventDefault();
        }
      },
      { passive: false }
    );
    targetDocument2.addEventListener("touchend", () => {
      endDrag();
    });
    targetDocument2.addEventListener("touchcancel", () => {
      endDrag();
    });
  }
  function saveMainHUDPosition(position, dependencies = {}) {
    const { MGA_saveJSON: MGA_saveJSON2 = null, debugLog: debugLog3 = () => {
    }, debugError: debugError2 = () => {
    } } = dependencies;
    try {
      if (MGA_saveJSON2) {
        MGA_saveJSON2("MGA_mainHUDPosition", position);
      }
      debugLog3("OVERLAY_LIFECYCLE", "Saved main HUD position", { position });
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to save main HUD position", error, { position });
    }
  }
  function loadMainHUDPosition(element, dependencies = {}) {
    const { MGA_loadJSON: MGA_loadJSON2 = null, debugLog: debugLog3 = () => {
    }, debugError: debugError2 = () => {
    } } = dependencies;
    try {
      if (!MGA_loadJSON2) return;
      const savedPosition = MGA_loadJSON2("MGA_mainHUDPosition", null);
      if (savedPosition && savedPosition.left && savedPosition.top) {
        const leftPx = parseInt(savedPosition.left);
        const topPx = parseInt(savedPosition.top);
        if (!isNaN(leftPx) && !isNaN(topPx) && leftPx >= 0 && topPx >= 0 && leftPx < window.innerWidth && topPx < window.innerHeight) {
          element.style.left = savedPosition.left;
          element.style.top = savedPosition.top;
          debugLog3("OVERLAY_LIFECYCLE", "Restored main HUD position", { position: savedPosition });
        }
      }
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to load main HUD position", error);
    }
  }
  function makeElementResizable(element, options = {}) {
    const {
      minWidth = 300,
      minHeight = 250,
      maxWidth = window.innerWidth * 0.9,
      maxHeight = window.innerHeight * 0.9,
      handleSize = 12,
      showHandleOnHover = true
    } = options;
    const existingHandle = element.querySelector(".mga-resize-handle");
    if (existingHandle) {
      existingHandle.remove();
    }
    const resizeHandle = document.createElement("div");
    resizeHandle.className = "mga-resize-handle";
    resizeHandle.title = "Drag to resize";
    resizeHandle.style.cssText = `
      position: absolute;
      bottom: 0;
      right: 0;
      width: ${handleSize}px;
      height: ${handleSize}px;
      cursor: se-resize;
      background: linear-gradient(-45deg, transparent 35%, rgba(74, 158, 255, 0.7) 45%, rgba(74, 158, 255, 0.9) 50%, rgba(74, 158, 255, 0.7) 55%, transparent 65%);
      border-radius: 0 0 4px 0;
      opacity: ${showHandleOnHover ? "0.5" : "0.7"};
      transition: opacity 0.2s ease, background 0.2s ease;
      z-index: 10;
      pointer-events: auto;
  `;
    element.appendChild(resizeHandle);
    if (showHandleOnHover) {
      element.addEventListener("mouseenter", () => {
        resizeHandle.style.opacity = "1.0";
      });
      element.addEventListener("mouseleave", () => {
        if (!element.hasAttribute("data-resizing")) {
          resizeHandle.style.opacity = "0.5";
        }
      });
    }
    let isResizing = false;
    let startX, startY, startWidth, startHeight;
    let rafId = null;
    const onMouseMove = (e) => {
      if (!isResizing) return;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => {
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + (e.clientX - startX)));
        const newHeight = Math.max(minHeight, Math.min(maxHeight, startHeight + (e.clientY - startY)));
        element.style.width = `${newWidth}px`;
        element.style.height = `${newHeight}px`;
      });
    };
    const stopResizing = () => {
      if (!isResizing) return;
      isResizing = false;
      element.removeAttribute("data-resizing");
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
      resizeHandle.style.opacity = showHandleOnHover ? "0.5" : "0.7";
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", stopResizing);
    };
    resizeHandle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      isResizing = true;
      element.setAttribute("data-resizing", "true");
      startX = e.clientX;
      startY = e.clientY;
      startWidth = element.offsetWidth;
      startHeight = element.offsetHeight;
      document.body.style.cursor = "se-resize";
      document.body.style.userSelect = "none";
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", stopResizing);
    });
    return resizeHandle;
  }
  function makeResizable(element, handle) {
    if (handle) {
      return makeElementResizable(element, { showHandleOnHover: false });
    }
    return makeElementResizable(element);
  }
  function makeToggleButtonDraggable(toggleBtn, dependencies = {}) {
    const {
      isMGAEvent = () => true,
      debugLog: debugLog3 = () => {
      },
      saveToggleButtonPosition: savePositionFn = null,
      UnifiedState: UnifiedState3 = null,
      MGA_saveJSON: MGA_saveJSON2 = null
    } = dependencies;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let startLeft = 0;
    let startTop = 0;
    let clickStarted = false;
    let currentX = 0;
    let currentY = 0;
    toggleBtn.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      clickStarted = true;
      isDragging = false;
      startX = e.clientX;
      startY = e.clientY;
      currentX = startX;
      currentY = startY;
      const rect = toggleBtn.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      toggleBtn.style.willChange = "transform";
      toggleBtn.style.cursor = "grabbing";
    });
    document.addEventListener("pointermove", (e) => {
      if (!clickStarted) return;
      if (!isDragging) {
        if (!isMGAEvent(e)) {
          return;
        }
      }
      currentX = e.clientX;
      currentY = e.clientY;
      const deltaX = Math.abs(currentX - startX);
      const deltaY = Math.abs(currentY - startY);
      if (!isDragging && (deltaX > 3 || deltaY > 3)) {
        isDragging = true;
        toggleBtn.style.transition = "none";
        toggleBtn.style.boxShadow = "0 8px 32px rgba(74, 158, 255, 0.6)";
        toggleBtn.style.zIndex = "999999";
        toggleBtn.setPointerCapture(e.pointerId);
      }
      if (isDragging) {
        const moveX = currentX - startX;
        const moveY = currentY - startY;
        let newLeft = startLeft + moveX;
        let newTop = startTop + moveY;
        const padding = 10;
        newLeft = Math.max(padding, Math.min(window.innerWidth - toggleBtn.offsetWidth - padding, newLeft));
        newTop = Math.max(padding, Math.min(window.innerHeight - toggleBtn.offsetHeight - padding, newTop));
        toggleBtn.style.right = "";
        toggleBtn.style.bottom = "";
        toggleBtn.style.left = `${newLeft}px`;
        toggleBtn.style.top = `${newTop}px`;
      }
    });
    document.addEventListener("pointerup", (e) => {
      if (clickStarted) {
        if (!isDragging && !isMGAEvent(e)) {
          return;
        }
        if (isDragging) {
          toggleBtn.releasePointerCapture(e.pointerId);
          isDragging = false;
          toggleBtn.style.transition = "all 0.2s ease";
          toggleBtn.style.boxShadow = "0 4px 20px rgba(74, 158, 255, 0.4)";
          toggleBtn.style.zIndex = "999998";
          toggleBtn.style.cursor = "grab";
          toggleBtn.style.willChange = "auto";
          const finalPosition = {
            left: toggleBtn.style.left,
            top: toggleBtn.style.top,
            right: "",
            // Clear right positioning
            bottom: ""
            // Clear bottom positioning
          };
          if (savePositionFn) {
            savePositionFn(finalPosition);
          }
          debugLog3("OVERLAY_LIFECYCLE", "Toggle button dragged to new position", finalPosition);
        } else {
          toggleBtn.style.willChange = "auto";
          toggleBtn.style.cursor = "grab";
          if (UnifiedState3 && UnifiedState3.panels && UnifiedState3.panels.main) {
            const panel = UnifiedState3.panels.main;
            const isCurrentlyVisible = panel.style.display !== "none";
            const newVisibility = !isCurrentlyVisible;
            panel.style.display = newVisibility ? "block" : "none";
            if (window.MGA_Tooltips && window.MGA_Tooltips.hide) {
              window.MGA_Tooltips.hide();
            }
            if (UnifiedState3.data && UnifiedState3.data.settings && MGA_saveJSON2) {
              UnifiedState3.data.settings.panelVisible = newVisibility;
              MGA_saveJSON2("MGA_data", UnifiedState3.data);
            }
            debugLog3("OVERLAY_LIFECYCLE", `Panel toggled: ${newVisibility ? "visible" : "hidden"}`);
          }
        }
        clickStarted = false;
      }
    });
  }
  function saveToggleButtonPosition(position, dependencies = {}) {
    const { MGA_saveJSON: MGA_saveJSON2 = null, debugLog: debugLog3 = () => {
    }, debugError: debugError2 = () => {
    } } = dependencies;
    try {
      if (MGA_saveJSON2) {
        MGA_saveJSON2("MGA_toggleButtonPosition", position);
      }
      debugLog3("OVERLAY_LIFECYCLE", "Saved toggle button position", { position });
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to save toggle button position", error, { position });
    }
  }
  function loadToggleButtonPosition(toggleBtn, dependencies = {}) {
    const { MGA_loadJSON: MGA_loadJSON2 = null, debugLog: debugLog3 = () => {
    }, debugError: debugError2 = () => {
    } } = dependencies;
    try {
      if (!MGA_loadJSON2) return;
      const savedPosition = MGA_loadJSON2("MGA_toggleButtonPosition", null);
      if (savedPosition) {
        if (savedPosition.left && savedPosition.top) {
          const leftPx = parseInt(savedPosition.left);
          const topPx = parseInt(savedPosition.top);
          if (!isNaN(leftPx) && !isNaN(topPx) && leftPx >= 0 && topPx >= 0 && leftPx < window.innerWidth && topPx < window.innerHeight) {
            toggleBtn.style.right = "";
            toggleBtn.style.bottom = "";
            toggleBtn.style.left = savedPosition.left;
            toggleBtn.style.top = savedPosition.top;
            debugLog3("OVERLAY_LIFECYCLE", "Restored toggle button position", { position: savedPosition });
          }
        }
      }
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to load toggle button position", error);
    }
  }
  var draggable_default = {
    // Main HUD Dragging
    makeDraggable,
    saveMainHUDPosition,
    loadMainHUDPosition,
    // Resize System
    makeElementResizable,
    makeResizable,
    // Toggle Button
    makeToggleButtonDraggable,
    saveToggleButtonPosition,
    loadToggleButtonPosition
  };

  // src/ui/ui.js
  var ui_exports = {};
  __export(ui_exports, {
    el: () => el,
    emit: () => emit,
    ensureStyles: () => ensureStyles,
    off: () => off,
    on: () => on,
    qs: () => qs,
    qsa: () => qsa,
    toast: () => toast
  });
  var stylesInjected = false;
  function ensureStyles() {
    if (stylesInjected) return;
    const css = `
    /* MGTools Toast Container */
    .mgtools-toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 999999;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Individual Toast */
    .mgtools-toast {
      pointer-events: auto;
      min-width: 280px;
      max-width: 400px;
      padding: 16px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      animation: mgtools-toast-slide-in 0.3s ease-out;
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      position: relative;
    }

    .mgtools-toast.mgtools-toast-hiding {
      opacity: 0;
      transform: translateX(20px);
    }

    /* Toast Types */
    .mgtools-toast.mgtools-toast-info {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .mgtools-toast.mgtools-toast-warn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }

    .mgtools-toast.mgtools-toast-error {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: #333;
    }

    /* Toast Icon */
    .mgtools-toast-icon {
      flex-shrink: 0;
      width: 20px;
      height: 20px;
      font-size: 20px;
      line-height: 1;
    }

    /* Toast Content */
    .mgtools-toast-content {
      flex: 1;
      word-wrap: break-word;
    }

    /* Toast Close Button */
    .mgtools-toast-close {
      flex-shrink: 0;
      width: 20px;
      height: 20px;
      border: none;
      background: none;
      color: inherit;
      font-size: 20px;
      line-height: 1;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.2s;
      padding: 0;
    }

    .mgtools-toast-close:hover {
      opacity: 1;
    }

    /* Animations */
    @keyframes mgtools-toast-slide-in {
      from {
        opacity: 0;
        transform: translateX(100%);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Discord Compatibility: Higher z-index for iframe contexts */
    .mgtools-discord-context .mgtools-toast-container {
      z-index: 9999999;
    }
  `;
    try {
      const style = document.createElement("style");
      style.textContent = css;
      document.head.appendChild(style);
      stylesInjected = true;
      Logger.debug("UI", "Toast styles injected");
    } catch (error) {
      Logger.error("UI", "Failed to inject toast styles", error);
    }
  }
  var toastContainer = null;
  var toastQueue = [];
  var toastIdCounter = 0;
  function ensureToastContainer() {
    if (toastContainer && document.body.contains(toastContainer)) {
      return toastContainer;
    }
    ensureStyles();
    toastContainer = document.createElement("div");
    toastContainer.className = "mgtools-toast-container";
    if (CompatibilityMode?.flags?.isDiscordEmbed) {
      toastContainer.classList.add("mgtools-discord-context");
    }
    document.body.appendChild(toastContainer);
    Logger.debug("UI", "Toast container created");
    return toastContainer;
  }
  function createToast(message, options = {}) {
    const { type = "info", duration = 5e3, dismissible = true, icon = null } = options;
    const toastId = ++toastIdCounter;
    const container = ensureToastContainer();
    const toast2 = document.createElement("div");
    toast2.className = `mgtools-toast mgtools-toast-${type}`;
    toast2.dataset.toastId = toastId;
    const defaultIcons = {
      info: "\u2139\uFE0F",
      warn: "\u26A0\uFE0F",
      error: "\u274C"
    };
    const toastIcon = document.createElement("span");
    toastIcon.className = "mgtools-toast-icon";
    toastIcon.textContent = icon || defaultIcons[type] || "\u2139\uFE0F";
    const content = document.createElement("div");
    content.className = "mgtools-toast-content";
    content.textContent = message;
    const closeBtn = document.createElement("button");
    closeBtn.className = "mgtools-toast-close";
    closeBtn.textContent = "\xD7";
    closeBtn.setAttribute("aria-label", "Close");
    if (dismissible) {
      closeBtn.addEventListener("click", () => {
        dismissToast(toastId);
      });
    } else {
      closeBtn.style.display = "none";
    }
    toast2.appendChild(toastIcon);
    toast2.appendChild(content);
    toast2.appendChild(closeBtn);
    container.appendChild(toast2);
    toastQueue.push({ id: toastId, element: toast2, timeout: null });
    if (duration > 0) {
      const timeoutId = setTimeout(() => {
        dismissToast(toastId);
      }, duration);
      const toastData = toastQueue.find((t) => t.id === toastId);
      if (toastData) {
        toastData.timeout = timeoutId;
      }
    }
    Logger.debug("UI", `Toast created: ${type} - "${message}"`);
    emit("toast:created", { id: toastId, type, message });
    return toastId;
  }
  function dismissToast(toastId) {
    const toastData = toastQueue.find((t) => t.id === toastId);
    if (!toastData) return;
    if (toastData.timeout) {
      clearTimeout(toastData.timeout);
    }
    toastData.element.classList.add("mgtools-toast-hiding");
    setTimeout(() => {
      if (toastData.element.parentNode) {
        toastData.element.parentNode.removeChild(toastData.element);
      }
      const index = toastQueue.findIndex((t) => t.id === toastId);
      if (index !== -1) {
        toastQueue.splice(index, 1);
      }
      Logger.debug("UI", `Toast dismissed: ${toastId}`);
      emit("toast:dismissed", { id: toastId });
    }, 200);
  }
  function dismissAllToasts() {
    const toastIds = toastQueue.map((t) => t.id);
    toastIds.forEach((id) => dismissToast(id));
    Logger.debug("UI", "All toasts dismissed");
  }
  var toast = {
    /**
     * Show info toast
     * @param {string} message - Toast message
     * @param {Object} options - Toast options
     * @returns {number} - Toast ID
     */
    info(message, options = {}) {
      return createToast(message, { ...options, type: "info" });
    },
    /**
     * Show warning toast
     * @param {string} message - Toast message
     * @param {Object} options - Toast options
     * @returns {number} - Toast ID
     */
    warn(message, options = {}) {
      return createToast(message, { ...options, type: "warn" });
    },
    /**
     * Show error toast
     * @param {string} message - Toast message
     * @param {Object} options - Toast options
     * @returns {number} - Toast ID
     */
    error(message, options = {}) {
      return createToast(message, { ...options, type: "error" });
    },
    /**
     * Dismiss all toasts
     */
    dismissAll() {
      dismissAllToasts();
    },
    /**
     * Dismiss specific toast
     * @param {number} toastId - Toast ID to dismiss
     */
    dismiss(toastId) {
      dismissToast(toastId);
    }
  };
  var eventHandlers = /* @__PURE__ */ new Map();
  function on(event, handler) {
    if (!eventHandlers.has(event)) {
      eventHandlers.set(event, []);
    }
    eventHandlers.get(event).push(handler);
    Logger.debug("UI", `Event handler registered: ${event}`);
  }
  function off(event, handler) {
    if (!eventHandlers.has(event)) return;
    const handlers = eventHandlers.get(event);
    const index = handlers.indexOf(handler);
    if (index !== -1) {
      handlers.splice(index, 1);
      Logger.debug("UI", `Event handler removed: ${event}`);
    }
    if (handlers.length === 0) {
      eventHandlers.delete(event);
    }
  }
  function emit(event, payload) {
    if (!eventHandlers.has(event)) return;
    const handlers = eventHandlers.get(event);
    handlers.forEach((handler) => {
      try {
        handler(payload);
      } catch (error) {
        Logger.error("UI", `Error in event handler for "${event}"`, error);
      }
    });
    Logger.debug("UI", `Event emitted: ${event}`, payload);
  }
  function el(tag, attrs = {}, ...children) {
    const element = document.createElement(tag);
    for (const [key, value] of Object.entries(attrs)) {
      if (key === "className") {
        element.className = value;
      } else if (key === "style" && typeof value === "object") {
        Object.assign(element.style, value);
      } else if (key.startsWith("on") && typeof value === "function") {
        const eventName = key.substring(2).toLowerCase();
        element.addEventListener(eventName, value);
      } else {
        element.setAttribute(key, value);
      }
    }
    children.forEach((child) => {
      if (typeof child === "string") {
        element.appendChild(document.createTextNode(child));
      } else if (child instanceof Node) {
        element.appendChild(child);
      }
    });
    return element;
  }
  function qs(selector, root = document) {
    try {
      return root.querySelector(selector);
    } catch (error) {
      Logger.error("UI", `Invalid selector: "${selector}"`, error);
      return null;
    }
  }
  function qsa(selector, root = document) {
    try {
      return root.querySelectorAll(selector);
    } catch (error) {
      Logger.error("UI", `Invalid selector: "${selector}"`, error);
      return [];
    }
  }
  if (typeof document !== "undefined" && document.readyState !== "loading") {
    ensureStyles();
  } else if (typeof document !== "undefined") {
    document.addEventListener("DOMContentLoaded", ensureStyles);
  }
  Logger.info("UI", "UI framework module loaded");

  // src/ui/version-badge.js
  var version_badge_exports = {};
  __export(version_badge_exports, {
    renderBranchSwitcherModal: () => renderBranchSwitcherModal,
    renderVersionBadge: () => renderVersionBadge,
    showVersionOutdatedToast: () => showVersionOutdatedToast,
    teardownVersionUI: () => teardownVersionUI,
    wireVersionSwitchHandlers: () => wireVersionSwitchHandlers
  });
  function renderVersionBadge(container, meta = {}) {
    if (!container || !(container instanceof HTMLElement)) {
      Logger.error("VERSION_UI", "Invalid container provided to renderVersionBadge");
      return null;
    }
    const { currentVersion = "Unknown", availableVersion = null, branch = "Unknown", isOutdated = false } = meta;
    const existingBadge = qs(".mgtools-version-badge", container);
    if (existingBadge) {
      existingBadge.remove();
    }
    const badge = el("div", {
      className: "mgtools-version-badge",
      style: {
        display: "inline-flex",
        alignItems: "center",
        gap: "8px",
        padding: "6px 12px",
        borderRadius: "6px",
        fontSize: "13px",
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
        background: isOutdated ? "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)" : "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
        color: "white",
        boxShadow: "0 2px 8px rgba(0, 0, 0, 0.15)",
        cursor: isOutdated ? "pointer" : "default",
        transition: "transform 0.2s, box-shadow 0.2s"
      },
      "data-version": currentVersion,
      "data-branch": branch
    });
    if (isOutdated) {
      badge.addEventListener("mouseenter", () => {
        badge.style.transform = "translateY(-2px)";
        badge.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.25)";
      });
      badge.addEventListener("mouseleave", () => {
        badge.style.transform = "translateY(0)";
        badge.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.15)";
      });
    }
    const icon = el(
      "span",
      {
        style: { fontSize: "16px", lineHeight: "1" }
      },
      isOutdated ? "\u26A0\uFE0F" : "\u2713"
    );
    const versionText = el(
      "span",
      {
        style: { fontWeight: "500" }
      },
      `v${currentVersion}`
    );
    const branchBadge = el(
      "span",
      {
        style: {
          padding: "2px 6px",
          borderRadius: "4px",
          fontSize: "11px",
          fontWeight: "600",
          background: "rgba(255, 255, 255, 0.25)",
          textTransform: "uppercase",
          letterSpacing: "0.5px"
        }
      },
      branch
    );
    badge.appendChild(icon);
    badge.appendChild(versionText);
    badge.appendChild(branchBadge);
    if (isOutdated && availableVersion) {
      const updateIndicator = el(
        "span",
        {
          style: {
            padding: "2px 6px",
            borderRadius: "4px",
            fontSize: "11px",
            fontWeight: "600",
            background: "rgba(255, 255, 255, 0.4)",
            animation: "mgtools-pulse 2s infinite"
          }
        },
        `\u2192 v${availableVersion}`
      );
      badge.appendChild(updateIndicator);
    }
    container.appendChild(badge);
    Logger.debug(
      "VERSION_UI",
      `Version badge rendered: v${currentVersion} (${branch})${isOutdated ? " [OUTDATED]" : ""}`
    );
    return badge;
  }
  function wireVersionSwitchHandlers(container, callbacks = {}) {
    if (!container || !(container instanceof HTMLElement)) {
      Logger.error("VERSION_UI", "Invalid container provided to wireVersionSwitchHandlers");
      return () => {
      };
    }
    const { onSwitch } = callbacks;
    if (typeof onSwitch !== "function") {
      Logger.warn("VERSION_UI", "No onSwitch callback provided to wireVersionSwitchHandlers");
      return () => {
      };
    }
    const badge = qs(".mgtools-version-badge", container);
    if (!badge) {
      Logger.warn("VERSION_UI", "No version badge found in container");
      return () => {
      };
    }
    const currentBranch = badge.dataset.branch;
    const isOutdated = badge.style.background.includes("f093fb");
    if (!isOutdated) {
      Logger.debug("VERSION_UI", "Version is up-to-date, no switch handler needed");
      return () => {
      };
    }
    const handleClick = (event) => {
      event.preventDefault();
      event.stopPropagation();
      const targetBranch = currentBranch === "Stable" ? "Live Beta" : "Stable";
      Logger.info("VERSION_UI", `User clicked to switch from ${currentBranch} to ${targetBranch}`);
      onSwitch({
        from: currentBranch,
        to: targetBranch,
        currentVersion: badge.dataset.version
      });
    };
    badge.addEventListener("click", handleClick);
    badge.style.cursor = "pointer";
    badge.title = "Click to update to latest version";
    Logger.debug("VERSION_UI", "Branch switch handler wired");
    return () => {
      badge.removeEventListener("click", handleClick);
      badge.style.cursor = "default";
      badge.title = "";
      Logger.debug("VERSION_UI", "Branch switch handler removed");
    };
  }
  function showVersionOutdatedToast(meta = {}) {
    const {
      currentVersion = "Unknown",
      availableVersion = "Unknown",
      branch = "Unknown",
      targetBranch = "Unknown"
    } = meta;
    const message = `Update available! v${currentVersion} \u2192 v${availableVersion} (${targetBranch})`;
    const toastId = toast.warn(message, {
      duration: 1e4,
      // 10 seconds
      dismissible: true,
      icon: "\u{1F514}"
    });
    Logger.info("VERSION_UI", `Outdated version toast shown: ${message}`);
    return toastId;
  }
  function teardownVersionUI(container) {
    if (!container || !(container instanceof HTMLElement)) {
      Logger.warn("VERSION_UI", "Invalid container provided to teardownVersionUI");
      return;
    }
    const badge = qs(".mgtools-version-badge", container);
    if (badge) {
      const clone = badge.cloneNode(true);
      badge.parentNode.replaceChild(clone, badge);
      clone.remove();
      Logger.debug("VERSION_UI", "Version badge removed");
    }
    Logger.debug("VERSION_UI", "Version UI teardown complete");
  }
  function renderBranchSwitcherModal(options = {}) {
    const { currentBranch = "Unknown", targetBranch = "Unknown", onConfirm = () => {
    }, onCancel = () => {
    } } = options;
    const overlay = el("div", {
      className: "mgtools-modal-overlay",
      style: {
        position: "fixed",
        top: "0",
        left: "0",
        right: "0",
        bottom: "0",
        background: "rgba(0, 0, 0, 0.6)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: "9999999",
        animation: "mgtools-fade-in 0.2s ease-out"
      }
    });
    const modal = el("div", {
      className: "mgtools-modal",
      style: {
        background: "white",
        borderRadius: "12px",
        padding: "24px",
        maxWidth: "400px",
        boxShadow: "0 8px 32px rgba(0, 0, 0, 0.25)",
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
      }
    });
    const title = el(
      "h2",
      {
        style: {
          margin: "0 0 16px 0",
          fontSize: "20px",
          fontWeight: "600",
          color: "#333"
        }
      },
      "Switch Branch?"
    );
    const description = el(
      "p",
      {
        style: {
          margin: "0 0 24px 0",
          fontSize: "14px",
          lineHeight: "1.6",
          color: "#666"
        }
      },
      `You are currently on ${currentBranch}. Switch to ${targetBranch} to get the latest version?`
    );
    const buttonContainer = el("div", {
      style: {
        display: "flex",
        gap: "12px",
        justifyContent: "flex-end"
      }
    });
    const cancelBtn = el(
      "button",
      {
        style: {
          padding: "10px 20px",
          border: "1px solid #ddd",
          borderRadius: "6px",
          background: "white",
          color: "#666",
          fontSize: "14px",
          fontWeight: "500",
          cursor: "pointer",
          transition: "all 0.2s"
        }
      },
      "Cancel"
    );
    cancelBtn.addEventListener("click", () => {
      overlay.remove();
      onCancel();
    });
    const confirmBtn = el(
      "button",
      {
        style: {
          padding: "10px 20px",
          border: "none",
          borderRadius: "6px",
          background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
          color: "white",
          fontSize: "14px",
          fontWeight: "500",
          cursor: "pointer",
          transition: "all 0.2s",
          boxShadow: "0 2px 8px rgba(102, 126, 234, 0.3)"
        }
      },
      "Switch Branch"
    );
    confirmBtn.addEventListener("click", () => {
      overlay.remove();
      onConfirm({ from: currentBranch, to: targetBranch });
    });
    buttonContainer.appendChild(cancelBtn);
    buttonContainer.appendChild(confirmBtn);
    modal.appendChild(title);
    modal.appendChild(description);
    modal.appendChild(buttonContainer);
    overlay.appendChild(modal);
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
        onCancel();
      }
    });
    document.body.appendChild(overlay);
    Logger.debug("VERSION_UI", "Branch switcher modal rendered");
    return overlay;
  }
  ensureStyles();
  Logger.info("VERSION_UI", "Version badge UI module loaded");

  // src/ui/connection-status.js
  var connection_status_exports = {};
  __export(connection_status_exports, {
    CONNECTION_STATES: () => CONNECTION_STATES,
    attachConnectionHandlers: () => attachConnectionHandlers,
    renderConnectionStatus: () => renderConnectionStatus,
    showConnectionToast: () => showConnectionToast,
    teardownConnectionStatus: () => teardownConnectionStatus,
    updateConnectionStatus: () => updateConnectionStatus
  });
  var CONNECTION_STATES = {
    CONNECTED: "connected",
    RECONNECTING: "reconnecting",
    OFFLINE: "offline",
    EXPIRED4710: "expired4710"
    // Special state for expired sessions
  };
  var STATE_CONFIG = {
    [CONNECTION_STATES.CONNECTED]: {
      icon: "\u2713",
      text: "Connected",
      color: "#10b981",
      // Green
      gradient: "linear-gradient(135deg, #10b981 0%, #059669 100%)",
      pulse: false
    },
    [CONNECTION_STATES.RECONNECTING]: {
      icon: "\u27F3",
      text: "Reconnecting...",
      color: "#f59e0b",
      // Amber
      gradient: "linear-gradient(135deg, #f59e0b 0%, #d97706 100%)",
      pulse: true
    },
    [CONNECTION_STATES.OFFLINE]: {
      icon: "\u2715",
      text: "Offline",
      color: "#ef4444",
      // Red
      gradient: "linear-gradient(135deg, #ef4444 0%, #dc2626 100%)",
      pulse: false
    },
    [CONNECTION_STATES.EXPIRED4710]: {
      icon: "\u26A0",
      text: "Session Expired",
      color: "#8b5cf6",
      // Purple
      gradient: "linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%)",
      pulse: true
    }
  };
  function renderConnectionStatus(container, initialState = CONNECTION_STATES.CONNECTED) {
    if (!container || !(container instanceof HTMLElement)) {
      Logger.error("CONN_UI", "Invalid container provided to renderConnectionStatus");
      return null;
    }
    const state = CONNECTION_STATES[initialState.toUpperCase()] || CONNECTION_STATES.OFFLINE;
    const config2 = STATE_CONFIG[state];
    const existingHud = qs(".mgtools-connection-hud", container);
    if (existingHud) {
      existingHud.remove();
    }
    const hud = el("div", {
      className: "mgtools-connection-hud",
      style: {
        display: "inline-flex",
        alignItems: "center",
        gap: "8px",
        padding: "6px 12px",
        borderRadius: "6px",
        fontSize: "12px",
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
        background: config2.gradient,
        color: "white",
        boxShadow: "0 2px 8px rgba(0, 0, 0, 0.15)",
        transition: "all 0.3s ease",
        fontWeight: "500"
      },
      "data-state": state
    });
    if (config2.pulse) {
      hud.style.animation = "mgtools-pulse 2s infinite";
    }
    const icon = el(
      "span",
      {
        className: "mgtools-connection-icon",
        style: {
          fontSize: "14px",
          lineHeight: "1",
          display: "inline-block"
        }
      },
      config2.icon
    );
    if (state === CONNECTION_STATES.RECONNECTING) {
      icon.style.animation = "mgtools-spin 1s linear infinite";
    }
    const statusText = el(
      "span",
      {
        className: "mgtools-connection-text",
        style: { letterSpacing: "0.3px" }
      },
      config2.text
    );
    hud.appendChild(icon);
    hud.appendChild(statusText);
    container.appendChild(hud);
    Logger.debug("CONN_UI", `Connection HUD rendered: ${state}`);
    injectConnectionAnimations();
    return hud;
  }
  function updateConnectionStatus(container, newState) {
    if (!container || !(container instanceof HTMLElement)) {
      Logger.error("CONN_UI", "Invalid container provided to updateConnectionStatus");
      return false;
    }
    const hud = qs(".mgtools-connection-hud", container);
    if (!hud) {
      Logger.warn("CONN_UI", "No connection HUD found, rendering new one");
      renderConnectionStatus(container, newState);
      return true;
    }
    const state = CONNECTION_STATES[newState.toUpperCase()] || CONNECTION_STATES.OFFLINE;
    const config2 = STATE_CONFIG[state];
    const oldState = hud.dataset.state;
    hud.dataset.state = state;
    hud.style.background = config2.gradient;
    const icon = qs(".mgtools-connection-icon", hud);
    if (icon) {
      icon.textContent = config2.icon;
      if (state === CONNECTION_STATES.RECONNECTING) {
        icon.style.animation = "mgtools-spin 1s linear infinite";
      } else {
        icon.style.animation = "";
      }
    }
    const text = qs(".mgtools-connection-text", hud);
    if (text) {
      text.textContent = config2.text;
    }
    if (config2.pulse) {
      hud.style.animation = "mgtools-pulse 2s infinite";
    } else {
      hud.style.animation = "";
    }
    Logger.info("CONN_UI", `Connection status updated: ${oldState} \u2192 ${state}`);
    return true;
  }
  function attachConnectionHandlers(container, callbacks = {}) {
    if (!container || !(container instanceof HTMLElement)) {
      Logger.error("CONN_UI", "Invalid container provided to attachConnectionHandlers");
      return () => {
      };
    }
    const { onReconnect, onRefresh } = callbacks;
    const hud = qs(".mgtools-connection-hud", container);
    if (!hud) {
      Logger.warn("CONN_UI", "No connection HUD found to attach handlers");
      return () => {
      };
    }
    const buttonsContainer = el("div", {
      className: "mgtools-connection-buttons",
      style: {
        display: "inline-flex",
        gap: "4px",
        marginLeft: "4px"
      }
    });
    if (typeof onReconnect === "function") {
      const reconnectBtn = el(
        "button",
        {
          className: "mgtools-connection-btn mgtools-reconnect-btn",
          title: "Reconnect",
          style: {
            padding: "4px 8px",
            border: "none",
            borderRadius: "4px",
            background: "rgba(255, 255, 255, 0.2)",
            color: "white",
            fontSize: "11px",
            fontWeight: "600",
            cursor: "pointer",
            transition: "background 0.2s",
            textTransform: "uppercase",
            letterSpacing: "0.5px"
          }
        },
        "\u21BB"
      );
      reconnectBtn.addEventListener("mouseenter", () => {
        reconnectBtn.style.background = "rgba(255, 255, 255, 0.3)";
      });
      reconnectBtn.addEventListener("mouseleave", () => {
        reconnectBtn.style.background = "rgba(255, 255, 255, 0.2)";
      });
      reconnectBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        Logger.info("CONN_UI", "User clicked reconnect button");
        onReconnect({ timestamp: Date.now() });
      });
      buttonsContainer.appendChild(reconnectBtn);
    }
    if (typeof onRefresh === "function") {
      const refreshBtn = el(
        "button",
        {
          className: "mgtools-connection-btn mgtools-refresh-btn",
          title: "Refresh Page",
          style: {
            padding: "4px 8px",
            border: "none",
            borderRadius: "4px",
            background: "rgba(255, 255, 255, 0.2)",
            color: "white",
            fontSize: "11px",
            fontWeight: "600",
            cursor: "pointer",
            transition: "background 0.2s",
            textTransform: "uppercase",
            letterSpacing: "0.5px"
          }
        },
        "\u27F3"
      );
      refreshBtn.addEventListener("mouseenter", () => {
        refreshBtn.style.background = "rgba(255, 255, 255, 0.3)";
      });
      refreshBtn.addEventListener("mouseleave", () => {
        refreshBtn.style.background = "rgba(255, 255, 255, 0.2)";
      });
      refreshBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        Logger.info("CONN_UI", "User clicked refresh button");
        onRefresh({ timestamp: Date.now() });
      });
      buttonsContainer.appendChild(refreshBtn);
    }
    if (buttonsContainer.children.length > 0) {
      hud.appendChild(buttonsContainer);
    }
    Logger.debug("CONN_UI", "Connection handlers attached");
    return () => {
      const buttons = qs(".mgtools-connection-buttons", hud);
      if (buttons) {
        buttons.remove();
      }
      Logger.debug("CONN_UI", "Connection handlers removed");
    };
  }
  function showConnectionToast(state, options = {}) {
    const validState = CONNECTION_STATES[state.toUpperCase()] || CONNECTION_STATES.OFFLINE;
    const config2 = STATE_CONFIG[validState];
    let message = "";
    let toastType = "info";
    let duration = 5e3;
    switch (validState) {
      case CONNECTION_STATES.CONNECTED:
        message = "Connection established";
        toastType = "info";
        duration = 3e3;
        break;
      case CONNECTION_STATES.RECONNECTING:
        message = "Connection lost, attempting to reconnect...";
        toastType = "warn";
        duration = 0;
        break;
      case CONNECTION_STATES.OFFLINE:
        message = "Connection offline. Check your network.";
        toastType = "error";
        duration = 0;
        break;
      case CONNECTION_STATES.EXPIRED4710:
        message = "Session expired. Please refresh the page.";
        toastType = "error";
        duration = 0;
        break;
    }
    if (options.message) {
      message = options.message;
    }
    const toastId = toast[toastType](message, {
      duration,
      dismissible: true,
      icon: config2.icon
    });
    Logger.info("CONN_UI", `Connection toast shown: ${validState} - "${message}"`);
    return toastId;
  }
  function teardownConnectionStatus(container) {
    if (!container || !(container instanceof HTMLElement)) {
      Logger.warn("CONN_UI", "Invalid container provided to teardownConnectionStatus");
      return;
    }
    const hud = qs(".mgtools-connection-hud", container);
    if (hud) {
      const clone = hud.cloneNode(true);
      hud.parentNode.replaceChild(clone, hud);
      clone.remove();
      Logger.debug("CONN_UI", "Connection HUD removed");
    }
    Logger.debug("CONN_UI", "Connection UI teardown complete");
  }
  var animationsInjected = false;
  function injectConnectionAnimations() {
    if (animationsInjected) return;
    const css = `
    @keyframes mgtools-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes mgtools-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
  `;
    try {
      const style = document.createElement("style");
      style.textContent = css;
      document.head.appendChild(style);
      animationsInjected = true;
      Logger.debug("CONN_UI", "Connection animations injected");
    } catch (error) {
      Logger.error("CONN_UI", "Failed to inject connection animations", error);
    }
  }
  ensureStyles();
  Logger.info("CONN_UI", "Connection status UI module loaded");

  // src/ui/overlay.js
  var overlay_exports = {};
  __export(overlay_exports, {
    DYNAMIC_TABS: () => DYNAMIC_TABS,
    TAB_CACHE_DURATION: () => TAB_CACHE_DURATION,
    UNIFIED_STYLES: () => UNIFIED_STYLES,
    addResizeHandleToOverlay: () => addResizeHandleToOverlay,
    cleanupCorruptedDockPosition: () => cleanupCorruptedDockPosition,
    closeAllPopouts: () => closeAllPopouts,
    closeInGameOverlay: () => closeInGameOverlay,
    createInGameOverlay: () => createInGameOverlay,
    createUnifiedUI: () => createUnifiedUI,
    ensureUIHealthy: () => ensureUIHealthy,
    findOptimalPosition: () => findOptimalPosition,
    findPositionInZone: () => findPositionInZone,
    getCachedTabContent: () => getCachedTabContent,
    getContentForTab: () => getContentForTab,
    getGameViewport: () => getGameViewport,
    getPetsPopoutContent: () => getPetsPopoutContent,
    getTabCacheStats: () => getTabCacheStats,
    hasCollisionAtPosition: () => hasCollisionAtPosition,
    invalidateTabCache: () => invalidateTabCache,
    loadOverlayDimensions: () => loadOverlayDimensions,
    loadOverlayPosition: () => loadOverlayPosition,
    makeEntireOverlayDraggable: () => makeEntireOverlayDraggable,
    makePopoutDraggable: () => makePopoutDraggable,
    openPopoutWidget: () => openPopoutWidget,
    openSidebarTab: () => openSidebarTab,
    openTabInPopout: () => openTabInPopout,
    openTabInSeparateWindow: () => openTabInSeparateWindow,
    overlapsMainHUD: () => overlapsMainHUD,
    refreshOverlayContent: () => refreshOverlayContent,
    refreshSeparateWindowPopouts: () => refreshSeparateWindowPopouts,
    resetDockPosition: () => resetDockPosition,
    saveDockPosition: () => saveDockPosition,
    saveOverlayDimensions: () => saveOverlayDimensions,
    saveOverlayPosition: () => saveOverlayPosition,
    setupDockSizeControl: () => setupDockSizeControl,
    setupOverlayHandlers: () => setupOverlayHandlers,
    setupPetPopoutHandlers: () => setupPetPopoutHandlers,
    setupPureOverlayHandlers: () => setupPureOverlayHandlers,
    setupToolbarToggle: () => setupToolbarToggle,
    toggleTabPopout: () => toggleTabPopout,
    updateOverlayContent: () => updateOverlayContent,
    updatePopoutButtonState: () => updatePopoutButtonState,
    updatePopoutButtonStateByTab: () => updatePopoutButtonStateByTab,
    updatePureOverlayContent: () => updatePureOverlayContent
  });
  var googleFontsImport = "";
  var UNIFIED_STYLES = `
      ${googleFontsImport}

      /* ==================== HYBRID DOCK STYLES ==================== */
      #mgh-dock {
          font-family: 'Inter', sans-serif;
          position: fixed;
          display: flex;
          gap: 6px;
          background: rgba(10, 10, 10, 0.9);
          backdrop-filter: blur(20px);
          border: 1px solid rgba(255, 255, 255, 0.15);
          padding: 8px 12px;
          z-index: 999999;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
          /* No transition for instant drag response */
      }

      #mgh-dock.horizontal {
          bottom: 16px;
          left: 50%;
          transform: translateX(-50%);
          flex-direction: row;
          border-radius: 16px;
      }

      #mgh-dock.vertical {
          left: 16px;
          top: 20px;
          transform: none;
          flex-direction: column;
          border-radius: 16px;
          max-height: calc(100vh - 40px);
          overflow-y: auto;
          overflow-x: hidden;
      }

      /* Custom scrollbar for vertical dock */
      #mgh-dock.vertical::-webkit-scrollbar {
          width: 4px;
      }

      #mgh-dock.vertical::-webkit-scrollbar-track {
          background: transparent;
      }

      #mgh-dock.vertical::-webkit-scrollbar-thumb {
          background: rgba(255, 255, 255, 0.2);
          border-radius: 2px;
      }

      #mgh-dock.vertical::-webkit-scrollbar-thumb:hover {
          background: rgba(255, 255, 255, 0.3);
      }

      /* Scroll indicators - gradient shadows at top/bottom when scrollable */
      #mgh-dock.vertical::before,
      #mgh-dock.vertical::after {
          content: '';
          position: sticky;
          display: block;
          left: 0;
          right: 0;
          height: 20px;
          pointer-events: none;
          z-index: 10;
      }

      #mgh-dock.vertical::before {
          top: 0;
          background: linear-gradient(to bottom, rgba(31, 41, 55, 0.9), transparent);
          margin-bottom: -20px;
      }

      #mgh-dock.vertical::after {
          bottom: 0;
          background: linear-gradient(to top, rgba(31, 41, 55, 0.9), transparent);
          margin-top: -20px;
      }

      .mgh-dock-item {
          width: 44px;
          height: 44px;
          background: rgba(255, 255, 255, 0.05);
          border: 1px solid rgba(255, 255, 255, 0.57);
          border-radius: 10px;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 18px;
          cursor: pointer;
          transition: all 0.3s ease;
          position: relative;
      }

      .mgh-dock-item:hover {
          background: rgba(255, 255, 255, 0.15);
          transform: scale(1.1);
      }

      .mgh-dock-item.active {
          background: rgba(102, 126, 234, 0.3);
          border-color: #667eea;
      }

      .mgh-dock-item.flip-toggle {
          background: rgba(255, 255, 255, 0.08);
          font-size: 14px;
      }

      .mgh-dock-item.flip-toggle:hover {
          background: rgba(255, 255, 255, 0.12);
      }

      /* Optimized sizes for vertical mode */
      #mgh-dock.vertical .mgh-dock-item {
          width: 40px;
          height: 40px;
      }

      #mgh-dock.vertical .mgh-dock-item img {
          /* FIX: Match scriptwithicons sizing exactly */
          width: 24px;
          height: 24px;
      }

      #mgh-dock.vertical .mgh-dock-item {
          font-size: 20px;
      }

      /* ==================== DOCK SIZE VARIANTS ==================== */
      /* Micro size (0.50x scale - smallest) */
      #mgh-dock.dock-size-micro.horizontal .mgh-dock-item {
          width: 22px;
          height: 22px;
          font-size: 10px;
      }

      #mgh-dock.dock-size-micro.vertical .mgh-dock-item {
          width: 20px;
          height: 20px;
          font-size: 11px;
      }

      #mgh-dock.dock-size-micro .mgh-dock-item img {
          width: 12px;
          height: 12px;
      }

      /* Mini size (0.61x scale) */
      #mgh-dock.dock-size-mini.horizontal .mgh-dock-item {
          width: 27px;
          height: 27px;
          font-size: 12px;
      }

      #mgh-dock.dock-size-mini.vertical .mgh-dock-item {
          width: 25px;
          height: 25px;
          font-size: 13px;
      }

      #mgh-dock.dock-size-mini .mgh-dock-item img {
          width: 15px;
          height: 15px;
      }

      /* Tiny size (0.73x scale) */
      #mgh-dock.dock-size-tiny.horizontal .mgh-dock-item {
          width: 32px;
          height: 32px;
          font-size: 14px;
      }

      #mgh-dock.dock-size-tiny.vertical .mgh-dock-item {
          width: 30px;
          height: 30px;
          font-size: 15px;
      }

      #mgh-dock.dock-size-tiny .mgh-dock-item img {
          width: 18px;
          height: 18px;
      }

      /* Small size (0.86x scale) */
      #mgh-dock.dock-size-small.horizontal .mgh-dock-item {
          width: 38px;
          height: 38px;
          font-size: 16px;
      }

      #mgh-dock.dock-size-small.vertical .mgh-dock-item {
          width: 36px;
          height: 36px;
          font-size: 17px;
      }

      #mgh-dock.dock-size-small .mgh-dock-item img {
          width: 21px;
          height: 21px;
      }

      /* Medium size (1.0x scale - default, already defined above) */
      /* No additional CSS needed - uses base .mgh-dock-item styles */

      /* Large size (1.18x scale) */
      #mgh-dock.dock-size-large.horizontal .mgh-dock-item {
          width: 52px;
          height: 52px;
          font-size: 22px;
      }

      #mgh-dock.dock-size-large.vertical .mgh-dock-item {
          width: 48px;
          height: 48px;
          font-size: 24px;
      }

      #mgh-dock.dock-size-large .mgh-dock-item img {
          width: 28px;
          height: 28px;
      }

      .mgh-tooltip {
          position: absolute;
          background: rgba(10, 10, 10, 0.95);
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 11px;
          color: white;
          white-space: nowrap;
          opacity: 0;
          pointer-events: none;
          transition: opacity 0.2s;
          border: 1px solid rgba(255, 255, 255, 0.57);
          z-index: 10;
      }

      #mgh-dock.horizontal .mgh-tooltip {
          bottom: 56px;
          left: 50%;
          transform: translateX(-50%);
      }

      #mgh-dock.vertical .mgh-tooltip {
          left: 56px;
          top: 50%;
          transform: translateY(-50%);
      }

      .mgh-dock-item:hover .mgh-tooltip { opacity: 1; }

      .mgh-tail-group {
          display: flex;
          gap: 6px;
          transition: opacity 0.3s ease;
      }

      #mgh-dock.horizontal .mgh-tail-group {
          flex-direction: row;
      }

      #mgh-dock.vertical .mgh-tail-group {
          flex-direction: column;
      }

      /* ==================== SIDEBAR STYLES ==================== */
      #mgh-sidebar {
          font-family: 'Inter', sans-serif;
          position: fixed;
          left: -420px;
          top: 0;
          width: 400px;
          height: 100vh;
          background: rgba(10, 10, 10, 0.95);
          backdrop-filter: blur(20px);
          border-right: 1px solid rgba(255, 255, 255, 0.15);
          z-index: 999998;
          transition: left 0.3s ease;
          display: flex;
          flex-direction: column;
          box-shadow: 4px 0 24px rgba(0, 0, 0, 0.6);
      }

      #mgh-sidebar.open { left: 0; }

      /* ==================== SHOP SIDEBAR STYLES ==================== */
      .mga-shop-sidebar {
          font-family: 'Inter', sans-serif;
          position: fixed;
          top: 0;
          width: 380px;
          height: 100vh;
          background: rgba(10, 10, 10, 0.95);
          backdrop-filter: blur(20px);
          border: 1px solid rgba(255, 255, 255, 0.15);
          z-index: 999998;
          transition: left 0.3s ease, right 0.3s ease;
          display: flex;
          flex-direction: column;
          box-shadow: 0 0 24px rgba(0, 0, 0, 0.6);
      }

      .mga-shop-sidebar-left {
          left: -400px;
          border-right: 1px solid rgba(255, 255, 255, 0.15);
      }

      .mga-shop-sidebar-left.open {
          left: 0;
      }

      .mga-shop-sidebar-right {
          right: -400px;
          border-left: 1px solid rgba(255, 255, 255, 0.15);
      }

      .mga-shop-sidebar-right.open {
          right: 0;
      }

      .mga-shop-sidebar-header {
          padding: 20px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.57);
          display: flex;
          justify-content: space-between;
          align-items: center;
          background: rgba(20, 20, 20, 0.5);
      }

      .mgh-sidebar-header {
          padding: 20px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.57);
          display: flex;
          justify-content: space-between;
          align-items: center;
      }

      .mgh-sidebar-title {
          font-size: 16px;
          font-weight: 600;
          color: white;
      }

      .mgh-sidebar-close {
          width: 32px;
          height: 32px;
          background: transparent;
          border: 1px solid rgba(255, 255, 255, 0.73);
          border-radius: 8px;
          color: rgba(255, 255, 255, 0.7);
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 18px;
          transition: all 0.2s;
      }

      .mgh-sidebar-close:hover {
          background: rgba(255, 255, 255, 0.57);
          color: white;
      }

      .mgh-sidebar-body {
          flex: 1;
          padding: 20px;
          overflow-y: auto;
          color: white;
      }

      .mgh-sidebar-body::-webkit-scrollbar { width: 6px; }
      .mgh-sidebar-body::-webkit-scrollbar-thumb {
          background: rgba(255, 255, 255, 0.73);
          border-radius: 3px;
      }

      /* ==================== PRESERVE ORIGINAL MGA STYLES ==================== */
      .mga-btn {
          background: rgba(255, 255, 255, 0.57);
          border: 1px solid rgba(255, 255, 255, 0.73);
          color: #ffffff;
          padding: 6px 12px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 13px;
          transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
          outline: none !important;
      }

      .mga-btn:hover {
          background: rgba(255, 255, 255, 0.2);
          border-color: rgba(74, 158, 255, 0.6);
          box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
      }

      .mga-input, .mga-select {
          background: rgba(255, 255, 255, 0.05);
          border: 1px solid rgba(255, 255, 255, 0.2);
          color: #ffffff;
          padding: 6px 12px;
          border-radius: 6px;
          font-size: 13px;
          font-family: inherit;
      }

      .mga-input:focus, .mga-select:focus {
          outline: none;
          border-color: rgba(102, 126, 234, 0.5);
          background: rgba(255, 255, 255, 0.08);
      }

      .mga-select option {
          background: rgba(20, 20, 20, 0.95);
          color: #ffffff;
          padding: 8px;
      }

      .mga-select option:hover {
          background: rgba(74, 158, 255, 0.3);
      }

      .mga-select optgroup {
          background: rgba(0, 0, 0, 0.5);
          color: #4a9eff;
          font-weight: bold;
          font-size: 11px;
          padding: 6px;
          border-top: 1px solid rgba(255, 255, 255, 0.57);
      }

      /* Shop item name colors */
      .shop-color-white { color: #ffffff !important; }
      .shop-color-green { color: #2afd23ff !important; }
      .shop-color-blue { color: #0084ffff !important; }
      .shop-color-yellow { color: #fced19ff !important; }
      .shop-color-purple { color: #774cb3 !important; }
      .shop-color-orange { color: #ff7300ff !important; }

      /* Rainbow text for celestial items */
      .shop-rainbow-text {
          background: linear-gradient(90deg,
              #ff0000, #ff7b00, #ffd800, #3cff2a, #00b5ff, #774cb3, #ff2ab7, #ff0000);
          background-size: 200% 100%;
          background-repeat: repeat;
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent !important;
          animation: shopRainbowShift 3s linear infinite;
          font-weight: 700;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
      }

      @keyframes shopRainbowShift {
          0%   { background-position: 0% 50%; }
          100% { background-position: 200% 50%; }
      }

      /* ========== TEXTURE ANIMATIONS ========== */
      @keyframes textureSlowDrift {
          0%   { background-position: 0px 0px, 0 0; }
          100% { background-position: 200px 200px, 0 0; }
      }

      @keyframes hologramScan {
          0%   { background-position: 0 0, 0 0; }
          100% { background-position: 0 100%, 0 0; }
      }

      @keyframes energyPulse {
          0%   { background-position: 0% 0%, 0% 0%, 0% 0%, 0 0; }
          50%  { background-position: 100% 0%, 100% 100%, 0% 100%, 0 0; }
          100% { background-position: 0% 0%, 0% 0%, 0% 0%, 0 0; }
      }

      .mga-texture-animated {
          animation: textureSlowDrift 60s linear infinite;
      }

      /* Shop sprite sizing */
      .shop-sprite {
          width: 28px;
          height: 28px;
          border-radius: 6px;
          object-fit: contain;
          flex-shrink: 0;
          background: rgba(255, 255, 255, 0.02);
          transition: transform 0.12s ease, box-shadow 0.12s ease;
      }

      .shop-item.in-stock .shop-sprite {
          transform: scale(1.04);
          box-shadow: 0 4px 10px rgba(0, 255, 42, 0.07);
      }

      /* Original overlay styles preserved */
      .mga-overlay {
          position: fixed;
          background: rgba(17, 24, 39, 0.95);
          border: 1px solid rgba(255, 255, 255, 0.57);
          border-radius: 12px;
          padding: 20px;
          color: #ffffff;
          z-index: 10001;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      /* Popout widget styles */
      .mgh-popout {
          font-family: 'Inter', sans-serif;
          position: fixed;
          background: rgba(10, 10, 10, 0.95);
          backdrop-filter: blur(20px);
          border: 1px solid rgba(255, 255, 255, 0.15);
          border-radius: 12px;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
          z-index: 1000000;
          min-width: 320px;
          width: 400px; /* Default width, resizable */
          height: 400px; /* Default height, resizable */
          display: flex;
          flex-direction: column;
          /* No transition for instant drag response */
      }

      .mgh-popout-header {
          padding: 12px 16px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.57);
          display: flex;
          align-items: center;
          justify-content: space-between;
          cursor: grab;
          user-select: none;
          background: rgba(20, 20, 20, 0.5);
          flex-shrink: 0;
      }

      .mgh-popout-header:active {
          cursor: grabbing;
      }

      .mgh-popout-body {
          padding: 16px;
          color: white;
          flex: 1;
          min-height: 0;
          overflow-y: auto;
      }

      /* ==================== PET MANAGEMENT STYLES ==================== */
      .mga-section {
          margin-bottom: 20px;
      }

      .mga-section-title {
          font-size: 14px;
          font-weight: 600;
          color: rgba(255, 255, 255, 0.9);
          margin-bottom: 12px;
          padding-bottom: 8px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.57);
      }

      .mga-pet-section-title {
          background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          background-clip: text;
      }

      /* Active Pets Display */
      .mga-active-pets-display {
          background: rgba(255, 255, 255, 0.03);
          border: 1px solid rgba(255, 255, 255, 0.57);
          border-radius: 8px;
          padding: 12px;
          margin-bottom: 12px;
      }

      .mga-active-pets-header {
          color: #93c5fd;
          font-size: 12px;
          margin-bottom: 8px;
          font-weight: 500;
      }

      .mga-active-pets-list {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
      }

      .mga-pet-slot {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 4px;
      }

      .mga-pet-badge {
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          padding: 6px 12px;
          border-radius: 6px;
          font-size: 12px;
          font-weight: 600;
          white-space: nowrap;
          box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
          transition: all 0.2s ease;
      }

      .mga-pet-badge:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }

      .mga-hunger-timer {
          font-size: 11px;
          font-weight: 600;
          padding: 2px 6px;
          border-radius: 4px;
          background: rgba(0, 0, 0, 0.48);
      }

      /* Pet Presets */
      .mga-presets-container {
          display: flex;
          flex-direction: column;
          gap: 8px;
      }

      .mga-preset {
          background: rgba(255, 255, 255, 0.05);
          border: 1px solid rgba(255, 255, 255, 0.57);
          border-radius: 8px;
          padding: 12px;
          transition: all 0.2s ease;
      }

      .mga-preset-clickable {
          cursor: pointer;
      }

      .mga-preset-clickable:hover {
          background: rgba(255, 255, 255, 0.55);
          border-color: #667eea;
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(102, 126, 234, 0.48);
      }

      .mga-preset-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
      }

      .mga-preset-name {
          font-size: 13px;
          font-weight: 600;
          color: #93c5fd;
      }

      .mga-preset-pets {
          font-size: 12px;
          color: rgba(255, 255, 255, 0.7);
          line-height: 1.5;
      }

      /* Empty State */
      .mga-empty-state {
          text-align: center;
          padding: 24px;
          color: rgba(255, 255, 255, 0.5);
      }

      .mga-empty-state-icon {
          font-size: 32px;
          margin-bottom: 8px;
          opacity: 0.5;
      }

      .mga-empty-state-title {
          font-size: 14px;
          font-weight: 600;
          color: rgba(255, 255, 255, 0.7);
          margin-bottom: 6px;
      }

      .mga-empty-state-description {
          font-size: 12px;
          color: rgba(255, 255, 255, 0.5);
          line-height: 1.5;
      }

      /* Scrollable containers */
      .mga-scrollable {
          overflow-y: auto;
      }

      .mga-scrollable::-webkit-scrollbar {
          width: 6px;
      }

      .mga-scrollable::-webkit-scrollbar-track {
          background: rgba(255, 255, 255, 0.05);
          border-radius: 3px;
      }

      .mga-scrollable::-webkit-scrollbar-thumb {
          background: rgba(255, 255, 255, 0.73);
          border-radius: 3px;
      }

      .mga-scrollable::-webkit-scrollbar-thumb:hover {
          background: rgba(255, 255, 255, 0.3);
      }
  `;
  function createUnifiedUI({
    targetDocument: targetDocument2,
    productionLog: productionLog3,
    makeDockDraggable,
    openSidebarTab: openSidebarTab2,
    toggleShopWindows: toggleShopWindows2,
    openPopoutWidget: openPopoutWidget2,
    checkVersion: checkVersion2,
    saveDockOrientation,
    loadDockOrientation,
    loadDockPosition,
    generateThemeStyles: generateThemeStyles2,
    applyAccentToDock: applyAccentToDock2,
    applyAccentToSidebar: applyAccentToSidebar2,
    applyThemeToDock: applyThemeToDock2,
    applyThemeToSidebar: applyThemeToSidebar2,
    isDiscordEnv,
    UNIFIED_STYLES: UNIFIED_STYLES2,
    CURRENT_VERSION: CURRENT_VERSION2,
    IS_LIVE_BETA: IS_LIVE_BETA2,
    UnifiedState: UnifiedState3
  }) {
    if (targetDocument2.getElementById("mgh-dock") || targetDocument2.getElementById("mgh-sidebar")) {
      productionLog3("\u{1F3A8} UI already exists, skipping creation");
      return;
    }
    if (!targetDocument2.body) {
      console.error("[MGTools] \u26A0\uFE0F Body not ready, retrying UI creation in 100ms...");
      setTimeout(
        () => createUnifiedUI({
          targetDocument: targetDocument2,
          productionLog: productionLog3,
          makeDockDraggable,
          openSidebarTab: openSidebarTab2,
          toggleShopWindows: toggleShopWindows2,
          openPopoutWidget: openPopoutWidget2,
          checkVersion: checkVersion2,
          saveDockOrientation,
          loadDockOrientation,
          loadDockPosition,
          generateThemeStyles: generateThemeStyles2,
          applyAccentToDock: applyAccentToDock2,
          applyAccentToSidebar: applyAccentToSidebar2,
          applyThemeToDock: applyThemeToDock2,
          applyThemeToSidebar: applyThemeToSidebar2,
          isDiscordEnv,
          UNIFIED_STYLES: UNIFIED_STYLES2,
          CURRENT_VERSION: CURRENT_VERSION2,
          IS_LIVE_BETA: IS_LIVE_BETA2,
          UnifiedState: UnifiedState3
        }),
        100
      );
      return;
    }
    productionLog3("\u{1F3A8} Creating Hybrid Dock UI...");
    const styleSheet = targetDocument2.createElement("style");
    styleSheet.textContent = UNIFIED_STYLES2;
    targetDocument2.head.appendChild(styleSheet);
    const dock = targetDocument2.createElement("div");
    dock.id = "mgh-dock";
    dock.className = "horizontal";
    const primaryTabs = ["pets", "abilities", "seeds", "values", "timers", "rooms", "shop"];
    const tailTabs = ["tools", "settings", "hotkeys", "protect", "notifications", "help"];
    const icons = {
      pets: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAADkCAMAAADaZIrAAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAACXBIWXMAAC4jAAAuIwF4pT92AAAC/VBMVEVHcEz5nVv5jGPnqWjcqnb3nlf6tGXC1apD6bJE6878nV33Z+H6t1P9jIDuzW+9mdig4V261+D+hFvsnKHx0VO0PL7ygrJD7pFs7HyP8syy5kGkNaS0y1quMbLlski6TOHR6Gdc6UfSapulr+/iSvxJQy/+4X//yIH+1Hn+24D86XD+8H20NMr923j943f8+3j+z4H6+mn+1oH86mf88G7+6H/+zHr96nj+xXn98XbV+2f/uH7G+2fj+2jv+2fy/XbjUvwtad/9zHP/wID91m40SS8reN0s35Bk+rIsht7kW/1Q97Vk+sVm+6dQ+KZl+rvo/Xb88WVp+423+2Zj+tCq/GtP98QtV+As34JOtfYskt9jeO9qY+/8wFaB+Pwt4J2e+2RR1vemRu1i+tyxRe1P9fT/3cos33Jx+2d+5vxS+JAs315P99T84Gn9tVZPxvZ6M+Fi+cor3raP+2Yw3jMs36na/Xb/fllBm+os38+7SOpl+3OA+2VO5vZ+1fz74VR17bRRjPjL/XVO9uT/rYCaSe0u394tRt8snt9S+Xgt30hh+un711Rg9/hvM+FBqupi+oNK4DAyNOHt2nj9qVf+jllqovNu/H5Rofgs3sP5zFFmjfEsqd9wtfaB/fLKXP1RcviA3SssyN9rSfHdS/jWVfx1xvhg+mX/18ksvd+HM+E/uellMuAstN9l3StUV/i/Yf1GMOHWyqqZ3SqHXe1ASS8t0+Cw3ixZ+FNAjeruTfxXMeCMRe7G3izWYv25/HWP/+D/4sr9m1hbSO/t03hBy+px+FL+zFeZ/HKDtv6I+VH861V6Re+q+VE/futf5flt+5t+dv1D6Zl27J/Z3SyB/ub0W/oveeKD/HHfzi1L8WBBbOyW8ElD4eeL/9KWNOFKRvD5+VSwZPx6mf7U+1RD6Hzo+1To2EPB+lO8OtpJWu0hLdOz6EVx6EUm2Kni50OyO9pYXjv/x6nM6UQfXNKQi1rJP+Zwc036d7TIsF7ox0VhtVmzqoypu5JHcExw1ESbAAAA/3RSTlMAnGIQIDx9/v7+vvzf/lv+/P7b+rp9uXxClpFP+bP3w/rC+7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAoptLHAAAycklEQVR42uSbPWtbaRbHR7alwtghBBfLEoZpolfulaLEV/eOkhgkfQBv4dKQygwBp7SKXTAYNQIVU1jkI0RfIODORIVtZNwH4cZgggs31hLM7G5gz9vzduXpdB0vex4pyxZT/Pid8z/PlaWffvp/r/n03FwmlVpcXFpa2qd6jwX/b2llcSWVymQepdPz/yswc3OpJ/3+EAtI6J/3Upt8sOB/EXExBWwPGW2BaICHiYb7QzG0r4HsOt485tpcST1KP0CedIZwCGmKaD+m6ZiPhurBeyXzoLDmM0/a7Xa/3Xeo4pboX8uRxQRQvV7veOXRwgMRtMg8TDTsUA2FR0+S9N175hEkzQNECNXrPQQqAmozVGcy2NqC19bW58+T5v6+bcmZpmMZpc1pJqBKPwQgdLQ8ARrh+YxvoILKcVVyuSAMG2FjM9S9F+s7U0uPftwMpdqq+h3GISQCEiaFZFe+0Wg4imiSWvDPdm+3twv1o6DmDFC7PxEkzYNlHFU0VFVVvtXQioylXWI63V1a+FGKlvsIBMkwMIo01MRCqtC7yoerUC0UWq1jsYQ4CLS9S3W6m7n3xQq5vTwZDAYTirqOIH22q6LnqCKWDBDyUGULnlHU291VRLv3LQqJEAgLgDqdieo6Q5XLNZ2uqzpImgiPt01AoKgnQKdQvUf3S7Q8UDWhTbQVHyUh4nDIqUGyu46ZpDyS1LMsQWV+iCPFNHH7Duao6YyR03aaKEuWoFZXs/621XanVL17Y3KItgaDaaRKUzmq6ARnnoqtSHiACM/qKkG9QCBhui9PmbbVdrhglSatKGcRVawAryhFVYdIgFYFCrvu9PQ+mRYgvDsWEVyCOp16vT7YMj3nxLdF47RdVkvCvhOmosGBuji9yNxP27UHjqUt0FTvNAdiCIGasWC4O7+z2ZilErxe6LZDoouL5HMPLw3LjiQoIAJPkwHd6+yumyZSTNnYIBoomwnqdOE+JFnhsMXTVCeoZlMhNd27HRPpnVQlJJtJFWoqFU9tSxcr93GzmxhHrGkCjupNQKobSRU7HAxRQaedDgftiICgasJDRBdJj9OiiySXVUISS9aKtcPB5IOzklbtbCjhwdcL3XZU80nHnaTDlilCaqq2iydDZXrFWtlgtR0TUf0NeBjpK5xENaUMks4GuAU1se0cSZWcdbdTkqyNZHBcIsUkigAIanc+4XCQxnMk8RTZbWc981Xv7rmCy2TxlErlSJC4EtSU5me+ZafzPutwsPrOuYJLhBesJRtfSaVVNUdSuusQKcFpUo/mk4EOO7gt0CURU040WfegqqXJfqKI3YTctiuXys+NpcskNT1RHzWoB3NeSfXptrsjG8RS9k9myTKESGWL6PLrSsJ911/uyGMsANG9QUYppx05RJX4E8VdWVcyfYdAZdSkiKDSSe7Zdr9NN+/BZNLki5BO8Dvu3/ZDUvyyakHZ2VBmprULA3T59a+J7Vn+WLWjy+Kx8jt2Ac/Hn82nbkF2Liii8htNdHV5+UtCSKSo3R4qHiGqx8KOmAJhyss9KK9vqybrsvbVzooGqrU3ytJVcp2Xlk+4Ogapw0D2ljWSgmqAOzYPxwMejyR505fV0lQ0ABDUV1T0lSxdXWYSG6W+jJKxFJcU5IIKvAKRpNOOrt9efCXVdONpS5qJLBEQ1EpCW8kZpbpuPO0IcMBQIB8Uc9OBpIJX9Qp47OdYnxXV3FEqS9dhveZouOKaT2grIdHQnSSd3yEcajxUFCASNx1SqWck0ORlfSDyGaoWZ5JJAqbbV0BqkgSWTr+cO7g2eHlIkUXkgxfzHxRPCxHkLm5Sl42GdehgRiMiaVMBaaJxh+Pu9S0FT74kyWugqBmoGAY5dS99L3uVppbYheJCFEVH0XBUYvcdEo1GzCF7eNgEND6eTN64EtI7vUkw5S+Wg5dWCXKHRxJKeoJIfogdEr28ZzTZUP9eN0zgKBsWSQNiSTInlsYNVDKZ7L6ypaDWdGH0GroZyBECud3q1oBEJKn35dlFjs40EUiqgqSwVQ6j/QkkqhHQoSFK8pN0dFwNSeHQND5HpNrO637sVmdsAMsONgkU9fbu9A6fsZ+WM0lOJExdNsyW+oVodDQBigyRKEIa+tPm4TSjgidIkLyeizwRkQceqQZd33zE+pjoZe/wzvDwWehcNZj+hmqAVYoR0ndCNBphoPNEMJmkw3GjXaT/jm3wKcueUsEHwVS5SdTJKcCQIyUJ5qE0A+2Rbx4y17uzM7wzMjJyr24D1c/Wc6bs0FIsFo5pR2TJ2qMWIgdAZW5ewRJdGyR1PSmgQqi6uhZxMXikGbi+n6CkQbysDvpYEoZuZxiIRvb2fj2xgPQaUX+HYQBKFzjM9EVIbChDf9luE2kDHrNHPcDTk0KsVOqUJkU4qEjFzo2WnrgDBISpm6diQKYRQprYmzv69QzmX2/S63zGxqW/wwAVi8XYEikavTU6qYlUM8hkECqT2f62XUsbTZYwekgUTLkAC4BSHrVHQGUsqSOJNoktce5GJvb25uaOjhamYNJ8syMiOZLCYYXElqZV8PQpmyQoxsG/2b7dFtIGIRkgQAFTKAq/CLn4fcJDufMYR243VoOfFolPJOAhIPyaT0BAlE4bIpKUjcZAEuQuxjicu+lJLcneIwTicWzfuEbwaJd6UjIufojIdIOXqoHLDm8NPqxvKjtK3QQiLRyRorQm4mrATYrp4DHRqIW02dR1zJPJVNrp8Rki2tCWUsF8GSePH1YJCX+QBxR5VNeBI0qdn652yINlx5L29phoQYhy8QOa7AEC4SKBpEhEeGCTpsmSytyKWqSMNRXH9+1a2tChK8vkAarJkT6RvOrSgEesz+8jR3AgkSJeozlZI/paLEQIZRzFDNK0QlreRJ7xZkVbgvSqoz1LuEs85bLFlMduYEm0SB52hHvEa+RXd1XsBSGamzOpA0XrBghHAYElVkRE08vmZpdskrQFTwXD9+rmFS3ZQIAEjedRkhBoSK7f7oAcSdR1WHW9vEdU3yIpDUy59fWDdYkdPVmOHQXP5G5p8tB03QoC7bMkRQSWbrdpSZDyZcsSMUnwPOqQHWJLTwL+gJQdWMJqkNhRM1i5yx0YS+yJLNViYmnaWFqmPVpJNm3S1hYxVRz37186eTOUu41352MHRPmUh0LnodQNAZA6YwN4xuIeoSSKHVTDxIghSjNRXCQx0IFCUsHj3C0tLQMQS6LcoaN9cgQ/SJSpdHX9ti2ktpRqBcrnH7g0knUgSdmZ2/fwsNS37jo8kdK67PQqMRIARRIqdEgESLBIK4ooqdcIJFWAqYLz+8sjbSiklm6gISBmGgIgr33EgiQKHaQOu2FCHUj6jIXLqtmkrIIiIkKC1N0ySOhoJbmPjnTocCoZeiqVG21b0gWe10B5ApJiGNJlR464vnvZEe/R3J5qBqpvvH43rRFNjYASCalvBFpaWtnERdJrJKFjR1tAg0Rdd9u3lLIUlRUStrdAqWsQNQPdvunS0Gs1wxwpombI8RuFqTs1SBQhpFsK6dkynUhJKTuJHU+hIsGrfNMmUsqyZHJnWTKSBglJrqpGkpxIU8pSLof3oHNECW2JJQHTsyUEWsE92qcjdkshgaKCsuS4f9mvrdYu5VuJ8maPRBKVHa2SlJ3V3wYJT6Qc3+3OBS8rSFzfSLT0DC3hgbRPTKBpX0kqbBUKytJla1yQ6PUo2FwN+bzXI5ZsSX4FJI7o2jAhRyxt0hvMHcZutjpbPbBxsgmyBESJiEX0bEXdGuiExcNINqlQKVTUXHaZBOk1vVTkRVG5OXbqQHIHFBItkhyxTDRBi3Q0JSdSjt9kgSnbnLtagokSquwECf0YQxkxBI4KlLxK5bhS+b4NpNcbQX7ps0OHqUMiCt2QKjvtyCKa0NWwoA8kdDQ7S18abE0KaHIyYYCeLS4u7u/v84G0r9sbiSpG0/FxV1tIFDyYpmrQ1wZT3wG7vrHr2NHchErdm7RKHcSOv6zaseO2QyRJHTAtPlv88OGfu7u7f9/d/fnnLQ0EWwR/1goFkVTputEG0uvXKYF6YCvyeIY8uhkuIrIOpAUpBnhH4j1CJHnpM4uUEEcwtqQPAARQv/A8fVqQZkBHawIElr69NNJrLnE18E6RQhxeJMCyLKnY2ZZU1yEUNoPKXZWDh58a4N08oiahLSHREiMh064wrdI8LdCsFY4pewB13HWzHUv8+QTHAzgp4tGWmuv7fHvTiaTO2HSOcjcLlvSbeVjdVTWQWBKixQ8G6JfVv62uvlh9AbMmTJVjIjruutxh+xuUBI92pJg8quyGdDfoakCm4V277ISI61v6e7ZqvgedJ7K7gZH+gUyrKOnFn5Do7du3f10rrK2Ro2NEun1ZJCIKniPykiOWFLDeY1nSsC67CdV1U28sIgG6gGgSkZaXJw3Rhz/+j7Jz+YkyS+NwWsVg04xJm7gbF67dTJxVhzZhU1JiY9AesKhKoMYYO4ABujWh0+1UjOOoILeFFR0wXkggXGNiRa2oLMbAAptiihAIt/QAJUVqQCaRBWE17+1cvg+V4i35A548v/N7zylsm7qBFPU1iaMoz9VwmHngZ//f0/vbKdwOxpJSpEKnibbcGTSR3Oyw7LAaKHb//q6GFeFBUkQntaP6+noiuoJIwSsmdTjoqKQ2WgJEsVisNcxAYCm9LyDE0m2No4D+TI4Eyd5IObiRTOjK3ESnNZHrHH1vAwESE81dCQaDdjFQ6FhSzAtIsavEg0gHMtJGMpKI6KKRVPiZjYSWfiqzz5FcVjF2NfpLO2TCLxv0RhImaQYgmgva1dBEjpAphpYmwdOiQkrrv7D7wgoeS7qoY3fULUnXt74HKUm/0kH6Ra8k4KlhSZ+zdIVPksMSl11UxS4Wm4nFFu8L0t40kW4nb98OaUnmJFHu3PVt97e77JioRkvSX9uxJAdSQ71UA1gaDA4qR7Vcd9Fajh1CzUzOsKb4/vRaXCyFeL0qHi67TxBR2ZX9ZcQmQkfNzY7UuapBA9WTpIYGWrGYOyUJ+7u2TSsiR5NINBNjpPj+gztDOnrRcY4U0bw7dbKQXPXdyTu2mYiAKe+jO/Z7Q0RIV+AcBeFipxZSE1cDHySKHQDBAA9+0kPai0RJtyXj6BgUuOP2fcZd33gN6vxBSaoRSS6gk3ohnWMgQKL6JiIYA1RLiqJedsSz2IpE8f0H0kYKMZK7GAqlGZak7PRCOkNEWpIcI9xIyKPLTjO5uo6ZsO0G8SBVVQ3K3dt3V/c3O4KTlAufFAK17gDpn4RkNcNRdlSoUgeaEt+KpGUiGrEdAVKntWSJyRBt3bFQDYKE/R2sUi+KKn7xhe/WMtGkil0xB29Hlm6HQiIppC05+vsbDF4iJ2dr7qz6lm6wLJn+Pumw1MBIQepvjF2wowoeEx33ZcLh8FXShN1QDFCgqDW+GEkP6Q+8lhCJePRJAqL5P0ns1FU1Zznn42XHRDWn7fZ21bfLUcMolR3GrqrHp958woM/4XDrVTpKKfhA6HAW0vpGhZDwf6xhYsdE8+xoSbVdQpfdiL2Qhri/f3E4KlC5c98azimiUUBiIrTUQ0BV9JQI32egcCt+/IBUnHroB0l+YNoBEp4lnrdc34VS31R2Cbu+y5zN0Gk2kiq7gjxrIxXZG8lyNDqqy87n8yFNhzz5wjKLQATj96dSKf9OLGVgOyTRUgh5jiqi+WOSuiWu74Q0w4i1kIZkITFSje5vfWsocixZ099INKoc9fh64GFepYAUEgItaqZ4/OHOkGAuHnXv2GPzsmLBkvProI9KKheiAqsYTjmfSA4iQArSQgJJPnWM7qtzFGZFrZA3vz+QClDsACmdq/kesRRSFztimuf6po30rUgiSyNnXDtWITWftiXl553Khw86KlJIFtMoBw8cDVb5IHg9JMlnSwIodsSWAvH0kTI22ZIEr5CBpL6XcCEluBqW3Tt2yC67Zoldgb2RKHjKUr2LaFSaocrX4/Pdd54jpQgktfrjHLw4UD1JBynj0CYWXlJJAqh57G9M3ZI8kRL6iTSi6nuY6nvIIJXrtsuzfmsubVdpCtzkbjSogXxNmL2wk4kcgSIK3n/YUlpIX20SUigEzfBWHSSOHRAtqbJb5tSp9wQSDUk13AIieU8U8EnKz4PQiaIix3vC8IwGCQlT52u6S5c7K3KiCc4RSgqkUm8IaWHhwPovi12bm5vJEDeeugfNq6/slvgVm8AFm0Ndx46Gf1LHqJMXEqSu3HrHkqST6hzJ90HO1AX/FuwAJB+2HTji66qzGVAPQAX8gUDqDSJFgOnw4W3ftV8CURItrfE5eltIF7t5KYYlCJ25BpXZ9W0VQ/lpdY7I0SmshpPqGFHq6reEDscnoburv+FyEXHqFFJ8Ib7w+/+ObFfjhwBpM7nGwUMg7Dp+9MlGovpePgO5GxGkYey6oU6LiRwV6IWUz/1dhJIq9auvwYEElmjHwtyVN0U0ykBh7jmBQktvUm/aUVK8sbq7+4/bNDgjJZOMJCvpGGpa4mtDIifBFzvZsWWYumFd37ea4SjVmLYrQEun8vJN2dGrz4qdOkhBYKLcqWdftNZjHSR/1G+QxFLkN0Q6nLFd3yUJKWlbkts31bdaSCOO3DkklTOTtpRnXxvOVTrKTuobT1JHkBxZ71iPLga/v9XKXeDNG7AUj7T39lZXVx85uM1S2tycmkrSmNSBIrkIJfTtmyUNYzUM/TCkHTkuQvkgCbsun2KHZVeJC+maq75ZEZaDz7xko15AatUHiYhmAgSESIH2SKS3t7exGpl2b4M0pZAQir9roPYmIGo7dOS8ffNCuiULiQ6SXrK8kIrk+i2Oztc3nNdlhx84SJA79Q0XKJr0eCY9UbVh/TEAgsz5FVN7exyJGpHpSMb2SJS85FpybW1tfl5dgxKq7Ggh0ROJHKGkTr2RoOykGgpoH+FJKqK6A0lUDddcGyk42iH9bb49iUa9HpjcqNwazCnSRI29hESWDh+EydjzKaSpKda0hj88S0vY3ujom2XrXkfHaFjq26SOX30F+tYgzVDJxXDt3DnXXXU0qHl06JjIsx5TkjB1aIigIoH29l5D1P37kwGciYO7PoNE0VtbCxHRB5pEIiE3O6rvET5I0gyYu1u4ZMvLtaTvyBG++qi/sb4r1Y49T18I8Tt2sKfH/M6lSRFB7nI961EhanVYAqSXLxVSt0Ha+NfXH4HaI0hTpEksrX0grJWVFfgZGTkzYiwN/2osYX1jN5TLQSpgSZC7IrkIIVM9Njj+Zgx/0Ue/ReoZNL/pk2ZAIgtJtR28KYgo8JKQGsXSX588GECqrOwD2V9vid9uhTQ1nnTwfEAcmtmVWZjV2dXh1SH9T9rhv3uC9V3Omgrg3gBlZ//1/KJ9Rftk5mTkV5eGiGPnVUS5jGS3t5b0EoFQUnf3q4UnOMiUtZF9Z8u35Ic00pRm4hGg2dmns49mHwESTMtq/4uWlrrp6emK6el30+9oxt6N6ckcy5TZlyk8++auwWdOObJ+jYSxi5Z4vZMeJspdv0qpU7FLCVGEcqccdS8wEqdvY2PDfZH9SoDG4c/4uFKkDIGip+RI5kXLi5bpOvq8q9BACinTABFRJhPtsx1ZoUMgLww1AwABkrkI6bYDIkDS1dDdfd2BhPFzMX2pJPG8HpfUCRQBPZplR6sI1IJM09qRTWRBKUcsyeWoCaHwe+ISIppkRYxk+jtlIaklW81ExDQgTBNZG87rxBcOIJ7nK6/NKcLYrT5SRCQJUlehUvfOmbkx4cn8NBB13c2SEgHyeD0KaX1d94LfAopEGo2khQUlCYgeDAycOHFiYiJr70eQpsQREb1+jvN05bnETkmC3JElPklbcjfmyp0wqYM0J9XQ1NZ28yYhIZPHayQVa0sPA6bA2ZIgEZHUA/QeDBBNTGTbZb7LtsSanjMRzSMYcaQl1QGRdZI0zpjBsWJHRwn/6snjrq6+vr42AkIiLxPJQfIgkbIEV2/d37al6wsLDkuEhJY2svc4kcSR5E5JQiBE6oc//f0tNJfqLrXUVVQ4meyzRFj38HPv3s8w/8B59uwxDBH1MdFNIfJ6uL9ZUvG65G7Gr1JHICERK+uW46eDDyAYaQTJ7I2rL8QkeFyxEBPbaJ+RXQJpw6mAucCzFmc42ePHz9eery0tPTye/hc/hEGie4JEhF1IVGbcURAXt11CKSRLEkRgqomIlGESLhqVeNh8rI27uyykVjS661ENP02UZ2T6IImYqTSy6WXDRITPUOiri6VujZzjMRRrmG6UTxjVUNAgBDJEPGIIgDiw5SV/bV+ceyZcjSD6xgxEBJdalGK3I5okKcUDAnQj06ix13WOdJEVtcVk6Ti/xbfuEGCEOo34UGk6lecOh26gQcDShJ1HjDtNUifSx0ztfRL6owkdnTBILGk98R0z0gCIJLUx7G72eaI3aQED4jWwdH6DUBCqIDd4JHrkcgrGOsgPXBY4h7fuLPbiQQ842Tp9baWWFKFJjqrLL0vfY/DlojoZ5H02Ird/yk7n9eosiyOCzpDSZiZzcwoDs0g1DJ/RLkxxjhxI8aIELom4hCFsbUDSdEuglQSFCMWNERQjNYrZGK0OhjSplLOpmgXISpTCwMTJUWgGCoxsRYhuJzz69977nsvpr0VE5NVffie8z3nnXvrvVFPJBN0pNIIqjQ9MpKrnDuXP+dEmsmWPZUQh3USIEYyMu37n+d2LvCY6KHSyMXdhYtxiYRI/Zs27oYHOexmJeyeKmsQ/7aZRGE3wisHa1qJBCqVDRKr9OAnR0RMGHmffzQyMdLLl/GZ9DDW7IjojMokJNps20SiTbIGQhr2NHrqF6Sw2THR+sg0AsGachrNpAEom7WZ9IBV+nfBqMRIvzP1lpBeqhr73CXSM9++EeniDZNIvjls9pBEHHaGaNiPOp1GSGQrEiYSE+VAo2lCmp/PG41QJYeEeSTmcFyvlpYWafX2ffLtWxR6TkAPTYWNFKTYqEMeQzS7k9m1t4dKLEvESOtCNI9rjJlWZ7K40lyQeIFCBZLIqERO/nmfIPmNnfM6Y3Zx9h0m2uzvkagzZkfOYCrSPVeQ2Bhc2HVxQeIsIqRpQYImiDXKZsuEpMIOiQqeSIT0W4O0i9cxE/m3q0gXDBFXJKiw7Aymb5gVojiRTF/H1sBR10WJBEjTqNL8vFyZLyLUKgCteCoJkoo8kkm6or2fIp2dL9KvUglrLIukS5JtG7AgubbhqGtWPZVyOUICImCa4uvYMgkFKqVBpYwUpAcFDryISj9y5H2KdW9VkDz7thr5bUOP1zbMDg7vUJDavavYo557I9G6Czu5kAWaVUql1Z+sSBJ2hSgSe94fQ0i6V7Uaxfh3m0ICHkK6q1u7uO7bEZmCtGWYcusiEmnk5kEzHHbpXotUKBSO45evEpZbuWQ/FNJo1+5bVyTxOteret23JbIVSRH5BQmARCQkmldzyMlsGl9paYMKBRRJNEoJD/wsvSthbeJk+lmYqLUj9/5yQdJEbRJ0mgi8bjgadaOeNUiNtXGXQ7cTkeZlHIREkzQ/QaK0zSNcRJRiGn5JP87JdIi9LnI98WwHjZTZWWcQrxscvCvGoJwh1H4fPbolUdfljGGdiKYrzuvGZLI6ObmyAkAQdwYIjaEgLARDXylGkgbi0M/h/nvXa6QdkLTXhZBGVdvgdQ0Sd0hUq1Qq8/5gFddKOstIGUASlVIppw//gLgruSuM3z83K7b7/j7i3l6RDYedV5FUkeXAU0BWpHUKulqlhttIU04kISKZelmkBwbIEqVSrVar5EZ6v4m2DZ7ZWaawf/ebTPKv+rxrpNFw3+DCjpiIqFZDjSr5xZlFtoYxR9QEoowjCqnERClWST1u6+PHLySSfz0RLkhXlH3zBUWMfWtzIKItDyhniPLYrHpRhyvdS6kkRFadlHyn/5XA81rE8jifXr9+/dHG3DNtdhdDRGe8guSI7sYVJG3fEbPbYh4EwqCr5BFpcZGuzBlpxRCBSgVDVGASwRHBUmDiKYi8vQrp42uaFbv5lrXvuAvzNlOQrlyJK7GPIvZ9NnQZa3lGajVDRECwZsozZTE7irsmIFmJmAi+AlxOplSpVEqZZpwcgh+m+P7q+4WNZ4Jj/PuGH3Z+t2r9m+2b3O5fJNK9p9br9IQLNyhwrcNrZGStuFYzQWeZymVoGZBIVNIiARGtQJYieldKlT67bdx9rNLC+6sLCws/vNowKoXdTlekzRBRzNDunmqECGlLFuB0LU9MTBQFqaZEKgNTlqAIqMlxxyIFISLHBMl03EPag08lpWfAXTXPTHtx44a2B9V+94jbRQpS+KrPNatUYQ3P1pFlxEGiCULSIpVRJWhWgWlFRGqySjbwYpEw8ErvNNIhEmmBNHr1+BU+V+MxPuGgXr9gR0La8Xh2oseQgxZIDRpsw4BAcCm79ObN0NAEvogIFxMpkWh4gs13OmsyKcOpZAGCIMJUSkWQ0BwWNhZ+MM+uwq1LemoD7l5Wq231M24xVNumXeR4j+5Gymu7rLNn5wYGBoZ4TQwNWY2QyNj34mLeIwKmpthdL8VcUCjEEwWxKh2UJw8iEUtkn0JB+7F4e75EZ0eiM5Hgyz1LQ373aPARW52ZcD19cvse7fbhQS5aQ0PjQqSAkMlIlF8cY6CyAGWga8Cga2QyXiJFRUrGqbSXkHCD+R/mkTuoEGlE94zF/WW5C9fJ0x0nvPtP0KcU+RNjePb7n3QKlw4Pdo8z0NC4AJmoM0CVoou6sSmLRM03QGV6e5uZDCHh2w/w3Qc+EvwhiX9GlTx72HP4/YLbMn/8Xy0SHgPgG0Me6+g4JrfawWMNly65T5Leks/AGaRuOZimoITJijSBRPkiAWHMTbFKkkfp9B+gEwImINrmuCMeX6US0iSNTLouYTJh3G1I3Mkzd0Slzs7vSCcRCWQ6Qfc9OUV3ELp+8/otIDp//u01eBmRUKX78SrpsCsW80alsampy75KzdUMBJ7EXUBq8Ns3QEn4Tb6SKFLLZ31i6uDDBQKKiPQdZ9LfSKRj5lTD6VOXWKSbJuzeikYMdF9EkuU0MplUBKhaMZ8vchsERLgAhzKJoo7iDkTa3qawK1CI0dtPJQEnEHn4R4kDzzun8vDZxquNF3JQgx5R0ycaubt+cyYhEGQSQgHQzfM3z6NKIBGdSrMaEZEvkgECpDWWqCjOsDhG10gcdojUm0WkDBJh3IFIyWTKvggLCAP6L60S6vTnENIdIXrM7t3Hh0+QCLyh45g9eXJCrAET6aZ1hrfXnEbEc99EnRd0Q64gcRadozxiosuSSECUxhzKoDmASCrGEIRx+Hf0DPwLapSMIsGSiuSefcJ5JLcqPtlx+iTfdBCALl2/JFF36xqG3TVjDd2k0Xgc0ZA1BpKoiEB50Yi6b6NRL8VdBogaIBIEHSoSWKhApFE/KZe8Y1J7EQk6oDsvpMb26ccBkNWZPDol9v13Fgk/pvjWMztt3+NhY6AuCDUqUtDl/wNAY948CIkoiRCpsb29DW4nwRbwP4k5QeS4i3j4nj2C9P0N8xAhiTtUSe7rKyJZldC/b5FKEnemIt13TEOKidaaiFThRFqks3Zy1YcqpY1KHHeNTAOICMOmTZAM/RcAGck/InrYXckilIm7Pu++vigT322HKpJkki1JWqSdEsmKxNaQVzMuTyXUCBbIFASBfeuOJPDZKO5CB3kPuUtzbFPrfSISxZ24g7vr4HV3bxrr36YgdWsDt/Yd6oPy+Kp4UzsgWmFvMEiN3kaDkUgJ+90Ti/8UTSUoTHfCs5N6Xd1pnm+RbTOJKpKzu2+/vSZu121E8ho7Z99rxu0qtWmZfavpCc3s0iaRms0Gxp0WQ2vkARJS6Lzh3jtxBzXaqlUbdifVLfrkHiH0CWbrDU6k8RCTuZ5Yk+Z72szzIzM7IeK4azRRJPvmAy/gAo+vFK5KlEyWiC6O4GtigplB4rG0Dtc1UEEyvaoH5Pd1LuaIZ3ltba1G28s5NypWJ+0o7qzZERKssEQRhxCR4Cty0vWgv+VC1+X10KABTz3t57s8qe7bMnXbj1EYojn8eCx+kvSI3UWSDWbeoRgLi9Sb7lVx1ySRVKCRUkEol1ikZEv0SPxhN+LCYw11udirtvEMsqc/Ed6g+DD8YRZvH6RPd44OnJ2DV/vS0hL+O7LknQLI5RyTiTs74iIkRYRI0UwKlVj+KsEvMTdu3CdEF0NDu542fTxID0/o9Mms2utTc0gCChMR07RWyc3zOZNs3DWbrZhKgcsiK1GgLcK6QyruLPyByPC7KiIZooSbNAz7AyE1h8QjuG8IaCm8jcQS2U1z4w1q9u28oRWhGpEQiy1QiBR/d80DanBSb9PH0szwG67L9wPTfo/oiZnaDQASAs21CxExLattJAk6tY9k8oh2XSTstjOZVkBqbbQ2tneIOr9IoYPv8BmMA26ab9NIT/OvXPGODs7+gkAYdLf9OeTSkhFp2R1scGnkiC57GxTW7DJNQSKmIBmXUEq6mJqkbI83Y+tq9l11m0iyPzEsU0j/pN0ARx1qpPJITjyNRIim5h0RzlXF6zDstjMN4IHVYCjdJqjUUi1RjIErnep2WoeJZOzbOzpoNHIiyRhyQER60x4i6oogeRVphZ3BqYREBIVM+B3a8WDnyrRTIlkmGtnV1ey7X29R7GeVPrjtyyeIdNsebJhbameiJYi6I13LXtyZE0IhpGxaVyQIu9YVC9QwXPATmoltvNyg1cAXrtbGN1++8+7hvmpVwk6JhESqItm4Y5Fuj4pIczaTwgXJqjQfbhu4V1V9Q7P16xYQ/eXLn3k8UO3rrFarMvvu10S+ff/idsZURdIl9ohvdjl3CsDsXdI8SBFtK412IzE/diUCJnzGWBWwiKiqpvn7vYLERGx2A741KLML2bfaYJ4s23GQ7u2+TqHWv/5pdyLoIw50JjoTHfBK4MA4oeybGyHSyE7Ab+v9WOffSqNciGhMDb/tlTmLBBpNfg3TN7+KiIRKEFVHArpvaFXVZqzbc3Fmd1bySJoG0siZ3f+rO2MUhGEoDBd0MAcQKyI9i5ewuIp71y4ORdDRtZu9RmdX8QLyoKs9gLPvf0lsIigWpOJrL/DxJ2leXt8fd193dOoTzXmQleh2uLbSaMpj7jMg+UKJSnM81m1ebbaKSBa7Zh+09/4e9HZ2s7iO4yqudrvKKTB7NZelIxKYri1xWl4KFo7BxBrpfjFOKAg5xVobKSa8AU+e3dIaS6TicyngTlPzW+nQhbF3IkVfvQL6xZwamB44SKSQyhI8+ohglpYASVrn97A3yNM0L1NkSNk5Y6YzMwHIInnl2JN7+G2IoknQSbBULJDw0IaYiIHEog8mIabHnIFyJsrKEq8VSSyEak8jtxz7WL2XmmfYC7qL3mjMQEofCIlDH4lELNICJTFxoBCDA0liWaPCDDwAGSaHyAKZ+sQKPP2g8+iHI0Xi0CdjTuZRYjRqOn4fU+lZI3dl8FbvKBpOfoDzV3EHkd9/KKbWtFYAAAAASUVORK5CYII=",
      abilities: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe59e"/><stop offset="1" stop-color="%23ffc75b"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M68 18 40 70h18l-6 38 38-58H74l6-32z" fill="%23fff7d6" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/></svg>',
      seeds: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23d3f8c6"/><stop offset="1" stop-color="%239be4a3"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><ellipse cx="64" cy="76" rx="20" ry="16" fill="%23a36b3a" stroke="%236b4b2a" stroke-width="6"/><path d="M64 60c0-12 10-22 22-22-3 12-11 20-22 22zM64 60c0-12-10-22-22-22 3 12 11 20 22 22z" fill="%239cd67f" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/></svg>',
      values: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe59e"/><stop offset="1" stop-color="%23ffd24d"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="64" r="30" fill="%23ffd86a" stroke="%236b4b2a" stroke-width="6"/><path d="M64 44v40M52 54h24M52 74h24" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/></svg>',
      timers: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23cde9ff"/><stop offset="1" stop-color="%2387d0ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="72" r="34" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><path d="M64 72V52M64 72l18 12" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/><rect x="50" y="18" width="28" height="12" rx="6" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/></svg>',
      rooms: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe1f0"/><stop offset="1" stop-color="%23ffb6d9"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M28 70l36-26 36 26v30H28z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><rect x="54" y="74" width="20" height="26" rx="4" fill="%23ffd24d" stroke="%236b4b2a" stroke-width="6"/></svg>',
      shop: "https://cdn.discordapp.com/emojis/1423011042744729700.webp",
      tools: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e5e1ff"/><stop offset="1" stop-color="%23c7c2ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M46 86l36-36-8-8-36 36-2 14 10-6z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><rect x="68" y="34" width="14" height="14" rx="3" fill="%23ffd24d" stroke="%236b4b2a" stroke-width="6"/></svg>',
      settings: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23dff3ff"/><stop offset="1" stop-color="%23bfe6ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="64" r="20" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><path d="M64 30v12M64 86v12M30 64h12M86 64h12M42 42l8 8M78 78l8 8M86 42l-8 8M50 78l-8 8" stroke="%236b4b2a" stroke-width="6" stroke-linecap="round"/></svg>',
      hotkeys: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23fff2c4"/><stop offset="1" stop-color="%23ffd889"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><rect x="30" y="44" width="68" height="40" rx="10" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><text x="64" y="70" font-family="Arial,Helvetica,sans-serif" font-size="28" text-anchor="middle" fill="%236b4b2a">F</text></svg>',
      protect: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e2ffe7"/><stop offset="1" stop-color="%23b7f5c3"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M64 26l32 10v22c0 24-16 36-32 44-16-8-32-20-32-44V36z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><path d="M46 62l12 12 24-24" fill="none" stroke="%2394d36b" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/></svg>',
      notifications: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e3f0ff"/><stop offset="1" stop-color="%23c7dbff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M40 82h48l-6-10V58a18 18 0 10-36 0v14z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><circle cx="84" cy="44" r="10" fill="%23ff6464" stroke="%236b4b2a" stroke-width="6"/></svg>',
      help: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23f1e7ff"/><stop offset="1" stop-color="%23d9ccff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="88" r="6" fill="%236b4b2a"/><path d="M48 54a16 16 0 1132 0c0 10-8 10-10 16" fill="none" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/></svg>'
    };
    const tooltipText = {
      pets: "Pets \u2022 Alt+P \u2022 Shift+Click for widget",
      abilities: "Abilities \u2022 Alt+A \u2022 Shift+Click for widget",
      seeds: "Seeds \u2022 Alt+S \u2022 Shift+Click for widget",
      values: "Values \u2022 Alt+V \u2022 Shift+Click for widget",
      timers: "Timers \u2022 Shift+Click for widget",
      rooms: "Rooms \u2022 Shift+Click for widget",
      shop: "Shop \u2022 Alt+B",
      tools: "Tools",
      settings: "Settings \u2022 Alt+G",
      hotkeys: "Hotkeys",
      protect: "Crop Protection \u2022 Lock/unlock crops",
      notifications: "Notifications",
      help: "Help"
    };
    primaryTabs.forEach((tabName) => {
      const item = targetDocument2.createElement("div");
      item.className = "mgh-dock-item";
      item.dataset.tab = tabName;
      const img = targetDocument2.createElement("img");
      img.src = icons[tabName];
      img.style.height = "70%";
      img.onerror = () => {
        img.style.display = "none";
        const fallbackEmoji = targetDocument2.createElement("span");
        const emojiMap = {
          pets: "\u{1F43E}",
          abilities: "\u26A1",
          seeds: "\u{1F331}",
          values: "\u{1F48E}",
          timers: "\u23F1\uFE0F",
          rooms: "\u{1F3E0}",
          shop: "\u{1F6D2}",
          tools: "\u{1F527}",
          settings: "\u2699\uFE0F",
          hotkeys: "\u2328\uFE0F",
          protect: "\u{1F512}",
          notifications: "\u{1F514}",
          help: "\u2753"
        };
        fallbackEmoji.textContent = emojiMap[tabName] || "\u{1F4CB}";
        fallbackEmoji.style.fontSize = "24px";
        item.insertBefore(fallbackEmoji, item.firstChild);
      };
      item.appendChild(img);
      const tooltip = targetDocument2.createElement("div");
      tooltip.className = "mgh-tooltip";
      tooltip.innerHTML = tooltipText[tabName] || tabName.charAt(0).toUpperCase() + tabName.slice(1);
      item.appendChild(tooltip);
      item.addEventListener("click", (e) => {
        if (e.shiftKey) {
          openPopoutWidget2(tabName);
        } else {
          if (tabName === "shop") {
            toggleShopWindows2();
          } else {
            openSidebarTab2(tabName);
          }
        }
      });
      dock.appendChild(item);
    });
    const tailGroup = targetDocument2.createElement("div");
    tailGroup.className = "mgh-tail-group";
    tailGroup.style.display = "none";
    tailTabs.forEach((tabName) => {
      const item = targetDocument2.createElement("div");
      item.className = "mgh-dock-item";
      item.dataset.tab = tabName;
      const img = targetDocument2.createElement("img");
      img.src = icons[tabName];
      img.style.height = "70%";
      img.onerror = () => {
        img.style.display = "none";
        const fallbackEmoji = targetDocument2.createElement("span");
        const emojiMap = {
          pets: "\u{1F43E}",
          abilities: "\u26A1",
          seeds: "\u{1F331}",
          values: "\u{1F48E}",
          timers: "\u23F1\uFE0F",
          rooms: "\u{1F3E0}",
          shop: "\u{1F6D2}",
          tools: "\u{1F527}",
          settings: "\u2699\uFE0F",
          hotkeys: "\u2328\uFE0F",
          protect: "\u{1F512}",
          notifications: "\u{1F514}",
          help: "\u2753"
        };
        fallbackEmoji.textContent = emojiMap[tabName] || "\u{1F4CB}";
        fallbackEmoji.style.fontSize = "24px";
        item.insertBefore(fallbackEmoji, item.firstChild);
      };
      item.appendChild(img);
      const tooltip = targetDocument2.createElement("div");
      tooltip.className = "mgh-tooltip";
      tooltip.innerHTML = tooltipText[tabName] || tabName.charAt(0).toUpperCase() + tabName.slice(1);
      item.appendChild(tooltip);
      item.addEventListener("click", (e) => {
        if (e.shiftKey) {
          openPopoutWidget2(tabName);
        } else {
          openSidebarTab2(tabName);
        }
      });
      tailGroup.appendChild(item);
    });
    const versionIndicator = targetDocument2.createElement("div");
    versionIndicator.className = "mgh-dock-item version-indicator";
    versionIndicator.innerHTML = "\u25CF";
    versionIndicator.style.fontSize = "12px";
    versionIndicator.style.color = IS_LIVE_BETA2 ? "#ff9500" : "#00ff00";
    versionIndicator.style.cursor = "pointer";
    versionIndicator.title = `v${CURRENT_VERSION2} (${IS_LIVE_BETA2 ? "BETA" : "STABLE"}) - Checking for updates... (click to refresh)`;
    versionIndicator.addEventListener("click", (e) => {
      e.stopPropagation();
      versionIndicator.style.color = "#888";
      versionIndicator.title = `v${CURRENT_VERSION2} - Checking for updates...`;
      checkVersion2(versionIndicator);
    });
    tailGroup.appendChild(versionIndicator);
    const tailTrigger = targetDocument2.createElement("div");
    tailTrigger.className = "mgh-dock-item tail-trigger";
    tailTrigger.innerHTML = "\u22EF";
    tailTrigger.addEventListener("mouseenter", () => tailGroup.style.display = "flex");
    dock.addEventListener("mouseleave", () => {
      tailGroup.style.display = "none";
    });
    const flipToggle = targetDocument2.createElement("div");
    flipToggle.className = "mgh-dock-item flip-toggle";
    flipToggle.innerHTML = "\u2194";
    flipToggle.title = "Toggle orientation";
    flipToggle.addEventListener("click", (e) => {
      e.stopPropagation();
      if (dock.classList.contains("horizontal")) {
        dock.classList.remove("horizontal");
        dock.classList.add("vertical");
        dock.insertBefore(flipToggle, dock.firstChild);
        saveDockOrientation("vertical");
      } else {
        dock.classList.remove("vertical");
        dock.classList.add("horizontal");
        dock.appendChild(flipToggle);
        saveDockOrientation("horizontal");
      }
    });
    dock.appendChild(tailTrigger);
    dock.appendChild(tailGroup);
    dock.appendChild(flipToggle);
    checkVersion2(versionIndicator);
    makeDockDraggable(dock);
    const sidebar = targetDocument2.createElement("div");
    sidebar.id = "mgh-sidebar";
    const sidebarHeader = targetDocument2.createElement("div");
    sidebarHeader.className = "mgh-sidebar-header";
    const sidebarTitle = targetDocument2.createElement("div");
    sidebarTitle.className = "mgh-sidebar-title";
    sidebarTitle.textContent = "MGTools";
    const sidebarClose = targetDocument2.createElement("div");
    sidebarClose.className = "mgh-sidebar-close";
    sidebarClose.innerHTML = "\xD7";
    sidebarClose.addEventListener("click", () => {
      sidebar.classList.remove("open");
      targetDocument2.querySelectorAll(".mgh-dock-item").forEach((item) => {
        item.classList.remove("active");
      });
    });
    sidebarHeader.appendChild(sidebarTitle);
    sidebarHeader.appendChild(sidebarClose);
    const sidebarBody = targetDocument2.createElement("div");
    sidebarBody.className = "mgh-sidebar-body";
    sidebar.appendChild(sidebarHeader);
    sidebar.appendChild(sidebarBody);
    targetDocument2.body.appendChild(dock);
    targetDocument2.body.appendChild(sidebar);
    if (isDiscordEnv) {
      let uiRemovalCount = 0;
      const maxReinjections = 10;
      const observer = new MutationObserver((mutations) => {
        const dockMissing = !targetDocument2.body.contains(dock);
        const sidebarMissing = !targetDocument2.body.contains(sidebar);
        if ((dockMissing || sidebarMissing) && uiRemovalCount < maxReinjections) {
          uiRemovalCount++;
          productionLog3(`\u{1F504} [DISCORD] UI purged by React (${uiRemovalCount}/${maxReinjections}), re-injecting...`);
          if (dockMissing && dock.parentNode !== targetDocument2.body) {
            targetDocument2.body.appendChild(dock);
          }
          if (sidebarMissing && sidebar.parentNode !== targetDocument2.body) {
            targetDocument2.body.appendChild(sidebar);
          }
        }
      });
      observer.observe(targetDocument2.body, {
        childList: true,
        subtree: false
      });
      productionLog3("\u2705 [DISCORD] MutationObserver active for UI persistence");
    }
    const savedOrientation = loadDockOrientation();
    if (savedOrientation === "vertical") {
      dock.classList.remove("horizontal");
      dock.classList.add("vertical");
      dock.insertBefore(flipToggle, dock.firstChild);
    }
    const savedPosition = loadDockPosition();
    if (savedPosition) {
      dock.style.left = savedPosition.left + "px";
      dock.style.top = savedPosition.top + "px";
      dock.style.transform = "none";
      dock.style.bottom = "auto";
      dock.style.right = "auto";
    }
    UnifiedState3.panels.dock = dock;
    UnifiedState3.panels.sidebar = sidebar;
    UnifiedState3.panels.sidebarBody = sidebarBody;
    setTimeout(() => {
      const currentTheme = generateThemeStyles2();
      const isBlackTheme = currentTheme.gradientStyle && currentTheme.gradientStyle.startsWith("black-");
      if (isBlackTheme && currentTheme.accentColor) {
        applyAccentToDock2(currentTheme);
        applyAccentToSidebar2(currentTheme);
      } else {
        applyThemeToDock2(currentTheme);
        applyThemeToSidebar2(currentTheme);
      }
    }, 100);
    productionLog3("\u2705 Hybrid Dock UI created successfully");
  }
  function ensureUIHealthy({ targetDocument: targetDocument2, cleanupCorruptedDockPosition: cleanupCorruptedDockPosition3, createUnifiedUI: createUnifiedUI2, showToast }) {
    const maxRetries = 5;
    let retryCount = 0;
    function checkAndRetry() {
      const dock = targetDocument2.getElementById("mgh-dock");
      const sidebar = targetDocument2.getElementById("mgh-sidebar");
      const dockHidden = dock && (dock.style.display === "none" || window.getComputedStyle(dock).display === "none");
      const sidebarHidden = sidebar && (sidebar.style.display === "none" || window.getComputedStyle(sidebar).display === "none");
      if (!dock || !sidebar || dockHidden || sidebarHidden) {
        if (!dock) console.warn("[MGTools] Dock element missing");
        if (!sidebar) console.warn("[MGTools] Sidebar element missing");
        if (dockHidden) console.warn("[MGTools] Dock is hidden (display:none)");
        if (sidebarHidden) console.warn("[MGTools] Sidebar is hidden (display:none)");
        if (dockHidden || sidebarHidden) {
          console.warn("[MGTools] Clearing corrupted visibility state...");
          localStorage.removeItem("mgh_toolbar_visible");
        }
        retryCount++;
        if (retryCount < maxRetries) {
          const delay = Math.min(1e3 * Math.pow(2, retryCount - 1), 5e3);
          setTimeout(() => {
            try {
              cleanupCorruptedDockPosition3();
              createUnifiedUI2();
              checkAndRetry();
            } catch (error) {
              console.error("[MGTools TEST] UI recreation failed:", error);
            }
          }, delay);
        } else {
          console.error("[MGTools TEST] UI failed to load. Please report this issue.");
          try {
            const msg = targetDocument2.createElement("div");
            msg.style.cssText = "position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#ff4444;color:white;padding:20px;border-radius:10px;z-index:999999;font-family:Arial,sans-serif;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.5);";
            msg.innerHTML = "<strong>\u26A0\uFE0F MGTools UI Failed to Load</strong><br><br>Please reload the page (F5)<br>or check browser console for details.<br><br><small>Test Version 3.8.9-TEST</small>";
            targetDocument2.body.appendChild(msg);
            setTimeout(() => {
              if (msg.parentNode) msg.parentNode.removeChild(msg);
            }, 1e4);
          } catch (e) {
            console.error("[MGTools TEST] Emergency notification failed:", e);
          }
        }
      } else {
        setTimeout(() => {
          try {
            showToast("\u2705 MGTools TEST Loaded", "UI Health Check Passed", 3e3);
          } catch (e) {
          }
        }, 1e3);
      }
    }
    setTimeout(checkAndRetry, 500);
  }
  function setupToolbarToggle({ targetDocument: targetDocument2, document: document2, productionLog: productionLog3, showToast, CURRENT_VERSION: CURRENT_VERSION2 }) {
    if (window.__toolbarToggleInstalled) {
      return;
    }
    window.__toolbarToggleInstalled = true;
    const STORAGE_KEY = "mgh_toolbar_visible";
    const VERSION_KEY = "mgh_ui_version";
    const savedVersion = localStorage.getItem(VERSION_KEY);
    if (savedVersion !== CURRENT_VERSION2) {
      productionLog3(`\u{1F4E6} [UI-VERSION] Version change detected: ${savedVersion} \u2192 ${CURRENT_VERSION2}`);
      productionLog3("\u{1F4E6} [UI-VERSION] Resetting UI visibility state to default (visible)");
      localStorage.removeItem(STORAGE_KEY);
      localStorage.setItem(VERSION_KEY, CURRENT_VERSION2);
    }
    let toolbarVisible = localStorage.getItem(STORAGE_KEY) !== "false";
    function applyVisibility(visible, showNotification = false) {
      const dock = targetDocument2.getElementById("mgh-dock");
      const sidebar = targetDocument2.getElementById("mgh-sidebar");
      if (dock) {
        dock.style.display = visible ? "" : "none";
      }
      if (sidebar) {
        sidebar.style.display = visible ? "" : "none";
      }
      localStorage.setItem(STORAGE_KEY, visible.toString());
      if (showNotification) {
        try {
          showToast(visible ? "\u{1F3A8} Toolbar Shown" : "\u{1F47B} Toolbar Hidden", "Alt+M to toggle", 2e3);
        } catch (e) {
        }
      }
    }
    setTimeout(() => applyVisibility(toolbarVisible, false), 100);
    const toggleHandler = (e) => {
      if (e.altKey && (e.key === "m" || e.key === "M")) {
        e.preventDefault();
        e.stopPropagation();
        toolbarVisible = !toolbarVisible;
        applyVisibility(toolbarVisible, true);
        console.log(`[MGTools] Alt+M: Toolbar ${toolbarVisible ? "shown" : "hidden"}`);
      }
    };
    document2.addEventListener("keydown", toggleHandler, { passive: false, capture: true });
    if (targetDocument2 !== document2) {
      targetDocument2.addEventListener("keydown", toggleHandler, { passive: false, capture: true });
    }
  }
  function setupDockSizeControl({ targetDocument: targetDocument2, document: document2, resetDockPosition: resetDockPosition2, showToast }) {
    if (window.__dockSizeControlInstalled) {
      return;
    }
    window.__dockSizeControlInstalled = true;
    const STORAGE_KEY = "mgh_dock_size";
    const SIZES = ["micro", "mini", "tiny", "small", "medium", "large"];
    const SIZE_LABELS = {
      micro: "Micro",
      mini: "Mini",
      tiny: "Tiny",
      small: "Small",
      medium: "Medium",
      large: "Large"
    };
    let currentSize = localStorage.getItem(STORAGE_KEY) || "medium";
    if (!SIZES.includes(currentSize)) {
      currentSize = "medium";
    }
    function applyDockSize(size, showNotification = false) {
      const dock = targetDocument2.getElementById("mgh-dock");
      if (!dock) return;
      SIZES.forEach((s) => dock.classList.remove(`dock-size-${s}`));
      if (size !== "medium") {
        dock.classList.add(`dock-size-${size}`);
      }
      localStorage.setItem(STORAGE_KEY, size);
      currentSize = size;
      if (showNotification) {
        try {
          showToast(`\u{1F4CF} Dock Size: ${SIZE_LABELS[size]}`, "Alt+= / Alt+- to adjust", 2e3);
        } catch (e) {
        }
      }
    }
    setTimeout(() => applyDockSize(currentSize, false), 150);
    const sizeHandler = (e) => {
      if (e.altKey && (e.key === "=" || e.key === "+")) {
        e.preventDefault();
        e.stopPropagation();
        const currentIndex = SIZES.indexOf(currentSize);
        const nextIndex = (currentIndex + 1) % SIZES.length;
        applyDockSize(SIZES[nextIndex], true);
        console.log(`[MGTools] Alt+=: Dock size \u2192 ${SIZE_LABELS[SIZES[nextIndex]]}`);
      } else if (e.altKey && (e.key === "-" || e.key === "_")) {
        e.preventDefault();
        e.stopPropagation();
        const currentIndex = SIZES.indexOf(currentSize);
        const prevIndex = (currentIndex - 1 + SIZES.length) % SIZES.length;
        applyDockSize(SIZES[prevIndex], true);
        console.log(`[MGTools] Alt+-: Dock size \u2192 ${SIZE_LABELS[SIZES[prevIndex]]}`);
      } else if (e.altKey && (e.key === "x" || e.key === "X")) {
        e.preventDefault();
        e.stopPropagation();
        resetDockPosition2();
        console.log(`[MGTools] Alt+X: Dock position reset to default`);
      }
    };
    document2.addEventListener("keydown", sizeHandler, { passive: false, capture: true });
    if (targetDocument2 !== document2) {
      targetDocument2.addEventListener("keydown", sizeHandler, { passive: false, capture: true });
    }
  }
  function saveDockPosition(position) {
    try {
      const serialized = JSON.stringify(position);
      localStorage.setItem("mgh_dock_position", serialized);
      console.log(`[DOCK-SAVE] left=${position.left}, top=${position.top}, typeof=string (len=${serialized.length})`);
    } catch (e) {
      console.warn("[DOCK-SAVE] Exception during save:", e);
    }
  }
  function resetDockPosition({ targetDocument: targetDocument2, showNotificationToast: showNotificationToast2 }) {
    try {
      const dock = targetDocument2.getElementById("mgh-dock");
      if (!dock) {
        console.warn("[DOCK-RESET] Dock element not found");
        return;
      }
      localStorage.removeItem("mgh_dock_position");
      console.log("[DOCK-RESET] Cleared saved position");
      const dockWidth = dock.offsetWidth || 380;
      const defaultLeft = window.innerWidth - dockWidth - 20;
      const defaultTop = 100;
      dock.style.left = `${defaultLeft}px`;
      dock.style.top = `${defaultTop}px`;
      dock.style.transform = "none";
      dock.style.bottom = "auto";
      dock.style.right = "auto";
      console.log(`[DOCK-RESET] Reset to default position: left=${defaultLeft}, top=${defaultTop}`);
      try {
        showNotificationToast2("\u{1F3E0} Dock Reset - Position reset to default", "success");
      } catch (e) {
        console.log("[DOCK-RESET] Toast notification unavailable");
      }
    } catch (e) {
      console.warn("[DOCK-RESET] Exception during reset:", e);
    }
  }
  function cleanupCorruptedDockPosition() {
    try {
      const saved = localStorage.getItem("mgh_dock_position");
      if (!saved) return;
      if (typeof saved === "object" && saved !== null) {
        if (typeof saved.left === "number" && typeof saved.top === "number") {
          console.log("[DOCK-CLEANUP] Found valid object position, keeping it");
          return;
        } else {
          console.log("[DOCK-CLEANUP] Detected invalid object shape, clearing");
          localStorage.removeItem("mgh_dock_position");
          return;
        }
      }
      if (typeof saved === "string" && (saved === "[object Object]" || saved.startsWith("[object"))) {
        console.log("[DOCK-CLEANUP] Detected corrupted position data, clearing");
        localStorage.removeItem("mgh_dock_position");
        return;
      }
      try {
        JSON.parse(saved);
        console.log("[DOCK-CLEANUP] Position data is valid");
      } catch (parseError) {
        console.log("[DOCK-CLEANUP] Invalid JSON in position data, clearing");
        localStorage.removeItem("mgh_dock_position");
      }
    } catch (e) {
      console.warn("[DOCK-CLEANUP] Error during cleanup:", e);
      localStorage.removeItem("mgh_dock_position");
    }
  }
  function openSidebarTab(deps, tabName) {
    const { targetDocument: targetDocument2, UnifiedState: UnifiedState3, updateTabContent } = deps;
    const sidebar = UnifiedState3.panels.sidebar;
    const sidebarBody = UnifiedState3.panels.sidebarBody;
    const isAlreadyOpen = sidebar.classList.contains("open") && UnifiedState3.activeTab === tabName;
    if (isAlreadyOpen) {
      sidebar.classList.remove("open");
      targetDocument2.querySelectorAll(".mgh-dock-item").forEach((item) => {
        item.classList.remove("active");
      });
      return;
    }
    sidebar.querySelector(".mgh-sidebar-title").textContent = tabName.charAt(0).toUpperCase() + tabName.slice(1);
    UnifiedState3.activeTab = tabName;
    let contentEl = sidebarBody.querySelector("#mga-tab-content");
    if (!contentEl) {
      contentEl = targetDocument2.createElement("div");
      contentEl.id = "mga-tab-content";
      sidebarBody.innerHTML = "";
      sidebarBody.appendChild(contentEl);
    }
    updateTabContent();
    sidebarBody.scrollTop = 0;
    sidebar.classList.add("open");
    targetDocument2.querySelectorAll(".mgh-dock-item").forEach((item) => {
      item.classList.toggle("active", item.dataset.tab === tabName);
    });
    localStorage.setItem("mga_shift_hint_shown", "true");
  }
  function openPopoutWidget(deps, tabName) {
    const {
      targetDocument: targetDocument2,
      UnifiedState: UnifiedState3,
      makePopoutDraggable: makePopoutDraggable2,
      makeElementResizable: makeElementResizable2,
      generateThemeStyles: generateThemeStyles2,
      applyThemeToPopoutWidget: applyThemeToPopoutWidget2,
      stopInventoryCounter: stopInventoryCounter2,
      getCachedTabContent: getCachedTabContent2,
      contentGetters,
      handlerSetups
    } = deps;
    const existingPopout = targetDocument2.querySelector(`.mgh-popout[data-tab="${tabName}"]`);
    if (existingPopout) {
      UnifiedState3.data.popouts.widgets.delete(tabName);
      existingPopout.remove();
      return;
    }
    const popout = targetDocument2.createElement("div");
    popout.className = "mgh-popout";
    popout.dataset.tab = tabName;
    popout.style.top = "100px";
    popout.style.left = "100px";
    const header = targetDocument2.createElement("div");
    header.className = "mgh-popout-header";
    header.innerHTML = `
        <span>${tabName.charAt(0).toUpperCase() + tabName.slice(1)}</span>
        <span style="cursor: pointer; margin-left: auto; padding: 0 8px; font-size: 20px;">\xD7</span>
    `;
    const closeBtn = header.querySelector("span:last-child");
    closeBtn.addEventListener("click", () => {
      if (tabName === "shop") {
        stopInventoryCounter2();
      }
      UnifiedState3.data.popouts.widgets.delete(tabName);
      popout.remove();
    });
    const body = targetDocument2.createElement("div");
    body.className = "mgh-popout-body";
    const contentEl = targetDocument2.createElement("div");
    contentEl.id = "mga-tab-content";
    body.appendChild(contentEl);
    popout.appendChild(header);
    popout.appendChild(body);
    makePopoutDraggable2(deps, popout, header);
    const prevTab = UnifiedState3.activeTab;
    UnifiedState3.activeTab = tabName;
    const popoutContent = popout.querySelector("#mga-tab-content");
    switch (tabName) {
      case "pets":
        popoutContent.innerHTML = contentGetters.getPetsTabContent();
        handlerSetups.setupPetsTabHandlers(popout);
        break;
      case "abilities":
        popoutContent.innerHTML = contentGetters.getAbilitiesTabContent();
        handlerSetups.setupAbilitiesTabHandlers(popout);
        handlerSetups.updateAbilityLogDisplay(popout);
        break;
      case "seeds":
        popoutContent.innerHTML = contentGetters.getSeedsTabContent();
        handlerSetups.setupSeedsTabHandlers(popout);
        break;
      case "shop":
        popoutContent.innerHTML = contentGetters.getShopTabContent();
        handlerSetups.setupShopTabHandlers(popout);
        break;
      case "values":
        popoutContent.innerHTML = contentGetters.getValuesTabContent();
        handlerSetups.setupValuesTabHandlers(popout);
        break;
      case "timers":
        popoutContent.innerHTML = contentGetters.getTimersTabContent();
        break;
      case "rooms":
        popoutContent.innerHTML = contentGetters.getRoomStatusTabContent();
        handlerSetups.setupRoomJoinButtons(popout);
        break;
      case "tools":
        popoutContent.innerHTML = getCachedTabContent2(deps, "tools", contentGetters.getToolsTabContent);
        break;
      case "settings":
        popoutContent.innerHTML = getCachedTabContent2(deps, "settings", contentGetters.getSettingsTabContent);
        handlerSetups.setupSettingsTabHandlers(popout);
        break;
      case "hotkeys":
        popoutContent.innerHTML = getCachedTabContent2(deps, "hotkeys", contentGetters.getHotkeysTabContent);
        handlerSetups.setupHotkeysTabHandlers(popout);
        break;
      case "notifications":
        popoutContent.innerHTML = getCachedTabContent2(deps, "notifications", contentGetters.getNotificationsTabContent);
        handlerSetups.setupNotificationsTabHandlers(popout);
        break;
      case "protect":
        popoutContent.innerHTML = getCachedTabContent2(deps, "protect", contentGetters.getProtectTabContent);
        requestAnimationFrame(() => {
          handlerSetups.setupProtectTabHandlers(popout);
        });
        break;
      case "help":
        popoutContent.innerHTML = getCachedTabContent2(deps, "help", contentGetters.getHelpTabContent);
        break;
    }
    UnifiedState3.activeTab = prevTab;
    targetDocument2.body.appendChild(popout);
    const popoutThemeStyles = generateThemeStyles2(UnifiedState3.data.settings, true);
    if (popoutThemeStyles) {
      applyThemeToPopoutWidget2(popout, popoutThemeStyles);
    }
    makeElementResizable2(popout, {
      minWidth: 320,
      minHeight: 200,
      maxWidth: 800,
      maxHeight: 900,
      handleSize: 14,
      showHandleOnHover: true
    });
    UnifiedState3.data.popouts.widgets.set(tabName, popout);
  }
  function makePopoutDraggable(deps, popout, handle) {
    const { targetDocument: targetDocument2 } = deps;
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    const startDrag = (clientX, clientY, event) => {
      isDragging = true;
      startX = clientX;
      startY = clientY;
      const rect = popout.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;
      handle.style.cursor = "grabbing";
      event.preventDefault();
    };
    const handleDragMove = (clientX, clientY) => {
      if (!isDragging) return;
      const deltaX = clientX - startX;
      const deltaY = clientY - startY;
      popout.style.left = startLeft + deltaX + "px";
      popout.style.top = startTop + deltaY + "px";
    };
    const endDrag = () => {
      if (isDragging) {
        isDragging = false;
        handle.style.cursor = "grab";
      }
    };
    handle.addEventListener("mousedown", (e) => {
      startDrag(e.clientX, e.clientY, e);
    });
    targetDocument2.addEventListener("mousemove", (e) => {
      handleDragMove(e.clientX, e.clientY);
    });
    targetDocument2.addEventListener("mouseup", () => {
      endDrag();
    });
    handle.addEventListener(
      "touchstart",
      (e) => {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          startDrag(touch.clientX, touch.clientY, e);
        }
      },
      { passive: false }
    );
    targetDocument2.addEventListener(
      "touchmove",
      (e) => {
        if (isDragging && e.touches.length === 1) {
          const touch = e.touches[0];
          handleDragMove(touch.clientX, touch.clientY);
          e.preventDefault();
        }
      },
      { passive: false }
    );
    targetDocument2.addEventListener("touchend", () => {
      endDrag();
    });
    targetDocument2.addEventListener("touchcancel", () => {
      endDrag();
    });
  }
  function openTabInSeparateWindow(deps, tabName) {
    const {
      UnifiedState: UnifiedState3,
      productionLog: productionLog3,
      productionWarn: productionWarn3,
      debugLog: debugLog3,
      trackPopoutWindow: trackPopoutWindow2,
      contentGetters,
      handlerSetups,
      UNIFIED_STYLES: UNIFIED_STYLES2
    } = deps;
    productionLog3(`\u{1F517} Opening ${tabName} tab in pop-out window...`);
    const tabTitles = {
      pets: "\u{1F43E} Pet Loadouts",
      abilities: "\u26A1 Abilities",
      seeds: "\u{1F331} Seeds",
      values: "\u{1F4B0} Values",
      timers: "\u23F0 Timers",
      rooms: "\u{1F3AE} Rooms",
      settings: "\u2699\uFE0F Settings"
    };
    const title = `MGTools - ${tabTitles[tabName] || tabName}`;
    const windowFeatures = "width=450,height=550,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=no,status=no";
    const popoutWindow = window.open("", `mga_popout_${tabName}`, windowFeatures);
    if (!popoutWindow) {
      productionWarn3("\u26A0\uFE0F Pop-out blocked! Please allow popups for this site.");
      return;
    }
    trackPopoutWindow2(popoutWindow);
    UnifiedState3.data.popouts.windows.set(tabName, popoutWindow);
    popoutWindow.addEventListener("beforeunload", () => {
      UnifiedState3.data.popouts.windows.delete(tabName);
      debugLog3("POPOUT_LIFECYCLE", `Removed ${tabName} from windows Map`);
    });
    let content = "";
    switch (tabName) {
      case "pets":
        content = contentGetters.getPetsPopoutContent();
        break;
      case "abilities":
        content = contentGetters.getAbilitiesTabContent();
        break;
      case "seeds":
        content = contentGetters.getSeedsTabContent();
        break;
      case "shop":
        content = contentGetters.getShopTabContent();
        break;
      case "values":
        content = contentGetters.getValuesTabContent();
        break;
      case "timers":
        content = contentGetters.getTimersTabContent();
        break;
      case "tools":
        content = contentGetters.getToolsTabContent();
        break;
      case "rooms":
        content = contentGetters.getRoomStatusTabContent();
        break;
      case "settings":
        content = contentGetters.getSettingsTabContent();
        break;
      case "help":
        content = contentGetters.getHelpTabContent();
        break;
      default:
        content = "<p>Tab content not available</p>";
    }
    const currentTheme = UnifiedState3.currentTheme || deps.generateThemeStyles();
    const popoutHTML = `
<!DOCTYPE html>
<html>
<head>
    <title>${title}</title>
    <style>
        ${UNIFIED_STYLES2}
        body {
            margin: 0;
            padding: 16px;
            background: ${currentTheme.background};
            color: #ffffff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            --panel-scale: 1;
            --base-font-size: 13px;
            --responsive-font-size: calc(var(--base-font-size) * var(--panel-scale));
            font-size: var(--responsive-font-size);
        }

        /* Removed universal font scaling to prevent oversized popout UI */
        .popout-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.57);
            flex-wrap: wrap;
            gap: 10px;
        }
        .popout-title {
            font-size: 18px;
            font-weight: 600;
            color: #4a9eff;
            flex-shrink: 0;
            min-width: 150px;
        }
        .popout-sync-notice {
            font-size: 12px;
            color: #888;
            font-style: italic;
            flex: 1 1 auto;
            text-align: center;
            min-width: 200px;
        }
        .refresh-btn {
            padding: 6px 12px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            flex-shrink: 0;
        }
        .refresh-btn:hover {
            background: #3a8eef;
        }
    </style>
</head>
<body>
    <div class="popout-header">
        <div class="popout-title">${title}</div>
        <div class="popout-sync-notice">Note: This is a static snapshot. Click refresh to update.</div>
        <button class="refresh-btn" onclick="refreshPopoutContent('\${tabName}')">\u{1F504} Refresh</button>
    </div>
    <div id="popout-content">${content}</div>
    <script>
        // Store reference to main window
        const mainWindow = window.opener;

        function refreshPopoutContent(tabName) {
            if (!mainWindow || mainWindow.closed) {
                console.warn('\u26A0\uFE0F Main window is closed. Cannot refresh content.');
                return;
            }

            // Get fresh content from main window
            let freshContent = '';
            switch(tabName) {
                case 'pets':
                    freshContent = mainWindow.MGA_Internal?.getPetsPopoutContent ? mainWindow.MGA_Internal?.getPetsPopoutContent() : 'Content unavailable';
                    break;
                case 'abilities':
                    freshContent = mainWindow.MGA_Internal?.getAbilitiesTabContent ? mainWindow.MGA_Internal?.getAbilitiesTabContent() : 'Content unavailable';
                    break;
                case 'seeds':
                    freshContent = mainWindow.MGA_Internal?.getSeedsTabContent ? mainWindow.MGA_Internal?.getSeedsTabContent() : 'Content unavailable';
                    break;
                case 'shop':
                    freshContent = mainWindow.MGA_Internal?.getShopTabContent ? mainWindow.MGA_Internal?.getShopTabContent() : 'Content unavailable';
                    break;
                case 'values':
                    freshContent = mainWindow.MGA_Internal?.getValuesTabContent ? mainWindow.MGA_Internal?.getValuesTabContent() : 'Content unavailable';
                    break;
                case 'timers':
                    freshContent = mainWindow.MGA_Internal?.getTimersTabContent ? mainWindow.MGA_Internal?.getTimersTabContent() : 'Content unavailable';
                    break;
                case 'tools':
                    freshContent = mainWindow.MGA_Internal?.getToolsTabContent ? mainWindow.MGA_Internal?.getToolsTabContent() : 'Content unavailable';
                    break;
                case 'rooms':
                    freshContent = mainWindow.MGA_Internal?.getRoomStatusTabContent ? mainWindow.MGA_Internal?.getRoomStatusTabContent() : 'Content unavailable';
                    break;
                case 'settings':
                    freshContent = mainWindow.MGA_Internal?.getSettingsTabContent ? mainWindow.MGA_Internal?.getSettingsTabContent() : 'Content unavailable';
                    break;
            }

            document.getElementById('popout-content').innerHTML = freshContent;

            // Rerun handlers if needed
            if (tabName === 'abilities' && mainWindow.setupAbilitiesTabHandlers) {
                mainWindow.setupAbilitiesTabHandlers.call(mainWindow);
                if (mainWindow.updateAbilityLogDisplay) {
                    mainWindow.updateAbilityLogDisplay.call(mainWindow);
                }
            } else if (tabName === 'pets') {
                // For pets popout, use special popout handlers instead of main tab handlers
                if (mainWindow.setupPetPopoutHandlers) {
                    mainWindow.setupPetPopoutHandlers.call(mainWindow, document);
                }
            } else if (tabName === 'seeds' && mainWindow.setupSeedsTabHandlers) {
                mainWindow.setupSeedsTabHandlers.call(mainWindow, document);
            } else if (tabName === 'values' && mainWindow.resourceDashboard) {
                mainWindow.resourceDashboard.setupDashboardHandlers(document);
            } else if (tabName === 'settings' && mainWindow.setupSettingsTabHandlers) {
                mainWindow.setupSettingsTabHandlers.call(mainWindow, document);
            } else if (tabName === 'rooms' && mainWindow.setupRoomJoinButtons) {
                mainWindow.setupRoomJoinButtons.call(mainWindow);
            }

            console.log('Pop-out content refreshed for:', tabName);
        }

        // Expose refresh function on window object for external access
        window.refreshPopoutContent = refreshPopoutContent;

        // Store the tab name for this popup window
        const currentTabName = '\${tabName}';

        // Auto-refresh every 5 seconds for dynamic tabs
        if (['values', 'timers', 'rooms', 'abilities'].includes(currentTabName)) {
            // Use managed interval to prevent memory leaks
            if (window.opener && window.opener.setManagedInterval) {
                window.opener.setManagedInterval(
                    'popoutRefresh_' + currentTabName + '_' + Date.now(),
                    () => refreshPopoutContent(currentTabName),
                    5000
                );
            }
        }

        // Cleanup when window closes
        window.addEventListener('beforeunload', () => {
            console.log('Pop-out window closing for:', currentTabName);
        });
    <\/script>
</body>
</html>
        `;
    productionLog3("\u{1F331} [WINDOW DEBUG] Content being written to separate window:", {
      tabName,
      contentLength: content.length,
      htmlLength: popoutHTML.length,
      contentPreview: content.substring(0, 200)
    });
    popoutWindow.document.open();
    popoutWindow.document.write(popoutHTML);
    popoutWindow.document.close();
    setTimeout(() => {
      try {
        switch (tabName) {
          case "abilities":
            break;
          case "pets":
            handlerSetups.setupPetPopoutHandlers(popoutWindow.document);
            break;
          case "seeds":
            handlerSetups.setupSeedsTabHandlers(popoutWindow.document);
            break;
          case "shop":
            handlerSetups.setupShopTabHandlers(popoutWindow.document);
            break;
          case "settings":
            handlerSetups.setupSettingsTabHandlers(popoutWindow.document);
            break;
          case "tools":
            handlerSetups.setupToolsTabHandlers(popoutWindow.document);
            break;
          case "rooms":
            handlerSetups.setupRoomJoinButtons();
            handlerSetups.setupRoomsTabButtons();
            break;
          case "hotkeys":
            handlerSetups.setupHotkeysTabHandlers(popoutWindow.document);
            break;
          case "notifications":
            handlerSetups.setupNotificationsTabHandlers(popoutWindow.document);
            break;
          case "help":
            break;
        }
      } catch (error) {
        productionWarn3("Could not set up pop-out handlers:", error);
      }
    }, 100);
    productionLog3(`\u2705 Pop-out window opened for ${tabName} tab`);
  }
  function getContentForTab(deps, tabName, isPopout = false) {
    const { contentGetters } = deps;
    switch (tabName) {
      case "pets":
        return isPopout ? contentGetters.getPetsPopoutContent() : contentGetters.getPetsTabContent();
      case "abilities":
        return contentGetters.getAbilitiesTabContent();
      case "seeds":
        return contentGetters.getSeedsTabContent();
      case "shop":
        return contentGetters.getShopTabContent();
      case "values":
        return contentGetters.getValuesTabContent();
      case "timers":
        return contentGetters.getTimersTabContent();
      case "rooms":
        return contentGetters.getRoomStatusTabContent();
      case "tools":
        return contentGetters.getToolsTabContent();
      case "settings":
        return contentGetters.getSettingsTabContent();
      case "hotkeys":
        return contentGetters.getHotkeysTabContent();
      case "notifications":
        return contentGetters.getNotificationsTabContent();
      default:
        return '<div style="padding: 20px; text-align: center; color: rgba(255,255,255,0.5);">Content not available</div>';
    }
  }
  function setupOverlayHandlers(deps, overlay, tabName) {
    const { debugLog: debugLog3, debugError: debugError2, UnifiedState: UnifiedState3, handlerSetups } = deps;
    try {
      debugLog3("HANDLER_SETUP", `Setting up handlers for content-only overlay ${tabName}`, {
        overlayId: overlay.id
      });
      switch (tabName) {
        case "abilities":
          handlerSetups.setupAbilitiesTabHandlers(overlay);
          if (overlay) {
            handlerSetups.updateAbilityLogDisplay(overlay);
            debugLog3("ABILITY_LOGS", "Populated ability logs for content-only overlay", {
              logCount: UnifiedState3.data.petAbilityLogs.length
            });
          }
          break;
        case "pets":
          handlerSetups.setupPetPopoutHandlers(overlay);
          break;
        case "seeds":
          handlerSetups.setupSeedsTabHandlers(overlay);
          break;
        case "shop":
          handlerSetups.setupShopTabHandlers(overlay);
          break;
        case "settings":
          handlerSetups.setupSettingsTabHandlers(overlay);
          break;
        case "tools":
          handlerSetups.setupToolsTabHandlers(overlay);
          break;
        case "rooms":
          handlerSetups.setupRoomJoinButtons();
          handlerSetups.setupRoomsTabButtons();
          break;
        case "hotkeys":
          handlerSetups.setupHotkeysTabHandlers(overlay);
          break;
        case "notifications":
          handlerSetups.setupNotificationsTabHandlers(overlay);
          break;
      }
    } catch (error) {
      debugError2("HANDLER_SETUP", "Failed to set up content-only overlay handlers", error, {
        tabName,
        overlayId: overlay?.id
      });
    }
  }
  function createInGameOverlay(deps, tabName) {
    const {
      targetDocument: targetDocument2,
      UnifiedState: UnifiedState3,
      debugLog: debugLog3,
      productionLog: productionLog3,
      getGameViewport: getGameViewport2,
      findOptimalPosition: findOptimalPosition2,
      generateThemeStyles: generateThemeStyles2,
      makeEntireOverlayDraggable: makeEntireOverlayDraggable2,
      addResizeHandleToOverlay: addResizeHandleToOverlay2,
      loadOverlayPosition: loadOverlayPosition2,
      loadOverlayDimensions: loadOverlayDimensions2,
      closeInGameOverlay: closeInGameOverlay2
    } = deps;
    debugLog3("OVERLAY_LIFECYCLE", `Creating content-only overlay for ${tabName} tab`);
    if (UnifiedState3.data.popouts.overlays.has(tabName)) {
      const existingOverlay = UnifiedState3.data.popouts.overlays.get(tabName);
      if (existingOverlay && targetDocument2.contains(existingOverlay)) {
        if (existingOverlay.style.display !== "none") {
          existingOverlay.remove();
          UnifiedState3.data.popouts.overlays.delete(tabName);
          debugLog3("OVERLAY_LIFECYCLE", `Toggled OFF: ${tabName} overlay removed`);
          return null;
        } else {
          existingOverlay.style.display = "block";
          existingOverlay.style.zIndex = "999999";
          debugLog3("OVERLAY_LIFECYCLE", `Toggled ON: ${tabName} overlay shown`);
          return existingOverlay;
        }
      }
    }
    const overlay = targetDocument2.createElement("div");
    overlay.className = "mga-overlay-content-only mga-scrollable";
    overlay.id = `mga-overlay-${tabName}`;
    const gameViewport = getGameViewport2(deps);
    const smartPosition = findOptimalPosition2(deps, tabName, gameViewport);
    overlay.style.cssText = `
        position: fixed;
        top: ${smartPosition.top}px;
        left: ${smartPosition.left}px;
        width: 240px;
        height: 300px;
        min-height: 120px;
        max-height: 500px;
        padding: 10px 12px;
        color: #ffffff;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        font-size: 12px;
        line-height: 1.4;
        z-index: 999998;
        overflow-y: auto;
        min-width: 180px;
        max-width: 450px;
        user-select: none;
        border-radius: 4px;
        backdrop-filter: blur(10px);
        cursor: grab;
        will-change: width, height, transform;
    `;
    const popoutTheme = generateThemeStyles2(UnifiedState3.data.settings, true);
    if (popoutTheme.texturePattern) {
      overlay.style.background = `${popoutTheme.texturePattern}, ${popoutTheme.background}`;
      overlay.style.backgroundSize = `${popoutTheme.textureBackgroundSize}, cover`;
      overlay.style.backgroundBlendMode = `${popoutTheme.textureBlendMode}, normal`;
    } else {
      overlay.style.background = popoutTheme.background;
      overlay.style.backgroundBlendMode = "";
    }
    debugLog3("POP_OUT_DESIGN", `Applied content-only theme for ${tabName}`, {
      background: popoutTheme.background,
      dimensions: `${overlay.style.width} x ${overlay.style.height}`
    });
    overlay.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        debugLog3("POP_OUT_DESIGN", `Closing overlay ${tabName} via ESC key`);
        closeInGameOverlay2(deps, tabName);
      }
    });
    overlay.tabIndex = -1;
    overlay.focus();
    overlay.addEventListener("mouseenter", () => {
      if (!overlay.hasAttribute("data-dragging") && !overlay.id.includes("mga-pets-popout") && !overlay.id.includes("pets")) {
        overlay.style.transform = "scale(1.005)";
        overlay.style.transition = "transform 0.15s ease";
      }
    });
    overlay.addEventListener("mouseleave", () => {
      if (!overlay.hasAttribute("data-dragging") && !overlay.id.includes("mga-pets-popout") && !overlay.id.includes("pets")) {
        overlay.style.transform = "scale(1)";
      }
    });
    const contentHtml = `
        <style>
            /* TARGET IMAGE MATCH - Clean, readable styling */
            /* Section titles are now handled in the main visibility rules above */

            .mga-overlay-content-only .mga-section {
                margin: 0 !important;
                padding: 0 !important;
            }

            .mga-overlay-content-only .mga-value-row {
                display: flex !important;
                justify-content: space-between !important;
                margin: 3px 0 !important;
                padding: 2px 0 !important;
                line-height: 1.3 !important;
            }

            .mga-overlay-content-only .mga-value-label {
                font-size: 12px !important;
                color: rgba(255, 255, 255, 0.9) !important;
                font-weight: 400 !important;
                margin: 0 !important;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            }

            .mga-overlay-content-only .mga-value-amount {
                font-size: 13px !important;
                font-weight: 600 !important;
                color: #ffffff !important;
                margin: 0 !important;
                text-align: right;
                min-width: 50px;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
            }

            /* HIGH CONTRAST TOTAL VALUE */
            .mga-overlay-content-only .mga-total-value {
                border-top: 1px solid rgba(255, 255, 255, 0.73) !important;
                margin-top: 6px !important;
                padding-top: 4px !important;
            }

            .mga-overlay-content-only .mga-total-value .mga-value-label {
                font-weight: 500 !important;
                color: rgba(255, 255, 255, 0.95) !important;
                font-size: 13px !important;
            }

            .mga-overlay-content-only .mga-total-value .mga-value-amount {
                font-size: 14px !important;
                font-weight: 700 !important;
                color: #ffff00 !important;
                text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            }

            /* Hide only truly unnecessary elements - KEEP buttons and checkboxes for functionality */
            .mga-overlay-content-only .mga-section-header,
            .mga-overlay-content-only .mga-input-group,
            .mga-overlay-content-only .mga-timer-controls {
                display: none !important;
            }

            /* Keep section titles visible but make them smaller */
            .mga-overlay-content-only .mga-section-title {
                display: block !important;
                font-size: 11px !important;
                margin-bottom: 4px !important;
            }

            /* Readable ability logs */
            .mga-overlay-content-only .mga-log-item {
                margin: 2px 0 !important;
                padding: 2px 0 !important;
                font-size: 11px !important;
                line-height: 1.3 !important;
                color: rgba(255, 255, 255, 0.9) !important;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            }

            .mga-overlay-content-only .mga-log-time {
                font-size: 10px !important;
                color: rgba(255, 255, 255, 0.7) !important;
            }

            /* Readable pet loadouts */
            .mga-overlay-content-only .mga-pet-slot {
                margin: 2px 0 !important;
                padding: 3px !important;
                font-size: 11px !important;
                color: rgba(255, 255, 255, 0.9) !important;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            }
        </style>
    `;
    const contentHTML = getContentForTab(deps, tabName, true);
    productionLog3("\u{1F50D} [CONTENT DEBUG] Variables check:", {
      contentHtmlType: typeof contentHtml,
      contentHtmlLength: contentHtml?.length,
      contentHTMLType: typeof contentHTML,
      contentHTMLLength: contentHTML?.length,
      contentHtmlPreview: contentHtml?.substring(0, 100),
      contentHTMLPreview: contentHTML?.substring(0, 100)
    });
    if (tabName === "abilities") {
      const dragIndicator = `
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.57);">
                <div style="font-size: 11px; color: #4a9eff; font-weight: 600;">ABILITY LOGS</div>
                <div style="font-size: 9px; color: rgba(255,255,255,0.4); cursor: grab;" title="Click and drag to move">\u28FF\u28FF drag</div>
            </div>
        `;
      overlay.innerHTML = contentHtml + dragIndicator + contentHTML;
    } else {
      overlay.innerHTML = contentHtml + contentHTML;
    }
    productionLog3("\u{1F331} [OVERLAY DEBUG] Content inserted:", {
      tabName,
      contentLength: contentHTML.length,
      overlayHTML: overlay.innerHTML.substring(0, 200)
    });
    makeEntireOverlayDraggable2(deps, overlay);
    addResizeHandleToOverlay2(deps, overlay);
    loadOverlayPosition2(deps, overlay);
    loadOverlayDimensions2(deps, overlay);
    debugLog3("POP_OUT_DESIGN", `Content added to overlay for ${tabName}`, {
      hasContent: !!contentHTML
    });
    targetDocument2.body.appendChild(overlay);
    if (tabName === "notifications") {
      const notifications = UnifiedState3.data?.settings?.notifications;
      if (notifications) {
        const abilityCheckbox = overlay.querySelector("#ability-notifications-enabled");
        if (abilityCheckbox) {
          abilityCheckbox.checked = notifications.abilityNotificationsEnabled || false;
        }
        if (notifications.watchedAbilityCategories) {
          Object.keys(notifications.watchedAbilityCategories).forEach((category) => {
            const catCheckbox = overlay.querySelector(`#ability-cat-${category}`);
            if (catCheckbox) {
              catCheckbox.checked = notifications.watchedAbilityCategories[category];
            }
          });
        }
        if (notifications.watchedAbilities) {
          const individualCheckboxes = overlay.querySelectorAll(".individual-ability-checkbox");
          individualCheckboxes.forEach((checkbox) => {
            const abilityName = checkbox.dataset.abilityName;
            if (abilityName) {
              checkbox.checked = notifications.watchedAbilities.includes(abilityName);
            }
          });
        }
        productionLog3(`\u2705 [WIDGET-STATE] Reloaded notification settings for ${tabName} widget`);
      }
    }
    UnifiedState3.data.popouts.overlays.set(tabName, overlay);
    setTimeout(() => {
      setupOverlayHandlers(deps, overlay, tabName);
    }, 100);
    debugLog3("OVERLAY_LIFECYCLE", `Content-only overlay created for ${tabName}`, {
      dimensions: `${overlay.style.width} x ${overlay.style.height}`,
      overlayId: overlay.id
    });
    return overlay;
  }
  function makeEntireOverlayDraggable(deps, overlay) {
    const { targetDocument: targetDocument2, debugLog: debugLog3, getGameViewport: getGameViewport2, saveOverlayPosition: saveOverlayPosition2 } = deps;
    let isDragging = false;
    const dragOffset = { x: 0, y: 0 };
    let animationFrame = null;
    let dragStartTime = 0;
    debugLog3("OVERLAY_LIFECYCLE", "Setting up invisible dragging for entire overlay", {
      overlayId: overlay.id
    });
    overlay.addEventListener("mousedown", (e) => {
      if (e.target.tagName === "BUTTON" || e.target.tagName === "INPUT" || e.target.tagName === "SELECT" || e.target.closest(".mga-btn") || e.target.classList.contains("mga-resize-handle")) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      dragStartTime = Date.now();
      isDragging = false;
      const rect = overlay.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;
    });
    targetDocument2.addEventListener("mousemove", (e) => {
      if (dragStartTime === 0) return;
      const timeDiff = Date.now() - dragStartTime;
      const mouseMoved = Math.abs(e.clientX - dragOffset.x) > 3 || Math.abs(e.clientY - dragOffset.y) > 3;
      if (!isDragging && mouseMoved && timeDiff > 50) {
        isDragging = true;
        overlay.setAttribute("data-dragging", "true");
        overlay.style.zIndex = "999999";
        overlay.style.transform = "scale(1.02)";
        overlay.style.filter = "brightness(1.1)";
        overlay.style.transition = "transform 0.1s ease, filter 0.1s ease";
        overlay.classList.add("mga-dragging");
        targetDocument2.body.style.userSelect = "none";
        targetDocument2.body.style.cursor = "grabbing !important";
        debugLog3("OVERLAY_LIFECYCLE", "Started invisible dragging", { overlayId: overlay.id });
      }
      if (!isDragging) return;
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
      animationFrame = requestAnimationFrame(() => {
        const rect = overlay.getBoundingClientRect();
        const newX = e.clientX - dragOffset.x;
        const newY = e.clientY - dragOffset.y;
        const gameViewport = getGameViewport2(deps);
        const constrainedX = Math.max(gameViewport.left, Math.min(newX, gameViewport.right - rect.width));
        const constrainedY = Math.max(gameViewport.top, Math.min(newY, gameViewport.bottom - rect.height));
        overlay.style.left = constrainedX + "px";
        overlay.style.top = constrainedY + "px";
      });
    });
    targetDocument2.addEventListener("mouseup", () => {
      if (dragStartTime > 0) {
        dragStartTime = 0;
        if (isDragging) {
          isDragging = false;
          overlay.removeAttribute("data-dragging");
          overlay.classList.remove("mga-dragging");
          overlay.style.transform = "scale(1)";
          overlay.style.filter = "brightness(1)";
          overlay.style.zIndex = "999998";
          overlay.style.transition = "transform 0.2s ease, filter 0.2s ease";
          targetDocument2.body.style.userSelect = "";
          targetDocument2.body.style.cursor = "";
          if (animationFrame) {
            cancelAnimationFrame(animationFrame);
            animationFrame = null;
          }
          saveOverlayPosition2(deps, overlay.id, {
            left: overlay.style.left,
            top: overlay.style.top
          });
          debugLog3("OVERLAY_LIFECYCLE", "Finished invisible dragging", {
            overlayId: overlay.id,
            position: { left: overlay.style.left, top: overlay.style.top }
          });
        }
      }
    });
  }
  function getGameViewport(deps) {
    const { targetDocument: targetDocument2 } = deps;
    const gameContainer = targetDocument2.querySelector("#game-container, #app, .game-wrapper, main") || targetDocument2.body;
    const rect = gameContainer.getBoundingClientRect();
    return {
      top: Math.max(0, rect.top),
      left: Math.max(0, rect.left),
      right: Math.min(window.innerWidth, rect.right),
      bottom: Math.min(window.innerHeight, rect.bottom)
    };
  }
  function addResizeHandleToOverlay(deps, overlay) {
    const { productionLog: productionLog3, debugLog: debugLog3, makeElementResizable: makeElementResizable2, MGA_loadJSON: MGA_loadJSON2, MGA_saveJSON: MGA_saveJSON2 } = deps;
    productionLog3("\u{1F527} [RESIZE DEBUG] Adding resize handle to overlay:", overlay.id);
    debugLog3("RESIZE", "Adding resize handle to overlay", { overlayId: overlay.id });
    const existingHandle = overlay.querySelector(".mga-resize-handle");
    if (existingHandle) {
      existingHandle.remove();
      productionLog3("\u{1F527} [RESIZE DEBUG] Removed existing handle before adding new one");
    }
    makeElementResizable2(overlay, {
      minWidth: 180,
      minHeight: 120,
      maxWidth: 450,
      maxHeight: 500,
      showHandleOnHover: true
    });
    const observer = new MutationObserver(() => {
      if (overlay.style.width && overlay.style.height) {
        saveOverlayDimensions(deps, overlay.id, {
          width: overlay.style.width,
          height: overlay.style.height
        });
      }
    });
    observer.observe(overlay, {
      attributes: true,
      attributeFilter: ["style"]
    });
    overlay._resizeObserver = observer;
  }
  function saveOverlayDimensions(deps, overlayId, dimensions) {
    const { MGA_loadJSON: MGA_loadJSON2, MGA_saveJSON: MGA_saveJSON2, debugLog: debugLog3, debugError: debugError2 } = deps;
    try {
      const savedDimensions = MGA_loadJSON2("MGA_overlayDimensions", {});
      savedDimensions[overlayId] = dimensions;
      MGA_saveJSON2("MGA_overlayDimensions", savedDimensions);
      debugLog3("OVERLAY_LIFECYCLE", "Saved overlay dimensions", {
        overlayId,
        dimensions
      });
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to save overlay dimensions", error, {
        overlayId,
        dimensions
      });
    }
  }
  function loadOverlayDimensions(deps, overlay) {
    const { MGA_loadJSON: MGA_loadJSON2, debugLog: debugLog3, debugError: debugError2, applyResponsiveTextScaling } = deps;
    try {
      const savedDimensions = MGA_loadJSON2("MGA_overlayDimensions", {});
      const dimensions = savedDimensions[overlay.id];
      if (dimensions && dimensions.width && dimensions.height) {
        const width = parseInt(dimensions.width);
        const height = parseInt(dimensions.height);
        if (!isNaN(width) && !isNaN(height)) {
          overlay.style.width = dimensions.width;
          overlay.style.height = dimensions.height;
          applyResponsiveTextScaling(overlay, width, height);
          debugLog3("OVERLAY_LIFECYCLE", "Restored overlay dimensions", {
            overlayId: overlay.id,
            dimensions
          });
        }
      }
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to load overlay dimensions", error, {
        overlayId: overlay.id
      });
    }
  }
  function findOptimalPosition(deps, tabName, gameViewport) {
    const { MGA_loadJSON: MGA_loadJSON2, debugLog: debugLog3, hasCollisionAtPosition: hasCollisionAtPosition2, findPositionInZone: findPositionInZone2 } = deps;
    const overlayWidth = 240;
    const overlayHeight = 140;
    const margin = 15;
    const mainHudBuffer = 20;
    const snapGrid = 10;
    const savedPositions = MGA_loadJSON2("MGA_overlayPositions", {});
    const savedPosition = savedPositions[`mga-overlay-${tabName}`];
    if (savedPosition) {
      const leftPx = parseInt(savedPosition.left);
      const topPx = parseInt(savedPosition.top);
      if (!isNaN(leftPx) && !isNaN(topPx) && leftPx >= gameViewport.left && topPx >= gameViewport.top && leftPx + overlayWidth <= gameViewport.right && topPx + overlayHeight <= gameViewport.bottom) {
        if (!hasCollisionAtPosition2(deps, leftPx, topPx, overlayWidth, overlayHeight)) {
          debugLog3("OVERLAY_LIFECYCLE", "Using saved position with no collisions", {
            tabName,
            position: { left: leftPx, top: topPx }
          });
          return { left: leftPx, top: topPx };
        }
      }
    }
    const priorityZones = [
      // Zone 1: Right side of game viewport
      {
        name: "rightSide",
        x: gameViewport.right - overlayWidth - margin,
        y: gameViewport.top + margin,
        maxX: gameViewport.right - margin,
        maxY: gameViewport.bottom - overlayHeight - margin,
        stepX: 0,
        stepY: overlayHeight + margin
      },
      // Zone 2: Left side if right is full
      {
        name: "leftSide",
        x: gameViewport.left + margin,
        y: gameViewport.top + margin,
        maxX: gameViewport.left + overlayWidth + margin,
        maxY: gameViewport.bottom - overlayHeight - margin,
        stepX: 0,
        stepY: overlayHeight + margin
      },
      // Zone 3: Top area (cascade down)
      {
        name: "topArea",
        x: gameViewport.left + margin + overlayWidth + margin,
        y: gameViewport.top + margin,
        maxX: gameViewport.right - overlayWidth - margin,
        maxY: gameViewport.top + overlayHeight * 3,
        stepX: overlayWidth + margin,
        stepY: 30
      },
      // Zone 4: Bottom area (cascade up)
      {
        name: "bottomArea",
        x: gameViewport.left + margin,
        y: gameViewport.bottom - overlayHeight * 3,
        maxX: gameViewport.right - overlayWidth - margin,
        maxY: gameViewport.bottom - overlayHeight - margin,
        stepX: overlayWidth + margin,
        stepY: overlayHeight + margin
      }
    ];
    for (const zone of priorityZones) {
      const position = findPositionInZone2(deps, zone, overlayWidth, overlayHeight, snapGrid, mainHudBuffer);
      if (position) {
        debugLog3("OVERLAY_LIFECYCLE", `Found optimal position in ${zone.name}`, {
          tabName,
          position,
          zone: zone.name
        });
        return position;
      }
    }
    let fallbackX = gameViewport.left + margin;
    let fallbackY = gameViewport.top + margin;
    let attempts = 0;
    while (attempts < 20) {
      if (!hasCollisionAtPosition2(deps, fallbackX, fallbackY, overlayWidth, overlayHeight)) {
        debugLog3("OVERLAY_LIFECYCLE", "Using fallback position (no collision found)", {
          tabName,
          position: { left: fallbackX, top: fallbackY },
          attempts
        });
        return { left: fallbackX, top: fallbackY };
      }
      fallbackX += 30;
      fallbackY += 30;
      attempts++;
    }
    debugLog3("OVERLAY_LIFECYCLE", "Using last resort position (all attempts had collisions)", {
      tabName,
      position: { left: margin, top: margin }
    });
    return { left: margin, top: margin };
  }
  function findPositionInZone(deps, zone, overlayWidth, overlayHeight, snapGrid, mainHudBuffer) {
    const { hasCollisionAtPosition: hasCollisionAtPosition2, overlapsMainHUD: overlapsMainHUD2 } = deps;
    let x = zone.x;
    let y = zone.y;
    while (y <= zone.maxY) {
      while (x <= zone.maxX) {
        const snappedX = Math.round(x / snapGrid) * snapGrid;
        const snappedY = Math.round(y / snapGrid) * snapGrid;
        if (snappedX + overlayWidth <= zone.maxX && snappedY + overlayHeight <= zone.maxY) {
          if (!hasCollisionAtPosition2(deps, snappedX, snappedY, overlayWidth, overlayHeight) && !overlapsMainHUD2(deps, snappedX, snappedY, overlayWidth, overlayHeight)) {
            return { left: snappedX, top: snappedY };
          }
        }
        x += zone.stepX || overlayWidth + 15;
        if (zone.stepX === 0) break;
      }
      x = zone.x;
      y += zone.stepY || 30;
    }
    return null;
  }
  function overlapsMainHUD(deps, x, y, width, height) {
    const { targetDocument: targetDocument2 } = deps;
    const mainHUD = targetDocument2.querySelector(".mga-panel");
    if (!mainHUD) return false;
    const mainHudRect = mainHUD.getBoundingClientRect();
    const buffer = 20;
    const expandedRect = {
      left: mainHudRect.left - buffer,
      top: mainHudRect.top - buffer,
      right: mainHudRect.right + buffer,
      bottom: mainHudRect.bottom + buffer
    };
    return !(x + width < expandedRect.left || x > expandedRect.right || y + height < expandedRect.top || y > expandedRect.bottom);
  }
  function hasCollisionAtPosition(deps, x, y, width, height) {
    const { targetDocument: targetDocument2 } = deps;
    const existingOverlays = Array.from(targetDocument2.querySelectorAll(".mga-overlay-content-only"));
    const buffer = 5;
    for (const existingOverlay of existingOverlays) {
      const rect = existingOverlay.getBoundingClientRect();
      if (!(x + width + buffer < rect.left || x - buffer > rect.right || y + height + buffer < rect.top || y - buffer > rect.bottom)) {
        return true;
      }
    }
    return false;
  }
  function saveOverlayPosition(deps, overlayId, position) {
    const { MGA_loadJSON: MGA_loadJSON2, MGA_saveJSON: MGA_saveJSON2, debugLog: debugLog3, debugError: debugError2 } = deps;
    try {
      const savedPositions = MGA_loadJSON2("MGA_overlayPositions", {});
      savedPositions[overlayId] = position;
      MGA_saveJSON2("MGA_overlayPositions", savedPositions);
      debugLog3("OVERLAY_LIFECYCLE", "Saved overlay position", {
        overlayId,
        position
      });
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to save overlay position", error, {
        overlayId,
        position
      });
    }
  }
  function loadOverlayPosition(deps, overlay) {
    const { MGA_loadJSON: MGA_loadJSON2, debugLog: debugLog3, debugError: debugError2, getGameViewport: getGameViewport2 } = deps;
    try {
      const savedPositions = MGA_loadJSON2("MGA_overlayPositions", {});
      const position = savedPositions[overlay.id];
      if (position) {
        const gameViewport = getGameViewport2(deps);
        const leftPx = parseInt(position.left);
        const topPx = parseInt(position.top);
        if (!isNaN(leftPx) && !isNaN(topPx) && leftPx >= gameViewport.left && topPx >= gameViewport.top && leftPx < gameViewport.right && topPx < gameViewport.bottom) {
          overlay.style.left = position.left;
          overlay.style.top = position.top;
          debugLog3("OVERLAY_LIFECYCLE", "Restored overlay position", {
            overlayId: overlay.id,
            position
          });
        } else {
          debugLog3("OVERLAY_LIFECYCLE", "Saved position out of bounds, using default", {
            overlayId: overlay.id,
            savedPosition: position,
            viewport: gameViewport
          });
        }
      }
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to load overlay position", error, {
        overlayId: overlay.id
      });
    }
  }
  function closeInGameOverlay(deps, tabName) {
    const { targetDocument: targetDocument2, UnifiedState: UnifiedState3, productionLog: productionLog3, updatePopoutButtonStateByTab: updatePopoutButtonStateByTab2 } = deps;
    const overlay = UnifiedState3.data.popouts.overlays.get(tabName);
    if (overlay && targetDocument2.contains(overlay)) {
      overlay.remove();
    }
    UnifiedState3.data.popouts.overlays.delete(tabName);
    updatePopoutButtonStateByTab2(deps, tabName, false);
    productionLog3(`\u{1F5D1}\uFE0F Closed in-game overlay for ${tabName} tab`);
  }
  function updatePopoutButtonStateByTab(deps, tabName, isActive) {
    const { targetDocument: targetDocument2, updatePopoutButtonState: updatePopoutButtonState2 } = deps;
    const popoutBtn = targetDocument2.querySelector(`[data-popout="${tabName}"]`);
    if (popoutBtn) {
      updatePopoutButtonState2(deps, popoutBtn, isActive);
    }
  }
  function updatePureOverlayContent(deps, overlay, tabName) {
    const { productionLog: productionLog3, debugLog: debugLog3, debugError: debugError2, contentGetters, setupPureOverlayHandlers: setupPureOverlayHandlers2, addResizeHandleToOverlay: addResizeHandleToOverlay2 } = deps;
    try {
      debugLog3("OVERLAY_LIFECYCLE", `Updating pure overlay content for ${tabName}`, {
        overlayId: overlay.id
      });
      let content = "";
      switch (tabName) {
        case "pets":
          content = contentGetters.getPetsPopoutContent();
          break;
        case "abilities":
          content = contentGetters.getAbilitiesTabContent();
          break;
        case "seeds":
          content = contentGetters.getSeedsTabContent();
          break;
        case "values":
          content = contentGetters.getValuesTabContent();
          break;
        case "timers":
          content = contentGetters.getTimersTabContent();
          break;
        case "settings":
          content = contentGetters.getSettingsTabContent();
          break;
        default:
          content = "<p>Tab content not available</p>";
      }
      const contentHtml = `
        <style>
            /* TARGET IMAGE MATCH - Clean, readable styling */
            /* Section titles are now handled in the main visibility rules above */

            .mga-overlay-content-only .mga-section {
                margin: 0 !important;
                padding: 0 !important;
            }

            .mga-overlay-content-only .mga-value-row {
                display: flex !important;
                justify-content: space-between !important;
                margin: 3px 0 !important;
                padding: 2px 0 !important;
                line-height: 1.3 !important;
            }

            .mga-overlay-content-only .mga-value-label {
                font-size: 12px !important;
                color: rgba(255, 255, 255, 0.9) !important;
                font-weight: 400 !important;
                margin: 0 !important;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            }

            .mga-overlay-content-only .mga-value-amount {
                font-size: 13px !important;
                font-weight: 600 !important;
                color: #ffffff !important;
                margin: 0 !important;
                text-align: right;
                min-width: 50px;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
            }

            /* HIGH CONTRAST TOTAL VALUE */
            .mga-overlay-content-only .mga-total-value {
                border-top: 1px solid rgba(255, 255, 255, 0.73) !important;
                margin-top: 6px !important;
                padding-top: 4px !important;
            }

            .mga-overlay-content-only .mga-total-value .mga-value-label {
                font-weight: 500 !important;
                color: rgba(255, 255, 255, 0.95) !important;
                font-size: 13px !important;
            }

            .mga-overlay-content-only .mga-total-value .mga-value-amount {
                font-size: 14px !important;
                font-weight: 700 !important;
                color: #ffff00 !important;
                text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            }

            /* Hide only truly unnecessary elements - KEEP buttons and checkboxes for functionality */
            .mga-overlay-content-only .mga-section-header,
            .mga-overlay-content-only .mga-input-group,
            .mga-overlay-content-only .mga-timer-controls {
                display: none !important;
            }

            /* Keep section titles visible but make them smaller */
            .mga-overlay-content-only .mga-section-title {
                display: block !important;
                font-size: 11px !important;
                margin-bottom: 4px !important;
            }

            /* Readable ability logs */
            .mga-overlay-content-only .mga-log-item {
                margin: 2px 0 !important;
                padding: 2px 0 !important;
                font-size: 11px !important;
                line-height: 1.3 !important;
                color: rgba(255, 255, 255, 0.9) !important;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            }

            .mga-overlay-content-only .mga-log-time {
                font-size: 10px !important;
                color: rgba(255, 255, 255, 0.7) !important;
            }

            /* Readable pet loadouts */
            .mga-overlay-content-only .mga-pet-slot {
                margin: 2px 0 !important;
                padding: 3px !important;
                font-size: 11px !important;
                color: rgba(255, 255, 255, 0.9) !important;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            }
        </style>
    `;
      productionLog3("\u{1F50D} [PURE OVERLAY DEBUG] Variables check:", {
        contentHtmlType: typeof contentHtml,
        contentHtmlLength: contentHtml?.length,
        contentType: typeof content,
        contentLength: content?.length,
        contentHtmlPreview: contentHtml?.substring(0, 100),
        contentPreview: content?.substring(0, 100)
      });
      overlay.innerHTML = contentHtml + content;
      setupPureOverlayHandlers2(deps, overlay, tabName);
      setTimeout(() => {
        if (!overlay.querySelector(".mga-resize-handle")) {
          addResizeHandleToOverlay2(deps, overlay);
          productionLog3(`\u{1F527} [RESIZE] Re-added missing resize handle to ${tabName} pure overlay`);
        }
      }, 50);
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to update pure overlay content", error, {
        tabName,
        overlayId: overlay.id
      });
    }
  }
  function setupPureOverlayHandlers(deps, overlay, tabName) {
    const { productionLog: productionLog3, debugLog: debugLog3, debugError: debugError2, UnifiedState: UnifiedState3, handlerSetups } = deps;
    setTimeout(() => {
      try {
        productionLog3(`\u{1F527} [HANDLER-SETUP] Setting up handlers for ${tabName} overlay`);
        debugLog3("HANDLER_SETUP", `Setting up pure overlay handlers for ${tabName}`, {
          overlayId: overlay.id
        });
        switch (tabName) {
          case "abilities":
            handlerSetups.setupAbilitiesTabHandlers(overlay);
            handlerSetups.updateAbilityLogDisplay(overlay);
            debugLog3("ABILITY_LOGS", "Set up ability logs for pure overlay", {
              logCount: UnifiedState3.data.petAbilityLogs.length,
              overlayId: overlay.id
            });
            break;
          case "pets":
            handlerSetups.setupPetPopoutHandlers(overlay);
            break;
          case "seeds":
            handlerSetups.setupSeedsTabHandlers(overlay);
            break;
          case "settings":
            handlerSetups.setupSettingsTabHandlers(overlay);
            break;
          case "tools":
            handlerSetups.setupToolsTabHandlers(overlay);
            break;
          default:
            break;
        }
      } catch (error) {
        debugError2("HANDLER_SETUP", "Failed to set up pure overlay handlers", error, {
          tabName,
          overlayId: overlay.id
        });
      }
    }, 200);
  }
  function refreshOverlayContent(deps, tabName) {
    const { targetDocument: targetDocument2, UnifiedState: UnifiedState3, productionLog: productionLog3, updatePureOverlayContent: updatePureOverlayContent2, updateOverlayContent: updateOverlayContent2 } = deps;
    const overlay = UnifiedState3.data.popouts.overlays.get(tabName);
    if (overlay && targetDocument2.contains(overlay)) {
      if (overlay.className.includes("mga-overlay-content-only")) {
        updatePureOverlayContent2(deps, overlay, tabName);
        productionLog3(`\u{1F504} Refreshed pure overlay content for ${tabName} tab`);
      } else {
        const contentArea = overlay.querySelector(".mga-overlay-content");
        if (contentArea) {
          updateOverlayContent2(deps, contentArea, tabName);
          productionLog3(`\u{1F504} Refreshed legacy overlay content for ${tabName} tab`);
        }
      }
    }
  }
  function updateOverlayContent(deps, contentArea, tabName) {
    const { targetDocument: targetDocument2, debugLog: debugLog3, debugError: debugError2, UnifiedState: UnifiedState3, contentGetters, handlerSetups } = deps;
    let content = "";
    switch (tabName) {
      case "pets":
        content = contentGetters.getPetsPopoutContent();
        break;
      case "abilities":
        content = contentGetters.getAbilitiesTabContent();
        break;
      case "seeds":
        content = contentGetters.getSeedsTabContent();
        break;
      case "shop":
        content = contentGetters.getShopTabContent();
        break;
      case "values":
        content = contentGetters.getValuesTabContent();
        break;
      case "timers":
        content = contentGetters.getTimersTabContent();
        break;
      case "tools":
        content = contentGetters.getToolsTabContent();
        break;
      case "rooms":
        content = contentGetters.getRoomStatusTabContent();
        break;
      case "settings":
        content = contentGetters.getSettingsTabContent();
        break;
      case "help":
        content = contentGetters.getHelpTabContent();
        break;
      default:
        content = "<p>Tab content not available</p>";
    }
    const styles = contentArea.querySelector("style");
    contentArea.innerHTML = "";
    if (styles) contentArea.appendChild(styles);
    const contentDiv = targetDocument2.createElement("div");
    contentDiv.innerHTML = content;
    contentArea.appendChild(contentDiv);
    setTimeout(() => {
      try {
        const parentOverlay = contentArea.closest(".mga-overlay") || contentArea.parentElement;
        debugLog3("HANDLER_SETUP", `Setting up handlers for ${tabName}`, {
          overlayFound: !!parentOverlay,
          overlayClass: parentOverlay?.className,
          contentAreaClass: contentArea?.className
        });
        switch (tabName) {
          case "abilities":
            handlerSetups.setupAbilitiesTabHandlers(parentOverlay);
            if (parentOverlay) {
              handlerSetups.updateAbilityLogDisplay(parentOverlay);
              debugLog3("ABILITY_LOGS", "Populated ability logs for new overlay", {
                logCount: UnifiedState3.data.petAbilityLogs.length,
                overlayId: parentOverlay?.id || "no-id"
              });
              setTimeout(() => {
                handlerSetups.updateAbilityLogDisplay(parentOverlay);
                debugLog3("ABILITY_LOGS", "Secondary refresh for ability logs completed");
              }, 500);
            } else {
              debugError2(
                "HANDLER_SETUP",
                "Could not find parent overlay for ability logs setup",
                new Error("Parent overlay not found"),
                { tabName, contentArea }
              );
            }
            break;
          case "pets":
            handlerSetups.setupPetPopoutHandlers(parentOverlay);
            break;
          case "seeds":
            handlerSetups.setupSeedsTabHandlers(parentOverlay);
            break;
          case "shop":
            handlerSetups.setupShopTabHandlers(parentOverlay);
            break;
          case "settings":
            handlerSetups.setupSettingsTabHandlers(parentOverlay);
            break;
          case "notifications":
            handlerSetups.setupNotificationsTabHandlers(parentOverlay);
            break;
        }
      } catch (error) {
        debugError2("HANDLER_SETUP", "Failed to set up overlay handlers", error, {
          tabName,
          contentArea
        });
      }
    }, 100);
  }
  function toggleTabPopout(deps, tabName, buttonElement) {
    const {
      UnifiedState: UnifiedState3,
      targetDocument: targetDocument2,
      debugLog: debugLog3,
      closeInGameOverlay: closeInGameOverlay2,
      createInGameOverlay: createInGameOverlay2,
      openTabInSeparateWindow: openTabInSeparateWindow2,
      updatePopoutButtonState: updatePopoutButtonState2
    } = deps;
    const isOverlayMode = UnifiedState3.data.settings.useInGameOverlays;
    if (isOverlayMode) {
      const existingOverlay = UnifiedState3.data.popouts.overlays.get(tabName);
      if (existingOverlay && targetDocument2.contains(existingOverlay)) {
        closeInGameOverlay2(deps, tabName);
        updatePopoutButtonState2(deps, buttonElement, false);
        debugLog3("OVERLAY_LIFECYCLE", `Toggled OFF: ${tabName} overlay closed`);
      } else {
        createInGameOverlay2(deps, tabName);
        updatePopoutButtonState2(deps, buttonElement, true);
        debugLog3("OVERLAY_LIFECYCLE", `Toggled ON: ${tabName} overlay opened`);
      }
    } else {
      openTabInSeparateWindow2(deps, tabName);
      updatePopoutButtonState2(deps, buttonElement, true);
      debugLog3("OVERLAY_LIFECYCLE", `Opened separate window for ${tabName}`);
    }
  }
  function updatePopoutButtonState(deps, buttonElement, isActive) {
    if (isActive) {
      buttonElement.style.color = "#4CAF50";
      buttonElement.style.transform = "scale(1.1)";
      buttonElement.style.opacity = "1";
      buttonElement.title = "Click to close pop-out";
    } else {
      buttonElement.style.color = "";
      buttonElement.style.transform = "";
      buttonElement.style.opacity = "";
      buttonElement.title = "Click to open in pop-out";
    }
  }
  function openTabInPopout(deps, tabName) {
    const { UnifiedState: UnifiedState3, createInGameOverlay: createInGameOverlay2, openTabInSeparateWindow: openTabInSeparateWindow2 } = deps;
    if (UnifiedState3.data.settings.useInGameOverlays) {
      return createInGameOverlay2(deps, tabName);
    } else {
      return openTabInSeparateWindow2(deps, tabName);
    }
  }
  function refreshSeparateWindowPopouts(deps, tabName) {
    const { UnifiedState: UnifiedState3, productionLog: productionLog3, productionWarn: productionWarn3, debugError: debugError2, updateActivePetsFromRoomState: updateActivePetsFromRoomState2 } = deps;
    try {
      UnifiedState3.data.popouts.windows.forEach((windowRef, popoutTabName) => {
        if (windowRef && !windowRef.closed && popoutTabName === tabName) {
          if (tabName === "pets") {
            updateActivePetsFromRoomState2();
          }
          if (windowRef.refreshPopoutContent) {
            windowRef.refreshPopoutContent(tabName);
            productionLog3(`\u{1F504} [POPOUT] Refreshed ${tabName} window popout`);
          } else if (windowRef.location) {
            productionWarn3(`\u26A0\uFE0F [POPOUT] No refresh function for ${tabName}, reloading window`);
            windowRef.location.reload();
          }
        }
      });
    } catch (error) {
      debugError2("OVERLAY_LIFECYCLE", "Failed to refresh separate window popouts", error, { tabName });
    }
  }
  function closeAllPopouts(deps) {
    const { targetDocument: targetDocument2, UnifiedState: UnifiedState3 } = deps;
    targetDocument2.querySelectorAll(".mga-overlay").forEach((overlay) => {
      overlay.style.display = "none";
    });
    UnifiedState3.popoutWindows.forEach((window2) => {
      try {
        window2.close();
      } catch (e) {
      }
    });
    UnifiedState3.popoutWindows.clear();
  }
  function getPetsPopoutContent(deps) {
    const { UnifiedState: UnifiedState3, calculateTimeUntilHungry: calculateTimeUntilHungry2, formatHungerTimer: formatHungerTimer2, ensurePresetOrder: ensurePresetOrder2 } = deps;
    const activePets = UnifiedState3.atoms.activePets || window.activePets || [];
    const petPresets = UnifiedState3.data.petPresets;
    if (Object.keys(petPresets).length === 0) {
      return `
            <div class="mga-section">
                <div class="mga-section-title mga-pet-section-title">Active Pets</div>
                <div class="mga-active-pets-display">
                    ${activePets.length > 0 ? `
                        <div style="color: #93c5fd; font-size: 12px; margin-bottom: 4px;">Currently Equipped:</div>
                        <div class="mga-active-pets-list">
                            ${activePets.map((p, index) => {
        const timeUntilHungry = calculateTimeUntilHungry2(p);
        const timerText = formatHungerTimer2(timeUntilHungry);
        const timerColor = timeUntilHungry === null ? "#999" : timeUntilHungry <= 0 ? "#8B0000" : timeUntilHungry < 5 * 60 * 1e3 ? "#ff4444" : timeUntilHungry < 15 * 60 * 1e3 ? "#ffa500" : "#4caf50";
        return `
                                    <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                        <span class="mga-pet-badge">${p.petSpecies}</span>
                                        <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                    </div>
                                `;
      }).join("")}
                        </div>
                    ` : `
                        <div class="mga-empty-state">
                            <div class="mga-empty-state-icon">\u2014</div>
                            <div class="mga-empty-state-description">No pets currently active</div>
                        </div>
                    `}
                </div>
            </div>
            <div class="mga-section">
                <div class="mga-empty-state" style="padding: 40px 20px;">
                    <div class="mga-empty-state-icon">\u{1F4CB}</div>
                    <div class="mga-empty-state-title">No Saved Presets</div>
                    <div class="mga-empty-state-description">
                        You haven't saved any pet loadout presets yet.<br>
                        Open the main HUD Pets tab to create presets from your current active pets.
                    </div>
                </div>
            </div>
        `;
    }
    let html = `
        <div class="mga-section">
            <div class="mga-section-title mga-pet-section-title">Active Pets</div>
            <div class="mga-active-pets-display">
                ${activePets.length > 0 ? `
                    <div class="mga-active-pets-header">Currently Equipped:</div>
                    <div class="mga-active-pets-list">
                        ${activePets.map((p, index) => {
      const timeUntilHungry = calculateTimeUntilHungry2(p);
      const timerText = formatHungerTimer2(timeUntilHungry);
      const timerColor = timeUntilHungry === null ? "#999" : timeUntilHungry <= 0 ? "#8B0000" : timeUntilHungry < 5 * 60 * 1e3 ? "#ff4444" : timeUntilHungry < 15 * 60 * 1e3 ? "#ffa500" : "#4caf50";
      return `
                                <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                    <span class="mga-pet-badge">${p.petSpecies}</span>
                                    <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                </div>
                            `;
    }).join("")}
                    </div>
                ` : `
                    <div class="mga-empty-state">
                        <div class="mga-empty-state-icon">\u2014</div>
                        <div class="mga-empty-state-description">No pets currently active</div>
                    </div>
                `}
            </div>
        </div>

        <div class="mga-section">
            <div class="mga-section-title">Load Pet Preset</div>
    `;
    ensurePresetOrder2();
    UnifiedState3.data.petPresetsOrder.forEach((name) => {
      if (petPresets[name]) {
        const pets = petPresets[name];
        const petList = pets.map((p) => p.petSpecies).join(", ");
        html += `
                <div class="mga-preset mga-preset-clickable" data-preset="${name}">
                    <div class="mga-preset-header">
                        <span class="mga-preset-name">${name}</span>
                    </div>
                    <div class="mga-preset-pets">${petList}</div>
                </div>
            `;
      }
    });
    html += `</div>`;
    return html;
  }
  function setupPetPopoutHandlers(deps, context = document) {
    const {
      UnifiedState: UnifiedState3,
      productionLog: productionLog3,
      productionWarn: productionWarn3,
      safeSendMessage: safeSendMessage2,
      updateActivePetsFromRoomState: updateActivePetsFromRoomState2,
      refreshSeparateWindowPopouts: refreshSeparateWindowPopouts2,
      updatePureOverlayContent: updatePureOverlayContent2,
      updateTabContent
    } = deps;
    const cards = context.querySelectorAll(".mga-preset-clickable[data-preset]");
    cards.forEach((presetCard, index) => {
      const newCard = presetCard.cloneNode(true);
      presetCard.parentNode.replaceChild(newCard, presetCard);
      newCard.addEventListener("click", (e) => {
        const presetName = e.currentTarget.dataset.preset;
        if (!presetName || !UnifiedState3.data.petPresets[presetName]) {
          productionWarn3("\u26A0\uFE0F Preset not found!");
          return;
        }
        const preset = UnifiedState3.data.petPresets[presetName];
        const maxSlots = 3;
        let delay = 0;
        for (let slotIndex = 0; slotIndex < maxSlots; slotIndex++) {
          const desiredPet = preset[slotIndex];
          ((currentDelay, slot) => {
            setTimeout(() => {
              const currentPets = UnifiedState3.atoms.activePets || window.activePets || [];
              const currentPet = currentPets[slot];
              if (currentPet && desiredPet) {
                if (currentPet.id === desiredPet.id) {
                  if (UnifiedState3.data.settings?.debugMode) {
                    productionLog3(`[PET-SWAP] Slot ${slot + 1}: Already equipped (${currentPet.id}), skipping`);
                  }
                  return;
                }
                if (UnifiedState3.data.settings?.debugMode) {
                  productionLog3(`[PET-SWAP] Slot ${slot + 1}: Swapping ${currentPet.id} \u2192 ${desiredPet.id}`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "SwapPet",
                  petSlotId: currentPet.id,
                  petInventoryId: desiredPet.id
                });
              } else if (!currentPet && desiredPet) {
                if (UnifiedState3.data.settings?.debugMode) {
                  productionLog3(`[PET-SWAP] Slot ${slot + 1}: Placing ${desiredPet.id} (empty slot)`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "PlacePet",
                  itemId: desiredPet.id,
                  position: { x: 17 + slot * 2, y: 13 },
                  localTileIndex: 64,
                  tileType: "Boardwalk"
                });
              } else if (currentPet && !desiredPet) {
                if (UnifiedState3.data.settings?.debugMode) {
                  productionLog3(`[PET-SWAP] Slot ${slot + 1}: Storing ${currentPet.id} (no preset pet)`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "StorePet",
                  itemId: currentPet.id
                });
              }
            }, currentDelay);
          })(delay, slotIndex);
          delay += 200;
        }
        const refreshPetDisplays = () => {
          updateActivePetsFromRoomState2();
          const contextDoc = context.ownerDocument || context;
          const contextWindow = contextDoc.defaultView || window;
          const isSeparateWindow = contextWindow !== window && contextWindow.refreshPopoutContent;
          if (isSeparateWindow) {
            contextWindow.refreshPopoutContent("pets");
          } else {
            refreshSeparateWindowPopouts2(deps, "pets");
            UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === "pets") {
                if (overlay.className.includes("mga-overlay-content-only")) {
                  updatePureOverlayContent2(deps, overlay, tabName);
                }
              }
            });
            if (UnifiedState3.activeTab === "pets") {
              updateTabContent();
            }
          }
        };
        setTimeout(refreshPetDisplays, delay + 200);
        productionLog3(`\u{1F43E} Loading pet preset: ${presetName}`);
      });
    });
  }
  var tabContentCache = /* @__PURE__ */ new Map();
  var TAB_CACHE_DURATION = 3e4;
  var DYNAMIC_TABS = [
    "pets",
    "abilities",
    "seeds",
    "shop",
    "values",
    "timers",
    "rooms",
    "hotkeys",
    "settings",
    "notifications",
    "protect"
  ];
  function getCachedTabContent(deps, tabName, generator) {
    if (DYNAMIC_TABS.includes(tabName)) {
      return generator();
    }
    const cached = tabContentCache.get(tabName);
    const now = Date.now();
    if (cached && now - cached.timestamp < TAB_CACHE_DURATION) {
      return cached.content;
    }
    const content = generator();
    tabContentCache.set(tabName, { content, timestamp: now });
    return content;
  }
  function invalidateTabCache(deps, tabName = null) {
    if (tabName) {
      tabContentCache.delete(tabName);
    } else {
      tabContentCache.clear();
    }
  }
  function getTabCacheStats(deps) {
    return {
      size: tabContentCache.size,
      entries: Array.from(tabContentCache.keys()),
      duration: TAB_CACHE_DURATION
    };
  }

  // src/ui/theme-system.js
  var theme_system_exports = {};
  __export(theme_system_exports, {
    applyAccentToDock: () => applyAccentToDock,
    applyAccentToSidebar: () => applyAccentToSidebar,
    applyDynamicScaling: () => applyDynamicScaling,
    applyThemeToDock: () => applyThemeToDock,
    applyThemeToElement: () => applyThemeToElement,
    applyThemeToPopoutWidget: () => applyThemeToPopoutWidget,
    applyThemeToSidebar: () => applyThemeToSidebar,
    applyUltraCompactMode: () => applyUltraCompactMode,
    calculateScale: () => calculateScale,
    generateThemeStyles: () => generateThemeStyles,
    getAccentColorForTheme: () => getAccentColorForTheme,
    updateTabResponsiveness: () => updateTabResponsiveness
  });
  function generateThemeStyles(deps, settings, isPopout = false) {
    const opacity = isPopout ? settings.popoutOpacity / 100 : settings.opacity / 100;
    const effectiveOpacity = opacity;
    const gradients = {
      // ⚫ BLACK ACCENT THEMES (Solid backgrounds with vibrant accent colors)
      "black-crimson": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(26, 0, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-emerald": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 26, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-royal": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(13, 0, 21, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-gold": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(26, 20, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-ice": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 13, 26, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-flame": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(26, 13, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-toxic": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(10, 26, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-pink": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(26, 0, 20, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-matrix": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 17, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-sunset": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(26, 10, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-blood": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(40, 0, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-neon": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 20, 30, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-storm": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(10, 0, 30, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-sapphire": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 10, 40, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-aqua": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 25, 25, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-phantom": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(20, 20, 20, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-void": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(10, 10, 10, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-violet": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(20, 0, 30, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-amber": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(30, 22, 0, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-jade": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 20, 15, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-coral": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(30, 15, 10, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-steel": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(10, 20, 25, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-lavender": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(20, 15, 25, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-mint": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(5, 20, 15, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-ruby": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(30, 0, 10, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-cobalt": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 10, 25, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-bronze": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(25, 15, 8, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-teal": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(0, 18, 18, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-magenta": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(25, 0, 25, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-lime": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(8, 25, 8, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      "black-indigo": "linear-gradient(135deg, rgba(0, 0, 0, " + effectiveOpacity + ") 0%, rgba(10, 0, 20, " + effectiveOpacity + ") 50%, rgba(0, 0, 0, " + effectiveOpacity + ") 100%)",
      // 🌈 ORIGINAL THEMES
      "blue-purple": "linear-gradient(135deg, rgba(20, 20, 35, " + effectiveOpacity + ") 0%, rgba(30, 30, 50, " + effectiveOpacity + ") 100%)",
      "green-blue": "linear-gradient(135deg, rgba(20, 35, 20, " + effectiveOpacity + ") 0%, rgba(30, 40, 60, " + effectiveOpacity + ") 100%)",
      "red-orange": "linear-gradient(135deg, rgba(35, 20, 20, " + effectiveOpacity + ") 0%, rgba(50, 35, 30, " + effectiveOpacity + ") 100%)",
      "purple-pink": "linear-gradient(135deg, rgba(35, 20, 35, " + effectiveOpacity + ") 0%, rgba(50, 30, 45, " + effectiveOpacity + ") 100%)",
      "gold-yellow": "linear-gradient(135deg, rgba(35, 30, 20, " + effectiveOpacity + ") 0%, rgba(45, 40, 25, " + effectiveOpacity + ") 100%)",
      // New vibrant gradients - using effectiveOpacity for better high-level opacity
      "electric-neon": "linear-gradient(135deg, rgba(0, 100, 255, " + effectiveOpacity * 0.3 + ") 0%, rgba(147, 51, 234, " + effectiveOpacity * 0.4 + ") 100%)",
      "sunset-fire": "linear-gradient(135deg, rgba(255, 94, 77, " + effectiveOpacity * 0.3 + ") 0%, rgba(255, 154, 0, " + effectiveOpacity * 0.4 + ") 100%)",
      "emerald-cyan": "linear-gradient(135deg, rgba(16, 185, 129, " + effectiveOpacity * 0.3 + ") 0%, rgba(6, 182, 212, " + effectiveOpacity * 0.4 + ") 100%)",
      "royal-gold": "linear-gradient(135deg, rgba(139, 69, 19, " + effectiveOpacity * 0.4 + ") 0%, rgba(255, 215, 0, " + effectiveOpacity * 0.3 + ") 100%)",
      "crimson-blaze": "linear-gradient(135deg, rgba(220, 38, 127, " + effectiveOpacity * 0.3 + ") 0%, rgba(249, 115, 22, " + effectiveOpacity * 0.4 + ") 100%)",
      "ocean-deep": "linear-gradient(135deg, rgba(15, 23, 42, " + effectiveOpacity * 0.8 + ") 0%, rgba(30, 64, 175, " + effectiveOpacity * 0.6 + ") 100%)",
      "forest-mystique": "linear-gradient(135deg, rgba(20, 83, 45, " + effectiveOpacity * 0.6 + ") 0%, rgba(34, 197, 94, " + effectiveOpacity * 0.4 + ") 100%)",
      "cosmic-purple": "linear-gradient(135deg, rgba(88, 28, 135, " + effectiveOpacity * 0.6 + ") 0%, rgba(168, 85, 247, " + effectiveOpacity * 0.4 + ") 100%)",
      "rainbow-burst": "linear-gradient(135deg, rgba(239, 68, 68, " + effectiveOpacity * 0.25 + ") 0%, rgba(245, 158, 11, " + effectiveOpacity * 0.25 + ") 25%, rgba(34, 197, 94, " + effectiveOpacity * 0.25 + ") 50%, rgba(59, 130, 246, " + effectiveOpacity * 0.25 + ") 75%, rgba(147, 51, 234, " + effectiveOpacity * 0.25 + ") 100%)",
      // Premium metallic themes - FIXED for visibility with darker, richer tones
      "steel-blue": "linear-gradient(135deg, rgba(30, 41, 59, " + effectiveOpacity * 0.95 + ") 0%, rgba(51, 65, 85, " + effectiveOpacity * 0.9 + ") 25%, rgba(71, 85, 105, " + effectiveOpacity * 0.85 + ") 50%, rgba(30, 58, 138, " + effectiveOpacity * 0.8 + ") 100%)",
      "chrome-silver": "linear-gradient(135deg, rgba(55, 65, 81, " + effectiveOpacity * 0.9 + ") 0%, rgba(75, 85, 99, " + effectiveOpacity * 0.85 + ") 25%, rgba(100, 116, 139, " + effectiveOpacity * 0.8 + ") 50%, rgba(71, 85, 105, " + effectiveOpacity * 0.9 + ") 100%)",
      "titanium-gray": "linear-gradient(135deg, rgba(31, 41, 55, " + effectiveOpacity * 0.95 + ") 0%, rgba(55, 65, 81, " + effectiveOpacity * 0.9 + ") 25%, rgba(75, 85, 99, " + effectiveOpacity * 0.85 + ") 50%, rgba(107, 114, 128, " + effectiveOpacity * 0.8 + ") 100%)",
      "platinum-white": "linear-gradient(135deg, rgba(75, 85, 99, " + effectiveOpacity * 0.85 + ") 0%, rgba(100, 116, 139, " + effectiveOpacity * 0.8 + ") 25%, rgba(148, 163, 184, " + effectiveOpacity * 0.75 + ") 50%, rgba(156, 163, 175, " + effectiveOpacity * 0.7 + ") 100%)"
    };
    const background = gradients[settings.gradientStyle] || gradients["blue-purple"];
    let boxShadow = "0 10px 40px rgba(0, 0, 0, 0.5)";
    let borderShadow = "";
    switch (settings.effectStyle) {
      case "metallic":
        boxShadow = `
                0 10px 40px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.57),
                inset 0 -1px 0 rgba(0, 0, 0, 0.48)
            `;
        break;
      case "neon":
        borderShadow = `0 0 20px rgba(74, 158, 255, ${effectiveOpacity * 0.6})`;
        boxShadow = `
                0 10px 40px rgba(0, 0, 0, 0.5),
                ${borderShadow}
            `;
        break;
      case "plasma":
        borderShadow = `0 0 30px rgba(147, 51, 234, ${effectiveOpacity * 0.5})`;
        boxShadow = `
                0 10px 40px rgba(0, 0, 0, 0.5),
                ${borderShadow}
            `;
        break;
      case "holographic":
        boxShadow = `
                0 10px 40px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(255, 255, 255, ${effectiveOpacity * 0.1}),
                inset 0 1px 0 rgba(255, 255, 255, 0.73)
            `;
        break;
      case "crystal":
        boxShadow = `
                0 10px 40px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 255, 255, ${effectiveOpacity * 0.1}),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.30)
            `;
        break;
    }
    const accentColors = {
      "black-void": { color: "#1a1a1a", glow: "rgba(26, 26, 26, 0.3)", text: "#2a2a2a" },
      "black-crimson": { color: "#DC143C", glow: "rgba(220, 20, 60, 0.5)", text: "#FF6B6B" },
      "black-emerald": { color: "#50C878", glow: "rgba(80, 200, 120, 0.5)", text: "#90EE90" },
      "black-royal": { color: "#9D4EDD", glow: "rgba(157, 78, 221, 0.5)", text: "#DDA0DD" },
      "black-gold": { color: "#FFD700", glow: "rgba(255, 215, 0, 0.5)", text: "#FFD700" },
      "black-ice": { color: "#00FFFF", glow: "rgba(0, 255, 255, 0.5)", text: "#B0E0E6" },
      "black-flame": { color: "#FF4500", glow: "rgba(255, 69, 0, 0.5)", text: "#FF7F50" },
      "black-toxic": { color: "#7FFF00", glow: "rgba(127, 255, 0, 0.5)", text: "#9ACD32" },
      "black-pink": { color: "#FF1493", glow: "rgba(255, 20, 147, 0.5)", text: "#FFB6C1" },
      "black-matrix": { color: "#00FF00", glow: "rgba(0, 255, 0, 0.8)", text: "#00FF00" },
      "black-sunset": { color: "#FF6B35", glow: "rgba(255, 107, 53, 0.6)", text: "#FFA500" },
      "black-blood": { color: "#8B0000", glow: "rgba(139, 0, 0, 0.7)", text: "#CD5C5C" },
      "black-neon": { color: "#00CED1", glow: "rgba(0, 206, 209, 0.8)", text: "#AFEEEE" },
      "black-storm": { color: "#483D8B", glow: "rgba(72, 61, 139, 0.6)", text: "#9370DB" },
      "black-sapphire": { color: "#0F52BA", glow: "rgba(15, 82, 186, 0.7)", text: "#4169E1" },
      "black-aqua": { color: "#008B8B", glow: "rgba(0, 139, 139, 0.6)", text: "#48D1CC" },
      "black-phantom": { color: "#C0C0C0", glow: "rgba(192, 192, 192, 0.4)", text: "#DCDCDC" },
      "black-violet": { color: "#8A2BE2", glow: "rgba(138, 43, 226, 0.6)", text: "#9370DB" },
      "black-amber": { color: "#FFBF00", glow: "rgba(255, 191, 0, 0.5)", text: "#FFC125" },
      "black-jade": { color: "#00A86B", glow: "rgba(0, 168, 107, 0.6)", text: "#5FD3A6" },
      "black-coral": { color: "#FF7F50", glow: "rgba(255, 127, 80, 0.5)", text: "#FFA07A" },
      "black-steel": { color: "#4682B4", glow: "rgba(70, 130, 180, 0.5)", text: "#87CEEB" },
      "black-lavender": { color: "#B57EDC", glow: "rgba(181, 126, 220, 0.5)", text: "#DDA0DD" },
      "black-mint": { color: "#3EB489", glow: "rgba(62, 180, 137, 0.6)", text: "#98FB98" },
      "black-ruby": { color: "#E0115F", glow: "rgba(224, 17, 95, 0.6)", text: "#FF1493" },
      "black-cobalt": { color: "#0047AB", glow: "rgba(0, 71, 171, 0.7)", text: "#4169E1" },
      "black-bronze": { color: "#CD7F32", glow: "rgba(205, 127, 50, 0.6)", text: "#D2691E" },
      "black-teal": { color: "#008080", glow: "rgba(0, 128, 128, 0.6)", text: "#20B2AA" },
      "black-magenta": { color: "#FF00FF", glow: "rgba(255, 0, 255, 0.6)", text: "#FF69B4" },
      "black-lime": { color: "#32CD32", glow: "rgba(50, 205, 50, 0.6)", text: "#7FFF00" },
      "black-indigo": { color: "#4B0082", glow: "rgba(75, 0, 130, 0.6)", text: "#8B00FF" }
    };
    const accent = accentColors[settings.gradientStyle] || null;
    const textures = {
      none: "",
      // ===== MODERN GLASS (Apple iOS Glassmorphism) =====
      "frosted-glass": `
            radial-gradient(circle at 35% 35%, rgba(74, 158, 255, 0.25), transparent 60%),
            radial-gradient(circle at 65% 65%, rgba(0, 217, 255, 0.20), transparent 55%),
            radial-gradient(circle at 20% 80%, rgba(147, 197, 253, 0.18), transparent 45%),
            url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E"),
            linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(200, 230, 255, 0.08))
        `,
      "crystal-prism": `
            linear-gradient(45deg, rgba(74, 158, 255, 0.35) 0%, transparent 50%, rgba(147, 51, 234, 0.28) 100%),
            linear-gradient(-45deg, transparent 0%, rgba(0, 217, 255, 0.30) 50%, transparent 100%),
            radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25), transparent 60%),
            radial-gradient(circle at 30% 70%, rgba(139, 92, 246, 0.18), transparent 50%)
        `,
      "ice-frost": `
            radial-gradient(circle at 20% 30%, rgba(147, 197, 253, 0.40) 0%, transparent 4%),
            radial-gradient(circle at 60% 70%, rgba(191, 219, 254, 0.35) 0%, transparent 5%),
            radial-gradient(circle at 80% 20%, rgba(224, 242, 254, 0.38) 0%, transparent 3%),
            radial-gradient(circle at 40% 50%, rgba(59, 130, 246, 0.22) 0%, transparent 8%),
            linear-gradient(to bottom, rgba(219, 234, 254, 0.15), rgba(147, 197, 253, 0.08))
        `,
      "smoke-flow": `
            radial-gradient(ellipse at 0% 0%, rgba(96, 165, 250, 0.35), transparent 55%),
            radial-gradient(ellipse at 100% 100%, rgba(147, 197, 253, 0.28), transparent 60%),
            radial-gradient(ellipse at 50% 50%, rgba(191, 219, 254, 0.25), transparent 45%),
            radial-gradient(ellipse at 30% 70%, rgba(59, 130, 246, 0.18), transparent 50%)
        `,
      "water-ripple": `
            radial-gradient(circle, rgba(6, 182, 212, 0.30) 3px, transparent 3px),
            radial-gradient(circle, rgba(34, 211, 238, 0.25) 2px, transparent 2px),
            radial-gradient(circle, rgba(103, 232, 249, 0.18) 1.5px, transparent 1.5px),
            linear-gradient(to bottom, rgba(165, 243, 252, 0.12), rgba(6, 182, 212, 0.08))
        `,
      // ===== PREMIUM MATERIALS (Photorealistic Luxury) =====
      "carbon-fiber-pro": `
            repeating-linear-gradient(0deg,
                rgba(59, 130, 246, 0.15) 0px,
                rgba(147, 51, 234, 0.35) 1px,
                rgba(99, 102, 241, 0.28) 2px,
                rgba(139, 92, 246, 0.12) 3px,
                transparent 4px),
            repeating-linear-gradient(90deg,
                rgba(30, 58, 138, 0.18) 0px,
                rgba(67, 56, 202, 0.32) 1px,
                rgba(79, 70, 229, 0.25) 2px,
                rgba(99, 102, 241, 0.15) 3px,
                transparent 4px),
            linear-gradient(135deg, rgba(30, 27, 75, 0.20), rgba(67, 56, 202, 0.10))
        `,
      "brushed-aluminum": `
            repeating-linear-gradient(90deg,
                rgba(226, 232, 240, 0.35) 0px,
                rgba(203, 213, 225, 0.45) 0.5px,
                rgba(226, 232, 240, 0.38) 1px,
                rgba(241, 245, 249, 0.28) 1.5px,
                rgba(203, 213, 225, 0.32) 2px),
            linear-gradient(180deg, rgba(248, 250, 252, 0.18), rgba(226, 232, 240, 0.25)),
            radial-gradient(circle at 50% 0%, rgba(255, 255, 255, 0.15), transparent 60%)
        `,
      "brushed-titanium": `
            repeating-linear-gradient(45deg,
                rgba(251, 191, 36, 0.30) 0px,
                rgba(217, 119, 6, 0.40) 1px,
                rgba(245, 158, 11, 0.35) 2px,
                rgba(251, 191, 36, 0.25) 3px),
            linear-gradient(135deg, rgba(217, 119, 6, 0.18), rgba(251, 191, 36, 0.12)),
            radial-gradient(circle at 40% 40%, rgba(252, 211, 77, 0.20), transparent 55%)
        `,
      "leather-grain": `
            url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='turbulence'%3E%3CfeTurbulence type='turbulence' baseFrequency='2.2' numOctaves='3'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23turbulence)' opacity='0.28'/%3E%3C/svg%3E"),
            radial-gradient(circle at 60% 40%, rgba(127, 29, 29, 0.35), transparent 65%),
            radial-gradient(circle at 30% 70%, rgba(153, 27, 27, 0.28), transparent 60%),
            linear-gradient(135deg, rgba(185, 28, 28, 0.22), rgba(127, 29, 29, 0.18))
        `,
      "fabric-weave": `
            repeating-linear-gradient(0deg, rgba(148, 163, 184, 0.35) 0px, transparent 1px, transparent 3px),
            repeating-linear-gradient(90deg, rgba(148, 163, 184, 0.35) 0px, transparent 1px, transparent 3px),
            linear-gradient(45deg, rgba(203, 213, 225, 0.15) 25%, transparent 25%, transparent 75%, rgba(203, 213, 225, 0.15) 75%),
            linear-gradient(45deg, rgba(226, 232, 240, 0.12), rgba(203, 213, 225, 0.08))
        `,
      "wood-grain": `
            linear-gradient(90deg,
                rgba(217, 119, 6, 0.28) 0%,
                rgba(251, 146, 60, 0.35) 8%,
                rgba(217, 119, 6, 0.25) 16%,
                rgba(234, 88, 12, 0.32) 24%,
                rgba(251, 146, 60, 0.28) 32%,
                rgba(217, 119, 6, 0.30) 40%),
            repeating-linear-gradient(90deg, transparent 0px, rgba(180, 83, 9, 0.18) 1px, transparent 2px),
            linear-gradient(180deg, rgba(251, 191, 36, 0.15), rgba(217, 119, 6, 0.10))
        `,
      // ===== TECH/FUTURISTIC (Cyberpunk Neon) =====
      "circuit-board": `
            linear-gradient(rgba(34, 197, 94, 0.32) 1px, transparent 1px),
            linear-gradient(90deg, rgba(34, 197, 94, 0.32) 1px, transparent 1px),
            linear-gradient(rgba(16, 185, 129, 0.25) 2px, transparent 2px),
            linear-gradient(90deg, rgba(16, 185, 129, 0.25) 2px, transparent 2px),
            radial-gradient(circle at 25% 25%, rgba(52, 211, 153, 0.20), transparent 15%),
            radial-gradient(circle at 75% 75%, rgba(16, 185, 129, 0.18), transparent 15%),
            linear-gradient(135deg, rgba(6, 78, 59, 0.15), rgba(20, 83, 45, 0.10))
        `,
      "hexagon-grid-pro": `
            repeating-linear-gradient(0deg, transparent, transparent 22px, rgba(6, 182, 212, 0.38) 22px, rgba(14, 165, 233, 0.38) 23px),
            repeating-linear-gradient(60deg, transparent, transparent 22px, rgba(34, 211, 238, 0.32) 22px, rgba(6, 182, 212, 0.32) 23px),
            repeating-linear-gradient(120deg, transparent, transparent 22px, rgba(56, 189, 248, 0.32) 22px, rgba(14, 165, 233, 0.32) 23px),
            radial-gradient(circle at 50% 50%, rgba(125, 211, 252, 0.18), transparent 50%)
        `,
      "hologram-scan": `
            repeating-linear-gradient(0deg,
                transparent 0px,
                rgba(6, 182, 212, 0.22) 1px,
                rgba(236, 72, 153, 0.32) 2px,
                rgba(6, 182, 212, 0.22) 3px,
                transparent 4px),
            linear-gradient(90deg, rgba(236, 72, 153, 0.15), rgba(6, 182, 212, 0.15), rgba(236, 72, 153, 0.15)),
            radial-gradient(circle at 50% 50%, rgba(236, 72, 153, 0.18), transparent 60%)
        `,
      "matrix-rain": `
            linear-gradient(rgba(34, 197, 94, 0.35) 2px, transparent 2px),
            linear-gradient(90deg, rgba(16, 185, 129, 0.28) 1px, transparent 1px),
            radial-gradient(circle at 30% 40%, rgba(52, 211, 153, 0.20), transparent 50%),
            linear-gradient(180deg, rgba(34, 197, 94, 0.12), rgba(6, 78, 59, 0.08))
        `,
      "energy-waves": `
            radial-gradient(ellipse at 50% 0%, rgba(59, 130, 246, 0.40), transparent 45%),
            radial-gradient(ellipse at 50% 100%, rgba(96, 165, 250, 0.38), transparent 45%),
            radial-gradient(ellipse at 50% 50%, rgba(147, 197, 253, 0.28), transparent 35%),
            radial-gradient(ellipse at 0% 50%, rgba(29, 78, 216, 0.22), transparent 40%),
            radial-gradient(ellipse at 100% 50%, rgba(37, 99, 235, 0.22), transparent 40%)
        `,
      "cyberpunk-grid": `
            linear-gradient(rgba(236, 72, 153, 0.35) 1px, transparent 1px),
            linear-gradient(90deg, rgba(6, 182, 212, 0.35) 1px, transparent 1px),
            radial-gradient(circle at 50% 50%, rgba(168, 85, 247, 0.25), transparent 65%),
            linear-gradient(135deg, rgba(236, 72, 153, 0.12), rgba(6, 182, 212, 0.12))
        `,
      // ===== GEOMETRIC CLEAN (Swiss Design) =====
      "dots-pro": `
            radial-gradient(circle, rgba(100, 116, 139, 0.40) 2px, transparent 2px),
            radial-gradient(circle, rgba(148, 163, 184, 0.20) 1px, transparent 1px),
            linear-gradient(to bottom right, rgba(203, 213, 225, 0.10), rgba(148, 163, 184, 0.08))
        `,
      "grid-pro": `
            linear-gradient(rgba(100, 116, 139, 0.35) 1px, transparent 1px),
            linear-gradient(90deg, rgba(100, 116, 139, 0.35) 1px, transparent 1px),
            linear-gradient(rgba(148, 163, 184, 0.15) 1px, transparent 1px),
            linear-gradient(90deg, rgba(148, 163, 184, 0.15) 1px, transparent 1px)
        `,
      "diagonal-pro": `
            repeating-linear-gradient(45deg,
                transparent,
                transparent 18px,
                rgba(100, 116, 139, 0.32) 18px,
                rgba(148, 163, 184, 0.28) 19px,
                transparent 20px),
            linear-gradient(135deg, rgba(203, 213, 225, 0.10), rgba(148, 163, 184, 0.05))
        `,
      waves: `
            repeating-radial-gradient(circle at 50% 50%,
                transparent 0px,
                rgba(100, 116, 139, 0.30) 12px,
                transparent 24px),
            radial-gradient(circle at 50% 50%, rgba(148, 163, 184, 0.18), transparent 60%)
        `,
      triangles: `
            linear-gradient(45deg, rgba(100, 116, 139, 0.35) 25%, transparent 25%),
            linear-gradient(-45deg, rgba(100, 116, 139, 0.35) 25%, transparent 25%),
            linear-gradient(45deg, transparent 75%, rgba(148, 163, 184, 0.28) 75%),
            linear-gradient(-45deg, transparent 75%, rgba(148, 163, 184, 0.28) 75%)
        `,
      crosshatch: `
            repeating-linear-gradient(0deg, transparent, transparent 4px, rgba(100, 116, 139, 0.32) 4px, rgba(100, 116, 139, 0.32) 5px),
            repeating-linear-gradient(90deg, transparent, transparent 4px, rgba(148, 163, 184, 0.28) 4px, rgba(148, 163, 184, 0.28) 5px)
        `,
      // ===== SPECIAL EFFECTS (Atmospheric) =====
      "perlin-noise": `
            url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='perlin'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='5' stitchTiles='stitch'/%3E%3CfeColorMatrix values='0.3 0 0 0 0.4, 0 0.4 0 0 0.5, 0 0 0.5 0 0.6, 0 0 0 0.35 0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23perlin)'/%3E%3C/svg%3E"),
            radial-gradient(circle at 50% 50%, rgba(147, 51, 234, 0.15), transparent 70%)
        `,
      "gradient-mesh": `
            radial-gradient(circle at 25% 25%, rgba(139, 92, 246, 0.35), transparent 55%),
            radial-gradient(circle at 75% 25%, rgba(59, 130, 246, 0.32), transparent 55%),
            radial-gradient(circle at 25% 75%, rgba(236, 72, 153, 0.30), transparent 55%),
            radial-gradient(circle at 75% 75%, rgba(6, 182, 212, 0.28), transparent 55%),
            linear-gradient(135deg, rgba(167, 139, 250, 0.12), rgba(96, 165, 250, 0.12))
        `
    };
    const textureBackgroundSize = {
      "frosted-glass": "100% 100%, 100% 100%, 100% 100%, cover, 100% 100%",
      "crystal-prism": "100% 100%, 100% 100%, 100% 100%, 100% 100%",
      "ice-frost": "100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%",
      "smoke-flow": "100% 100%, 100% 100%, 100% 100%, 100% 100%",
      "water-ripple": "30px 30px, 50px 50px, 40px 40px, 100% 100%",
      "carbon-fiber-pro": "6px 6px, 6px 6px, 100% 100%",
      "brushed-aluminum": "2px 100%, 100% 100%, 100% 100%",
      "brushed-titanium": "3px 3px, 100% 100%, 100% 100%",
      "leather-grain": "cover, 100% 100%, 100% 100%, 100% 100%",
      "fabric-weave": "4px 4px, 4px 4px, 30px 30px, 100% 100%",
      "wood-grain": "100% 40px, 100% 2px, 100% 100%",
      "circuit-board": "40px 40px, 40px 40px, 120px 120px, 120px 120px, 100% 100%, 100% 100%, 100% 100%",
      "hexagon-grid-pro": "100% 100%, 100% 100%, 100% 100%, 100% 100%",
      "hologram-scan": "100% 5px, 100% 100%, 100% 100%",
      "matrix-rain": "2px 20px, 10px 10px, 100% 100%, 100% 100%",
      "energy-waves": "100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%",
      "cyberpunk-grid": "50px 50px, 50px 50px, 100% 100%, 100% 100%",
      "dots-pro": "25px 25px, 20px 20px, 100% 100%",
      "grid-pro": "30px 30px, 30px 30px, 60px 60px, 60px 60px",
      "diagonal-pro": "100% 100%, 100% 100%",
      waves: "100% 100%, 100% 100%",
      triangles: "30px 30px, 30px 30px, 30px 30px, 30px 30px",
      crosshatch: "100% 100%, 100% 100%",
      "perlin-noise": "cover, 100% 100%",
      "gradient-mesh": "100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%"
    };
    const textureStyle = settings.textureStyle || "none";
    let texturePattern = textures[textureStyle] || "";
    let textureBgSize = textureBackgroundSize[textureStyle] || "auto";
    const textureIntensity = settings.textureIntensity !== void 0 ? settings.textureIntensity : 75;
    const intensityMultiplier = textureIntensity / 100;
    if (texturePattern && intensityMultiplier !== 1) {
      texturePattern = texturePattern.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/g, (match, r, g, b, a) => {
        const newAlpha = Math.min(1, parseFloat(a) * intensityMultiplier);
        return `rgba(${r}, ${g}, ${b}, ${newAlpha.toFixed(3)})`;
      });
      texturePattern = texturePattern.replace(/opacity='([0-9.]+)'/g, (match, a) => {
        const newAlpha = Math.min(1, parseFloat(a) * intensityMultiplier);
        return `opacity='${newAlpha.toFixed(2)}'`;
      });
    }
    const textureScale = settings.textureScale || "medium";
    const scaleMultipliers = { small: 0.5, medium: 1, large: 2 };
    const scaleMultiplier = scaleMultipliers[textureScale];
    if (textureBgSize !== "cover" && textureBgSize !== "auto" && scaleMultiplier !== 1) {
      textureBgSize = textureBgSize.replace(/(\d+)(px|%)/g, (match, value, unit) => {
        const scaled = Math.round(parseFloat(value) * scaleMultiplier);
        return scaled + unit;
      });
    }
    const textureBlendMode = settings.textureBlendMode || "overlay";
    const textureAnimated = settings.textureAnimated || false;
    return {
      background,
      boxShadow,
      opacity: isPopout ? settings.popoutOpacity : settings.opacity,
      effectiveOpacity,
      gradientStyle: settings.gradientStyle,
      effectStyle: settings.effectStyle,
      textureStyle,
      texturePattern,
      textureBackgroundSize: textureBgSize,
      textureBlendMode,
      textureAnimated,
      isPopout,
      accentColor: accent ? accent.color : "#4a9eff",
      accentGlow: accent ? accent.glow : "rgba(74, 158, 255, 0.5)",
      accentText: accent ? accent.text : "#FFFFFF"
    };
  }
  function applyThemeToElement(deps, element, themeStyles) {
    if (!element || !themeStyles) return;
    const opacity = themeStyles.opacity / 100;
    if (opacity === 0) {
      element.style.background = "transparent";
      element.style.boxShadow = "none";
      element.style.backdropFilter = "none";
      element.style.border = "none";
      deps.productionLog("Applied true 0% opacity - completely transparent");
      return;
    }
    if (themeStyles.texturePattern) {
      element.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
      element.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
      element.style.backgroundBlendMode = `${themeStyles.textureBlendMode}, normal`;
      const animatedTextures = ["smoke-flow", "hologram-scan", "energy-waves", "water-ripple"];
      if (themeStyles.textureAnimated && animatedTextures.includes(themeStyles.textureStyle)) {
        element.classList.add("mga-texture-animated");
      } else {
        element.classList.remove("mga-texture-animated");
      }
    } else {
      element.style.background = themeStyles.background;
      element.style.backgroundBlendMode = "";
      element.classList.remove("mga-texture-animated");
    }
    const isBlackTheme = themeStyles.gradientStyle && themeStyles.gradientStyle.startsWith("black-");
    if (isBlackTheme && themeStyles.accentColor) {
      element.style.boxShadow = `0 10px 40px rgba(0, 0, 0, 0.8), 0 0 30px ${themeStyles.accentGlow}`;
      element.style.border = `1px solid ${themeStyles.accentColor}`;
    } else {
      element.style.boxShadow = themeStyles.boxShadow;
      element.style.border = `1px solid rgba(255, 255, 255, ${Math.max(0.05, opacity * 0.15)})`;
    }
    if (opacity >= 1) {
      element.style.backdropFilter = "none";
    } else if (opacity > 0.05) {
      const blurIntensity = Math.max(2, Math.min(12, 12 * opacity));
      element.style.backdropFilter = `blur(${blurIntensity}px)`;
    } else {
      element.style.backdropFilter = "none";
    }
    const effectiveOpacity = themeStyles.effectiveOpacity || opacity;
    const accentColor = getAccentColorForTheme(themeStyles.gradientStyle, effectiveOpacity);
    element.style.setProperty("--theme-accent-bg", accentColor.background);
    element.style.setProperty("--theme-accent-border", accentColor.border);
    if (element.classList.contains("mga-overlay") || element.id && element.id.includes("overlay")) {
      const width = element.offsetWidth || 400;
      const scale = calculateScale(width);
      element.style.setProperty("--panel-scale", scale);
    }
  }
  function calculateScale(width) {
    let scale = 1;
    if (width < 350) {
      scale = 0.8;
    } else if (width < 450) {
      scale = 0.85;
    } else if (width < 550) {
      scale = 0.9;
    } else if (width < 650) {
      scale = 0.95;
    } else if (width >= 800) {
      scale = 1.05;
    }
    return scale;
  }
  function getAccentColorForTheme(gradientStyle, opacity) {
    const accentColors = {
      "blue-purple": {
        background: `linear-gradient(135deg, rgba(74, 158, 255, ${opacity * 0.1}) 0%, rgba(147, 51, 234, ${opacity * 0.1}) 100%)`,
        border: `rgba(74, 158, 255, ${opacity * 0.3})`
      },
      "green-blue": {
        background: `linear-gradient(135deg, rgba(34, 197, 94, ${opacity * 0.1}) 0%, rgba(59, 130, 246, ${opacity * 0.1}) 100%)`,
        border: `rgba(34, 197, 94, ${opacity * 0.3})`
      },
      "red-orange": {
        background: `linear-gradient(135deg, rgba(239, 68, 68, ${opacity * 0.1}) 0%, rgba(249, 115, 22, ${opacity * 0.1}) 100%)`,
        border: `rgba(239, 68, 68, ${opacity * 0.3})`
      },
      "purple-pink": {
        background: `linear-gradient(135deg, rgba(168, 85, 247, ${opacity * 0.1}) 0%, rgba(236, 72, 153, ${opacity * 0.1}) 100%)`,
        border: `rgba(168, 85, 247, ${opacity * 0.3})`
      },
      "gold-yellow": {
        background: `linear-gradient(135deg, rgba(255, 215, 0, ${opacity * 0.1}) 0%, rgba(245, 158, 11, ${opacity * 0.1}) 100%)`,
        border: `rgba(255, 215, 0, ${opacity * 0.3})`
      },
      "steel-blue": {
        background: `linear-gradient(135deg, rgba(30, 58, 138, ${opacity * 0.1}) 0%, rgba(51, 65, 85, ${opacity * 0.1}) 100%)`,
        border: `rgba(30, 58, 138, ${opacity * 0.3})`
      },
      "chrome-silver": {
        background: `linear-gradient(135deg, rgba(203, 213, 225, ${opacity * 0.1}) 0%, rgba(148, 163, 184, ${opacity * 0.1}) 100%)`,
        border: `rgba(203, 213, 225, ${opacity * 0.3})`
      },
      "titanium-gray": {
        background: `linear-gradient(135deg, rgba(107, 114, 128, ${opacity * 0.1}) 0%, rgba(156, 163, 175, ${opacity * 0.1}) 100%)`,
        border: `rgba(107, 114, 128, ${opacity * 0.3})`
      },
      "electric-neon": {
        background: `linear-gradient(135deg, rgba(0, 100, 255, ${opacity * 0.1}) 0%, rgba(147, 51, 234, ${opacity * 0.1}) 100%)`,
        border: `rgba(0, 100, 255, ${opacity * 0.3})`
      },
      "rainbow-burst": {
        background: `linear-gradient(135deg, rgba(239, 68, 68, ${opacity * 0.08}) 0%, rgba(245, 158, 11, ${opacity * 0.08}) 25%, rgba(34, 197, 94, ${opacity * 0.08}) 50%, rgba(59, 130, 246, ${opacity * 0.08}) 75%, rgba(147, 51, 234, ${opacity * 0.08}) 100%)`,
        border: `rgba(147, 51, 234, ${opacity * 0.3})`
      }
    };
    return accentColors[gradientStyle] || accentColors["blue-purple"];
  }
  function applyThemeToDock(deps, themeStyles) {
    const dock = deps.document.querySelector("#mgh-dock");
    if (!dock) return;
    dock.style.background = themeStyles.background;
    dock.style.border = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.15})`;
    dock.style.boxShadow = themeStyles.boxShadow;
    dock.style.backdropFilter = "blur(20px)";
  }
  function applyAccentToDock(deps, themeStyles) {
    const dock = deps.document.querySelector("#mgh-dock");
    if (!dock) return;
    const opacity = themeStyles.opacity / 100;
    dock.style.background = `rgba(0, 0, 0, ${opacity})`;
    dock.style.border = `1px solid ${themeStyles.accentColor}`;
    let accentShadow = `0 8px 24px rgba(0, 0, 0, 0.8), 0 0 20px ${themeStyles.accentGlow}`;
    if (themeStyles.effectStyle === "neon" || themeStyles.effectStyle === "plasma") {
      accentShadow += `, 0 0 40px ${themeStyles.accentGlow}`;
    } else if (themeStyles.effectStyle === "metallic" || themeStyles.effectStyle === "steel") {
      accentShadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
    } else if (themeStyles.effectStyle === "crystal" || themeStyles.effectStyle === "glass") {
      accentShadow += `, 0 0 30px ${themeStyles.accentGlow}, inset 0 1px 0 rgba(255, 255, 255, 0.73)`;
    }
    dock.style.boxShadow = accentShadow;
    if (opacity >= 1) {
      dock.style.backdropFilter = "none";
    } else if (opacity > 0.05) {
      const blurIntensity = Math.max(2, Math.min(20, 20 * opacity));
      dock.style.backdropFilter = `blur(${blurIntensity}px)`;
    } else {
      dock.style.backdropFilter = "none";
    }
    dock.style.setProperty("--accent-color", themeStyles.accentColor);
    dock.style.setProperty("--accent-glow", themeStyles.accentGlow);
  }
  function applyThemeToSidebar(deps, themeStyles) {
    const sidebar = deps.document.querySelector("#mgh-sidebar");
    if (!sidebar) return;
    if (themeStyles.texturePattern) {
      sidebar.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
      sidebar.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
    } else {
      sidebar.style.background = themeStyles.background;
    }
    sidebar.style.borderRight = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.15})`;
    sidebar.style.boxShadow = `4px 0 24px rgba(0, 0, 0, 0.6), ${themeStyles.boxShadow}`;
    sidebar.style.backdropFilter = "blur(20px)";
    const header = sidebar.querySelector(".mgh-sidebar-header");
    if (header) {
      if (themeStyles.texturePattern) {
        header.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
        header.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
      } else {
        header.style.background = themeStyles.background;
      }
      header.style.borderBottom = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.2})`;
    }
    const existingStyle = deps.document.getElementById("accent-theme-styles");
    if (existingStyle) existingStyle.remove();
  }
  function applyAccentToSidebar(deps, themeStyles) {
    const sidebar = deps.document.querySelector("#mgh-sidebar");
    if (!sidebar) return;
    const opacity = themeStyles.opacity / 100;
    if (themeStyles.texturePattern) {
      sidebar.style.background = `${themeStyles.texturePattern}, rgba(0, 0, 0, ${opacity})`;
      sidebar.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
    } else {
      sidebar.style.background = `rgba(0, 0, 0, ${opacity})`;
    }
    sidebar.style.borderRight = `2px solid ${themeStyles.accentColor}`;
    if (opacity >= 1) {
      sidebar.style.backdropFilter = "none";
    } else if (opacity > 0.05) {
      const blurIntensity = Math.max(2, Math.min(20, 20 * opacity));
      sidebar.style.backdropFilter = `blur(${blurIntensity}px)`;
    } else {
      sidebar.style.backdropFilter = "none";
    }
    let sidebarShadow = `4px 0 24px rgba(0, 0, 0, 0.6), 0 0 20px ${themeStyles.accentGlow}`;
    if (themeStyles.effectStyle === "neon" || themeStyles.effectStyle === "plasma") {
      sidebarShadow += `, 0 0 40px ${themeStyles.accentGlow}`;
    } else if (themeStyles.effectStyle === "crystal" || themeStyles.effectStyle === "glass") {
      sidebarShadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
    }
    sidebar.style.boxShadow = sidebarShadow;
    const header = sidebar.querySelector(".mgh-sidebar-header");
    if (header) {
      header.style.background = `linear-gradient(90deg, rgba(0, 0, 0, ${opacity}) 0%, ${themeStyles.accentColor} 100%)`;
      header.style.borderBottom = `2px solid ${themeStyles.accentColor}`;
      let headerGlow = `0 2px 20px ${themeStyles.accentGlow}`;
      if (themeStyles.effectStyle === "neon" || themeStyles.effectStyle === "plasma") {
        headerGlow += `, 0 0 30px ${themeStyles.accentGlow}`;
      }
      header.style.boxShadow = headerGlow;
    }
    sidebar.style.setProperty("--accent-color", themeStyles.accentColor);
    sidebar.style.setProperty("--accent-glow", themeStyles.accentGlow);
    const style = deps.document.createElement("style");
    style.id = "accent-theme-styles";
    const existingStyle = deps.document.getElementById("accent-theme-styles");
    if (existingStyle) existingStyle.remove();
    style.textContent = `
        /* Sidebar sections - ONLY MGTools elements */
        #mgh-sidebar .mga-section {
            background: ${themeStyles.accentColor}05;
            border: 1px solid ${themeStyles.accentColor}33;
        }

        /* Buttons - ONLY in sidebar */
        #mgh-sidebar button.mga-button,
        #mgh-sidebar button.mga-btn {
            background: linear-gradient(135deg, ${themeStyles.accentColor}AA, ${themeStyles.accentColor});
            border: 1px solid ${themeStyles.accentColor};
        }
        #mgh-sidebar button.mga-button:hover,
        #mgh-sidebar button.mga-btn:hover {
            background: linear-gradient(135deg, ${themeStyles.accentColor}, ${themeStyles.accentColor}FF);
            box-shadow: 0 0 15px ${themeStyles.accentGlow};
        }

        /* Inputs - ONLY mga-prefixed classes */
        #mgh-sidebar input.mga-slider,
        #mgh-sidebar select.mga-select,
        #mgh-sidebar textarea.mga-textarea {
            border-color: ${themeStyles.accentColor}66;
        }
        #mgh-sidebar input.mga-slider:focus,
        #mgh-sidebar select.mga-select:focus,
        #mgh-sidebar textarea.mga-textarea:focus {
            border-color: ${themeStyles.accentColor};
            box-shadow: 0 0 10px ${themeStyles.accentGlow};
        }

        /* Scrollbar - ONLY sidebar scrollbar */
        #mgh-sidebar .mgh-sidebar-body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, ${themeStyles.accentColor}, ${themeStyles.accentColor}AA);
        }
        #mgh-sidebar .mgh-sidebar-body::-webkit-scrollbar-thumb:hover {
            background: ${themeStyles.accentColor};
        }
    `;
    deps.document.head.appendChild(style);
  }
  function applyThemeToPopoutWidget(deps, popout, themeStyles) {
    if (!popout || !themeStyles) return;
    const isBlackTheme = themeStyles.gradientStyle && themeStyles.gradientStyle.startsWith("black-");
    const opacity = themeStyles.opacity / 100;
    if (isBlackTheme && themeStyles.accentColor) {
      if (themeStyles.texturePattern) {
        popout.style.background = `${themeStyles.texturePattern}, rgba(0, 0, 0, ${opacity})`;
        popout.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
      } else {
        popout.style.background = `rgba(0, 0, 0, ${opacity})`;
      }
      popout.style.border = `1px solid ${themeStyles.accentColor}`;
      let shadow = `0 8px 32px rgba(0, 0, 0, 0.6), 0 0 20px ${themeStyles.accentGlow}`;
      if (themeStyles.effectStyle === "neon" || themeStyles.effectStyle === "plasma") {
        shadow += `, 0 0 40px ${themeStyles.accentGlow}`;
      } else if (themeStyles.effectStyle === "metallic" || themeStyles.effectStyle === "steel") {
        shadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
      } else if (themeStyles.effectStyle === "crystal" || themeStyles.effectStyle === "glass") {
        shadow += `, 0 0 30px ${themeStyles.accentGlow}, inset 0 1px 0 rgba(255, 255, 255, 0.73)`;
      }
      popout.style.boxShadow = shadow;
      const header = popout.querySelector(".mgh-popout-header");
      if (header) {
        header.style.background = `linear-gradient(90deg, rgba(0, 0, 0, ${opacity}) 0%, ${themeStyles.accentColor} 100%)`;
        header.style.borderBottom = `1px solid ${themeStyles.accentColor}`;
        let headerGlow = `0 2px 20px ${themeStyles.accentGlow}`;
        if (themeStyles.effectStyle === "neon" || themeStyles.effectStyle === "plasma") {
          headerGlow += `, 0 0 30px ${themeStyles.accentGlow}`;
        }
        header.style.boxShadow = headerGlow;
      }
      const body = popout.querySelector(".mgh-popout-body");
      if (body) {
        if (themeStyles.texturePattern) {
          body.style.background = `${themeStyles.texturePattern}, rgba(0, 0, 0, ${opacity})`;
          body.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
        } else {
          body.style.background = `rgba(0, 0, 0, ${opacity})`;
        }
      }
    } else {
      if (themeStyles.texturePattern) {
        popout.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
        popout.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
      } else {
        popout.style.background = themeStyles.background;
      }
      popout.style.border = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.15})`;
      popout.style.boxShadow = themeStyles.boxShadow;
      const header = popout.querySelector(".mgh-popout-header");
      if (header) {
        if (themeStyles.texturePattern) {
          header.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
          header.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
        } else {
          header.style.background = themeStyles.background;
        }
        header.style.borderBottom = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.2})`;
      }
      const body = popout.querySelector(".mgh-popout-body");
      if (body) {
        if (themeStyles.texturePattern) {
          body.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
          body.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
        } else {
          body.style.background = themeStyles.background;
        }
      }
    }
    popout.style.backdropFilter = "blur(20px)";
  }
  function applyUltraCompactMode(deps, panel, state, enabled) {
    if (!panel) return;
    if (enabled) {
      panel.style.cssText += `
            --mga-font-size: 11px;
            --mga-section-padding: 6px;
            --mga-header-padding: 8px 12px;
            --mga-button-padding: 4px 8px;
            --mga-input-padding: 4px 6px;
            --mga-tab-height: 32px;
            --mga-spacing: 4px;
            min-width: 250px;
            font-size: 11px;
        `;
      panel.classList.add("mga-ultra-compact");
      const currentWidth = parseInt(panel.style.width) || 800;
      const currentHeight = parseInt(panel.style.height) || 600;
      panel.style.width = Math.max(250, currentWidth * 0.7) + "px";
      panel.style.height = Math.max(300, currentHeight * 0.8) + "px";
    } else {
      panel.classList.remove("mga-ultra-compact");
      panel.style.cssText = panel.style.cssText.replace(/--mga-[^;]+;/g, "");
      panel.style.minWidth = "250px";
      panel.style.maxWidth = "";
      panel.style.fontSize = "13px";
    }
    if (state.activeTab && deps.updateTabContent) {
      deps.updateTabContent();
    }
    deps.productionLog(`Ultra-compact mode ${enabled ? "applied" : "removed"}`);
  }
  function applyDynamicScaling(element, width, scaleCache) {
    if (element.classList.contains("mga-ultra-compact")) {
      return;
    }
    const widthRange = Math.floor(width / 50) * 50;
    let scale = scaleCache.get(widthRange);
    if (scale === void 0) {
      scale = calculateScale(width);
      scaleCache.set(widthRange, scale);
    }
    const lastScale = element._lastScale;
    if (lastScale !== scale) {
      element._lastScale = scale;
      element.style.setProperty("--panel-scale", scale);
    }
  }
  function updateTabResponsiveness(element) {
    const tabs = element.querySelectorAll(".mga-tab");
    const tabsContainer = element.querySelector(".mga-tabs");
    if (!tabsContainer || tabs.length === 0) return;
    const activeTab = element.querySelector(".mga-tab.active");
    if (activeTab && tabsContainer.scrollWidth > tabsContainer.clientWidth) {
      const tabRect = activeTab.getBoundingClientRect();
      const containerRect = tabsContainer.getBoundingClientRect();
      if (tabRect.right > containerRect.right) {
        tabsContainer.scrollLeft += tabRect.right - containerRect.right + 10;
      } else if (tabRect.left < containerRect.left) {
        tabsContainer.scrollLeft -= containerRect.left - tabRect.left + 10;
      }
    }
  }

  // src/ui/tooltip-system.js
  var tooltip_system_exports = {};
  __export(tooltip_system_exports, {
    TOOLTIP_STYLES: () => TOOLTIP_STYLES,
    createTooltipSystem: () => createTooltipSystem,
    initializeTooltipSystem: () => initializeTooltipSystem
  });
  var TOOLTIP_STYLES = `
@keyframes mga-fade-out {
  from { opacity: 1; transform: translateY(0); }
  to { opacity: 0; transform: translateY(-10px); }
}

/* Ensure our estimate/slot-value paragraphs behave as full-width, centered lines
   so they appear centered inside the game's tooltip textbox regardless of container quirks. */
[data-turtletimer-estimate="true"] {
  display: block !important;
  width: 100% !important;
  box-sizing: border-box !important;
  text-align: center !important;       /* centers text inside the tooltip textbox */
  margin: 2px 0 !important;
  padding: 0 !important;
  color: lime !important;
  font-weight: bold !important;
  font-size: 14px !important;
  line-height: 1.25 !important;
}

[data-turtletimer-slot-value="true"] {
  display: block !important;
  width: 100% !important;
  box-sizing: border-box !important;
  text-align: center !important;       /* centers text inside the tooltip textbox */
  margin: 2px 0 !important;
  padding: 0 !important;
  color: #FFD700 !important;
  font-weight: 600 !important;
  font-size: 13px !important;
  line-height: 1.25 !important;
}
`;
  function createTooltipSystem(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      document: doc = typeof document !== "undefined" ? document : null,
      window: win = typeof window !== "undefined" ? window : null,
      isMGAEvent = () => true
    } = dependencies;
    if (!targetDocument2 || !doc || !win) {
      return {
        init: () => {
        },
        show: () => {
        },
        hide: () => {
        },
        position: () => {
        },
        addToElement: () => {
        },
        removeFromElement: () => {
        },
        destroy: () => {
        }
      };
    }
    const state = {
      tooltip: null,
      showTimeout: null,
      hideTimeout: null,
      currentEvent: null
      // Store current mouse event for positioning
    };
    function handleMouseEnter(e) {
      const element = e.target?.closest?.("[data-tooltip]");
      if (!element) return;
      if (e.target && typeof e.target.matches === "function" && (e.target.matches("button, input, select, .mga-btn") || e.target.closest("button, .mga-btn"))) {
        return;
      }
      const text = element.dataset.tooltip;
      const delay = element.dataset.tooltipDelay || 500;
      state.currentEvent = e;
      state.showTimeout = setTimeout(
        () => {
          show(element, text);
        },
        parseInt(delay, 10)
      );
    }
    function handleMouseLeave(e) {
      const element = e.target?.closest?.("[data-tooltip]");
      if (!element) return;
      clearTimeout(state.showTimeout);
      hide();
    }
    function handleMouseMove(e) {
      if (!isMGAEvent(e)) {
        return;
      }
      if (e.target && typeof e.target.matches === "function" && (e.target.matches("button, input, select, .mga-btn") || e.target.closest("button, .mga-btn"))) {
        return;
      }
      state.currentEvent = e;
      if (state.tooltip && state.tooltip.classList.contains("show")) {
        const tooltipElement = e.target?.closest?.("[data-tooltip]");
        if (!tooltipElement) {
          hide();
          return;
        }
        position(e);
      }
    }
    function show(element, text) {
      const { tooltip } = state;
      tooltip.textContent = text;
      if (state.currentEvent) {
        position(state.currentEvent);
      }
      tooltip.classList.add("show");
    }
    function hide() {
      const { tooltip } = state;
      tooltip.classList.remove("show");
      tooltip.style.left = "-9999px";
      tooltip.style.top = "-9999px";
      state.currentEvent = null;
    }
    function position(e) {
      const { tooltip } = state;
      const rect = tooltip.getBoundingClientRect();
      const padding = 10;
      let x = e.clientX + padding;
      let y = e.clientY - rect.height - padding;
      if (x + rect.width > win.innerWidth) {
        x = e.clientX - rect.width - padding;
      }
      if (y < 0) {
        y = e.clientY + padding;
      }
      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;
    }
    function addToElement(element, text, options = {}) {
      if (!element) return;
      element.setAttribute("data-tooltip", text);
      if (options.delay) element.setAttribute("data-tooltip-delay", options.delay);
    }
    function removeFromElement(element) {
      if (!element) return;
      element.removeAttribute("data-tooltip");
      element.removeAttribute("data-tooltip-delay");
    }
    function init() {
      if (!state.tooltip) {
        state.tooltip = targetDocument2.createElement("div");
        state.tooltip.className = "mga-tooltip";
        targetDocument2.body.appendChild(state.tooltip);
      }
      doc.addEventListener("mouseenter", handleMouseEnter, true);
      doc.addEventListener("mouseleave", handleMouseLeave, true);
      doc.addEventListener("mousemove", handleMouseMove, true);
    }
    function destroy() {
      doc.removeEventListener("mouseenter", handleMouseEnter, true);
      doc.removeEventListener("mouseleave", handleMouseLeave, true);
      doc.removeEventListener("mousemove", handleMouseMove, true);
      if (state.tooltip && state.tooltip.parentNode) {
        state.tooltip.parentNode.removeChild(state.tooltip);
      }
      clearTimeout(state.showTimeout);
      clearTimeout(state.hideTimeout);
      state.tooltip = null;
      state.showTimeout = null;
      state.hideTimeout = null;
      state.currentEvent = null;
    }
    return {
      init,
      show,
      hide,
      position,
      addToElement,
      removeFromElement,
      destroy
    };
  }
  function initializeTooltipSystem(dependencies = {}) {
    const { targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null } = dependencies;
    const tooltipSystem = createTooltipSystem(dependencies);
    tooltipSystem.init();
    if (targetDocument2) {
      const styleSheet = targetDocument2.createElement("style");
      styleSheet.textContent = TOOLTIP_STYLES;
      targetDocument2.head.appendChild(styleSheet);
    }
    return tooltipSystem;
  }

  // src/ui/tab-content.js
  var tab_content_exports = {};
  __export(tab_content_exports, {
    getHelpTabContent: () => getHelpTabContent,
    getHotkeysTabContent: () => getHotkeysTabContent,
    getProtectTabContent: () => getProtectTabContent,
    getRoomStatusTabContent: () => getRoomStatusTabContent2,
    getSeedsTabContent: () => getSeedsTabContent,
    getTimersTabContent: () => getTimersTabContent,
    getToolsTabContent: () => getToolsTabContent,
    getValuesTabContent: () => getValuesTabContent
  });
  function getSeedsTabContent(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      debugLog: debugLog3 = () => {
      },
      productionLog: productionLog3 = () => {
      }
    } = dependencies;
    debugLog3("SEEDS_TAB", "getSeedsTabContent() called - generating full content");
    productionLog3("\u{1F50D} [SEEDS DEBUG] getSeedsTabContent() called - generating content");
    const seedGroups = [
      { name: "Common", color: "#fff", seeds: ["Carrot", "Strawberry", "Aloe"] },
      { name: "Uncommon", color: "#0f0", seeds: ["Apple", "Tulip", "Tomato", "Blueberry"] },
      { name: "Rare", color: "#0af", seeds: ["Daffodil", "Corn", "Watermelon", "Pumpkin", "Delphinium", "Squash"] },
      { name: "Legendary", color: "#ff0", seeds: ["Echeveria", "Coconut", "Banana", "Lily", "BurrosTail"] },
      { name: "Mythical", color: "#a0f", seeds: ["Mushroom", "Cactus", "Bamboo", "Grape"] },
      {
        name: "Divine",
        color: "orange",
        seeds: ["Sunflower", "Pepper", "Lemon", "PassionFruit", "DragonFruit", "Lychee"]
      },
      { name: "Celestial", color: "#ff69b4", seeds: ["Starweaver", "Moonbinder", "Dawnbinder"], protected: true }
    ];
    let html = `
          <div class="mga-section">
              <div class="mga-section-title">Quick Actions</div>
              <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
                  <button class="mga-btn mga-btn-sm" id="select-all-seeds" style="background: #059669;">Select All</button>
                  <button class="mga-btn mga-btn-sm" id="select-none-seeds" style="background: #dc2626;">Select None</button>
                  <button class="mga-btn mga-btn-sm" id="select-common" style="background: #6b7280;">Common</button>
                  <button class="mga-btn mga-btn-sm" id="select-uncommon" style="background: #059669;">Uncommon</button>
                  <button class="mga-btn mga-btn-sm" id="select-rare" style="background: #0ea5e9;">Rare+</button>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">Seed Management</div>
              <div style="display: flex; gap: 8px; margin-bottom: 12px; align-items: center; flex-wrap: wrap;">
                  <label class="mga-checkbox-group">
                      <input type="checkbox" class="mga-checkbox" id="auto-delete-checkbox">
                      <span class="mga-label">Auto-Delete</span>
                  </label>
                  <button class="mga-btn" id="delete-selected-btn" style="background: #dc2626;">Delete Selected</button>
                  <button class="mga-btn mga-btn-sm" id="calculate-value-btn" style="background: #f59e0b;">Calculate Value</button>
              </div>
              <div id="seed-value-display" style="display: none; margin-top: 8px; padding: 8px; background: rgba(245, 158, 11, 0.30); border-radius: 4px;">
                  <div style="font-size: 13px; color: #f59e0b;">Selected Seeds Value: <span id="selected-seeds-value">0</span> \u{1F4B0}</div>
              </div>
          </div>
      `;
    const seedIdMap = {
      Carrot: "Carrot",
      Strawberry: "Strawberry",
      Aloe: "Aloe",
      Blueberry: "Blueberry",
      Apple: "Apple",
      Tulip: "OrangeTulip",
      Tomato: "Tomato",
      Daffodil: "Daffodil",
      Sunflower: "Sunflower",
      Corn: "Corn",
      Watermelon: "Watermelon",
      Pumpkin: "Pumpkin",
      Delphinium: "Delphinium",
      Squash: "Squash",
      Echeveria: "Echeveria",
      Coconut: "Coconut",
      Banana: "Banana",
      Lily: "Lily",
      BurrosTail: "BurrosTail",
      Mushroom: "Mushroom",
      Cactus: "Cactus",
      Bamboo: "Bamboo",
      Grape: "Grape",
      Pepper: "Pepper",
      Lemon: "Lemon",
      PassionFruit: "PassionFruit",
      DragonFruit: "DragonFruit",
      Lychee: "Lychee",
      Starweaver: "Starweaver",
      Moonbinder: "Moonbinder",
      Dawnbinder: "Dawnbinder"
    };
    productionLog3("\u{1F50D} [SEEDS DEBUG] Applying saved state to checkboxes:", {
      savedSeedsToDelete: UnifiedState3?.data?.seedsToDelete,
      savedSeedsCount: UnifiedState3?.data?.seedsToDelete?.length || 0
    });
    seedGroups.forEach((group) => {
      html += `
              <div class="mga-section">
                  <div class="mga-section-title" style="color: ${group.color}">${group.name}</div>
                  <div class="mga-grid">
          `;
      group.seeds.forEach((seed) => {
        const isGroupProtected = group.protected === true;
        const isIndividuallyProtected = ["Starweaver", "Moonbinder", "Dawnbinder", "Sunflower"].includes(seed);
        const isProtected = isGroupProtected || isIndividuallyProtected;
        const disabledAttr = isProtected ? "disabled" : "";
        const protectedStyle = isProtected ? "opacity: 0.5; cursor: not-allowed;" : "";
        const protectedLabel = isProtected ? " \u{1F512}" : "";
        const internalId = seedIdMap[seed] || seed;
        const isChecked = UnifiedState3?.data?.seedsToDelete?.includes(internalId) || false;
        const checkedAttr = isChecked ? "checked" : "";
        productionLog3(`\u{1F50D} [SEEDS DEBUG] Seed ${seed} (${internalId}): checked=${isChecked}`);
        html += `
                  <label class="mga-checkbox-group" style="${protectedStyle}">
                      <input type="checkbox" class="mga-checkbox seed-checkbox" data-seed="${seed}" ${disabledAttr} ${checkedAttr}>
                      <span class="mga-label" style="color: ${group.color}">${seed}${protectedLabel}</span>
                  </label>
              `;
      });
      html += "</div></div>";
    });
    debugLog3("SEEDS_TAB", "getSeedsTabContent() returning HTML", { htmlLength: html.length });
    productionLog3("\u{1F50D} [SEEDS DEBUG] Returning HTML:", {
      htmlLength: html.length,
      htmlPreview: html.substring(0, 200)
    });
    return html;
  }
  function getValuesTabContent(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      globalValueManager = typeof window !== "undefined" && window.globalValueManager,
      initializeValueManager: initializeValueManager2 = typeof window !== "undefined" && window.initializeValueManager
    } = dependencies;
    const valueManager = globalValueManager || (initializeValueManager2 ? initializeValueManager2() : null);
    const tileValue = valueManager ? valueManager.getTileValue() : 0;
    const gardenValue = valueManager ? valueManager.getGardenValue() : 0;
    const inventoryValue = valueManager ? valueManager.getInventoryValue() : 0;
    return `
          <div class="mga-section">
              <div class="mga-section-title">\u{1F4B0} Garden Values</div>
              <div class="mga-value-compact" style="
                  display: grid;
                  grid-template-columns: 1fr auto;
                  column-gap: 12px;
                  row-gap: 4px;
                  font-size: 13px;
                  line-height: 1.5;
              ">
                  <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Tile value:</div>
                  <div class="overlay-val" style="text-align: right; color: #4a9eff; font-weight: bold; min-width: 90px; word-break: keep-all;">${tileValue.toLocaleString()}</div>

                  <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Inventory value:</div>
                  <div class="overlay-val" style="text-align: right; color: #f59e0b; font-weight: bold; min-width: 90px; word-break: keep-all;">${inventoryValue.toLocaleString()}</div>

                  <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Garden value:</div>
                  <div class="overlay-val" style="text-align: right; color: #10b981; font-weight: bold; min-width: 90px; word-break: keep-all;">${gardenValue.toLocaleString()}</div>
              </div>
          </div>

          <div class="mga-section" style="margin-top: 16px;">
              <div class="mga-section-title" style="display: flex; align-items: center; justify-content: space-between;">
                  <span>\u{1F31F} Auto-Favorite</span>
                  <label class="switch" style="margin-left: auto;">
                      <input type="checkbox" id="auto-favorite-enabled" ${UnifiedState3?.data?.settings?.autoFavorite?.enabled ? "checked" : ""}>
                      <span class="slider"></span>
                  </label>
              </div>
              <div style="margin-top: 8px;">
                  <div style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Automatically favorite these species when added to inventory:
                  </div>
                  <div id="auto-favorite-species" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 16px; max-height: 300px; overflow-y: auto; padding-right: 8px;">
                      ${[
      "Carrot",
      "Strawberry",
      "Aloe",
      "Blueberry",
      "Apple",
      "OrangeTulip",
      "Tomato",
      "Daffodil",
      "Corn",
      "Watermelon",
      "Pumpkin",
      "Echeveria",
      "Coconut",
      "Banana",
      "Lily",
      "BurrosTail",
      "Mushroom",
      "Cactus",
      "Bamboo",
      "Grape",
      "Pepper",
      "Lemon",
      "PassionFruit",
      "DragonFruit",
      "Lychee",
      "Sunflower",
      "Starweaver",
      "DawnCelestial",
      "MoonCelestial"
    ].map(
      (species) => `
                              <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; cursor: pointer; user-select: none;">
                                  <input type="checkbox" value="${species}"
                                      ${UnifiedState3?.data?.settings?.autoFavorite?.species?.includes(species) ? "checked" : ""}
                                      style="cursor: pointer;">
                                  <span style="color: #e5e7eb;">${species.replace("OrangeTulip", "Tulip").replace("DawnCelestial", "Dawnbinder").replace("MoonCelestial", "Moonbinder")}</span>
                              </label>
                          `
    ).join("")}
                  </div>
                  <div style="font-size: 11px; color: #aaa; margin-bottom: 12px; border-top: 1px solid rgba(255, 255, 255, 0.57); padding-top: 12px;">
                      Automatically favorite items with these mutations:
                  </div>
                  <div id="auto-favorite-mutations" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                      ${[
      "Rainbow",
      "Gold",
      "Frozen",
      "Wet",
      "Chilled",
      "Dawnlit",
      "Amberlit",
      "Dawnbound",
      "Amberbound"
    ].map(
      (mutation) => `
                              <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer; user-select: none;">
                                  <input type="checkbox" value="${mutation}"
                                      ${UnifiedState3?.data?.settings?.autoFavorite?.mutations?.includes(mutation) ? "checked" : ""}
                                      style="cursor: pointer;">
                                  <span style="color: #e5e7eb;">${mutation}</span>
                              </label>
                          `
    ).join("")}
                  </div>
                  <div style="font-size: 11px; color: #aaa; margin-bottom: 12px; border-top: 1px solid rgba(255, 255, 255, 0.57); padding-top: 12px;">
                      Automatically favorite pets with these abilities:
                  </div>
                  <div id="auto-favorite-pet-abilities" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                      ${["Rainbow Granter", "Gold Granter"].map(
      (ability) => `
                              <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer; user-select: none;">
                                  <input type="checkbox" value="${ability}"
                                      ${(UnifiedState3?.data?.settings?.autoFavorite?.petAbilities || []).includes(ability) ? "checked" : ""}
                                      style="cursor: pointer;">
                                  <span style="color: #e5e7eb;">${ability}</span>
                              </label>
                          `
    ).join("")}
                  </div>
              </div>
          </div>
      `;
  }
  function getTimersTabContent() {
    return `
          <div class="mga-section">
              <div class="mga-section-title">Restock Timers</div>
              <div class="mga-timer">
                  <div class="mga-timer-label">Seed Restock</div>
                  <div class="mga-timer-value" id="timer-seed">--:--</div>
              </div>
              <div class="mga-timer">
                  <div class="mga-timer-label">Egg Restock</div>
                  <div class="mga-timer-value" id="timer-egg">--:--</div>
              </div>
              <div class="mga-timer">
                  <div class="mga-timer-label">Tool Restock</div>
                  <div class="mga-timer-value" id="timer-tool">--:--</div>
              </div>
              <div class="mga-timer" style="background: rgba(147, 51, 234, 0.30); border-color: rgba(147, 51, 234, 0.3);">
                  <div class="mga-timer-label">Lunar Event</div>
                  <div class="mga-timer-value" id="timer-lunar" style="color: #9333ea;">--:--</div>
              </div>
          </div>
      `;
  }
  function getRoomStatusTabContent2(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      RoomRegistry = typeof window !== "undefined" && window.RoomRegistry,
      getCurrentRoomCode: getCurrentRoomCode2 = typeof window !== "undefined" && window.getCurrentRoomCode
    } = dependencies;
    const currentRoom = getCurrentRoomCode2 ? getCurrentRoomCode2() : null;
    const roomCounts = UnifiedState3?.data?.roomStatus?.counts || {};
    const activeRoomsTab = UnifiedState3?.data?.activeRoomsTab || "mg";
    const renderRoomCard = (room, allowDelete = false, allowDrag = false) => {
      const count = roomCounts[room.name?.toUpperCase()] || roomCounts[room.id] || 0;
      const displayCount = Math.min(count, 6);
      const isCurrentRoom = room.id === currentRoom;
      let statusColor = "#94a3b8";
      if (count > 0) statusColor = "#4ade80";
      if (count >= 4) statusColor = "#fbbf24";
      if (count >= 6) statusColor = "#ef4444";
      const bgColor = isCurrentRoom ? "rgba(59, 130, 246, 0.40)" : "rgba(255, 255, 255, 0.03)";
      const borderColor = isCurrentRoom ? "#3b82f6" : "rgba(255, 255, 255, 0.57)";
      return `
              <div class="room-item" ${allowDrag ? 'draggable="true"' : ""} data-room="${room.id}" style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  padding: 12px;
                  background: ${bgColor};
                  border: 1px solid ${borderColor};
                  border-radius: 6px;
                  transition: all 0.2s;
                  cursor: ${allowDrag ? "grab" : "default"} !important;
                  user-select: none;
              ">
                  <div style="display: flex; align-items: center; gap: 12px; flex: 1; cursor: ${allowDrag ? "grab" : "default"} !important;">
                      ${allowDrag ? '<span style="color: #666; font-size: 16px; cursor: grab !important;" title="Drag to reorder">\u22EE\u22EE</span>' : ""}
                      <span style="
                          font-weight: bold;
                          color: ${isCurrentRoom ? "#60a5fa" : "#e5e7eb"};
                          font-size: 14px;
                          min-width: ${allowDrag ? "45px" : "70px"};
                          cursor: ${allowDrag ? "grab" : "default"} !important;
                      ">${room.name || room.id}</span>
                      <span style="
                          font-weight: bold;
                          color: ${statusColor};
                          font-size: 13px;
                          min-width: 50px;
                          cursor: ${allowDrag ? "grab" : "default"} !important;
                      ">${displayCount}/6 ${isCurrentRoom ? "(You)" : ""}</span>
                  </div>
                  <div style="display: flex; gap: 8px; align-items: center;">
                      <button class="mga-button room-join-btn" data-room="${room.id}" style="
                          padding: 6px 14px;
                          font-size: 12px;
                          background: ${isCurrentRoom ? "#666" : "#4a9eff"};
                          color: white;
                          border: none;
                          border-radius: 4px;
                          cursor: ${isCurrentRoom ? "not-allowed" : "pointer"} !important;
                          opacity: ${isCurrentRoom ? "0.5" : "1"};
                      " ${isCurrentRoom ? "disabled" : ""}>
                          ${isCurrentRoom ? "Current" : "Join"}
                      </button>
                      ${allowDelete ? `
                      <button class="room-delete-btn" data-room="${room.id}" style="
                          padding: 6px 10px;
                          font-size: 14px;
                          background: #ef4444;
                          color: white;
                          border: none;
                          border-radius: 4px;
                          cursor: pointer !important;
                          opacity: 0.8;
                          transition: opacity 0.2s;
                      " title="Remove room from list">
                          \u274C
                      </button>` : ""}
                  </div>
              </div>
          `;
    };
    const mgAndCustomRooms = RoomRegistry && RoomRegistry.getMGAndCustomRooms ? RoomRegistry.getMGAndCustomRooms() : [];
    return `
          <div class="mga-section">
              <div class="mga-section-title">\u{1F3AE} Live Room Status</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Real-time player counts for Magic Garden rooms. Add custom rooms to track, or browse official MG1-10 servers.
              </p>

              <!-- Tab Selector -->
              <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 2px solid rgba(255,255,255,0.1);">
                  <button class="rooms-tab-btn" data-tab="mg" style="
                      flex: 1;
                      padding: 10px;
                      background: ${activeRoomsTab === "mg" ? "rgba(34, 197, 94, 0.3)" : "transparent"};
                      border: none;
                      border-bottom: 2px solid ${activeRoomsTab === "mg" ? "#22c55e" : "transparent"};
                      color: ${activeRoomsTab === "mg" ? "#fff" : "#aaa"};
                      font-size: 13px;
                      font-weight: bold;
                      cursor: pointer;
                      transition: all 0.2s;
                      border-radius: 4px 4px 0 0;
                  ">
                      \u{1F31F} MG & Custom
                  </button>
                  <button class="rooms-tab-btn" data-tab="discord" style="
                      flex: 1;
                      padding: 10px;
                      background: ${activeRoomsTab === "discord" ? "rgba(138, 43, 226, 0.3)" : "transparent"};
                      border: none;
                      border-bottom: 2px solid ${activeRoomsTab === "discord" ? "#8a2be2" : "transparent"};
                      color: ${activeRoomsTab === "discord" ? "#fff" : "#aaa"};
                      font-size: 13px;
                      font-weight: bold;
                      cursor: pointer;
                      transition: all 0.2s;
                      border-radius: 4px 4px 0 0;
                  ">
                      \u{1F3AE} Discord Servers
                  </button>
              </div>

              <!-- Search Bar -->
              <div style="margin-bottom: 12px;">
                  <input type="text" id="room-search-input" placeholder="Search room..."
                      style="width: 100%; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57);
                      border-radius: 4px; color: white; font-size: 12px;">
              </div>

              <!-- Single container approach - swaps content instead of toggling display -->
              <div id="rooms-tab-content">
                  ${activeRoomsTab === "mg" ? `
                      <!-- MG & Custom Tab Content -->
                      <div id="room-status-list-mg" style="display: flex; flex-direction: column; gap: 8px;">
                          ${mgAndCustomRooms.map((room) => renderRoomCard(room, room.category === "custom", room.category === "custom")).join("")}
                      </div>

                      <!-- Add Custom Room Section -->
                      <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 6px;">
                          <div style="font-weight: bold; color: #60a5fa; margin-bottom: 8px; font-size: 13px;">\u2795 Add Custom Room</div>
                          <div style="display: flex; gap: 8px; align-items: center;">
                              <input type="text" id="add-room-input" placeholder="Room code (e.g., MG16)"
                                  style="flex: 1; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57);
                                  border-radius: 4px; color: white; font-size: 12px; text-transform: uppercase;">
                              <button id="add-room-btn" class="mga-button" style="
                                  padding: 8px 16px;
                                  font-size: 12px;
                                  background: #4ade80;
                                  color: white;
                                  border: none;
                                  border-radius: 4px;
                                  cursor: pointer;
                                  font-weight: bold;
                              ">Add</button>
                          </div>
                          <div style="font-size: 10px; color: #888; margin-top: 6px;">
                              Tip: Drag custom rooms to reorder, click \u274C to remove
                          </div>
                      </div>

                      <div style="margin-top: 16px; padding: 12px; background: rgba(34, 197, 94, 0.2); border-radius: 6px; border: 1px solid rgba(34, 197, 94, 0.3);">
                          <div style="font-size: 12px; color: #94a3b8; line-height: 1.5;">
                              <strong style="color: #4ade80;">Magic Garden Rooms</strong><br>
                              \u2022 MG1-15 are public Magic Garden servers<br>
                              \u2022 Add your own custom rooms to track<br>
                              \u2022 Player counts update automatically every 5 seconds
                          </div>
                      </div>
                  ` : `
                      <!-- Discord Servers Tab Content -->
                      <div id="room-status-list-discord" style="display: flex; flex-direction: column; gap: 8px;">
                          ${RoomRegistry && RoomRegistry.discord && RoomRegistry.discord.length > 0 ? RoomRegistry.discord.map((room) => renderRoomCard(room, false, false)).join("") : '<div style="padding: 20px; text-align: center; color: #94a3b8; font-size: 13px;">No Discord rooms available</div>'}
                      </div>
                      <div style="margin-top: 16px; padding: 12px; background: rgba(138, 43, 226, 0.2); border-radius: 6px; border: 1px solid rgba(138, 43, 226, 0.3);">
                          <div style="font-size: 12px; color: #94a3b8; line-height: 1.5;">
                              <strong style="color: #a78bfa;">\u{1F4A1} Discord Activity Rooms (87 Total)</strong><br>
                              \u2022 Garlic Bread: play1-play10 (no hyphen) - 10 rooms<br>
                              \u2022 Magic Circle: play-2 to play-50 (with hyphen) - 49 rooms<br>
                              \u2022 Magic Circle: Country rooms (play-\u{1F1E8}\u{1F1E6}, play-\u{1F1EC}\u{1F1E7}, etc.) - 26 rooms<br>
                              \u2022 Special: play-qu\xE9bec, play - 2 rooms<br>
                              \u2022 <strong>Player counts via /api/rooms/{id}/info</strong> (same as community scripts)
                          </div>
                      </div>
                  `}
              </div>
          </div>
      `;
  }
  function getToolsTabContent() {
    return `
          <div class="mga-section">
              <div class="mga-section-title">Magic Garden Calculators</div>
              <div class="mga-tools-grid">
                  <div class="mga-tool-card" data-calculator="sell-price">
                      <div class="mga-tool-icon">\u{1F4B0}</div>
                      <div class="mga-tool-name">Sell Price Calculator</div>
                      <div class="mga-tool-desc">Calculate optimal selling prices for items</div>
                  </div>
                  <div class="mga-tool-card" data-calculator="weight-probability">
                      <div class="mga-tool-icon">\u2696\uFE0F</div>
                      <div class="mga-tool-name">Weight Probability Calculator</div>
                      <div class="mga-tool-desc">Calculate weight-based probability outcomes</div>
                  </div>
                  <div class="mga-tool-card" data-calculator="pet-appearance-probability">
                      <div class="mga-tool-icon">\u{1F3B2}</div>
                      <div class="mga-tool-name">Pet Appearance Probability Calculator</div>
                      <div class="mga-tool-desc">Calculate probabilities for pet appearances</div>
                  </div>
                  <div class="mga-tool-card" data-calculator="ability-trigger-time">
                      <div class="mga-tool-icon">\u23F1\uFE0F</div>
                      <div class="mga-tool-name">Ability Trigger Time Calculator</div>
                      <div class="mga-tool-desc">Calculate optimal timing for pet ability triggers</div>
                  </div>
                  <div class="mga-tool-card" data-calculator="import-garden">
                      <div class="mga-tool-icon">\u{1F4E5}</div>
                      <div class="mga-tool-name">Import Your Garden</div>
                      <div class="mga-tool-desc">Import and analyze your garden layout</div>
                  </div>
              </div>
              <div class="mga-section-note" style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.15); border-radius: 5px;">
                  <strong>Note:</strong> Calculators will open in new popup windows. Make sure popup blockers are disabled for this site.
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F4DA} Wiki Resources</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Quick access to Magic Garden wiki pages. Click any card to open in a popup window.
              </p>
              <div class="mga-wiki-grid">
                  <div class="mga-wiki-card" data-wiki="crops">
                      <div class="mga-wiki-icon">\u{1F33E}</div>
                      <div class="mga-wiki-name">Crops</div>
                  </div>
                  <div class="mga-wiki-card" data-wiki="pets">
                      <div class="mga-wiki-icon">\u{1F43E}</div>
                      <div class="mga-wiki-name">Pets</div>
                  </div>
                  <div class="mga-wiki-card" data-wiki="abilities">
                      <div class="mga-wiki-icon">\u26A1</div>
                      <div class="mga-wiki-name">Abilities</div>
                  </div>
                  <div class="mga-wiki-card" data-wiki="weather">
                      <div class="mga-wiki-icon">\u{1F324}\uFE0F</div>
                      <div class="mga-wiki-name">Weather Events</div>
                  </div>
                  <div class="mga-wiki-card" data-wiki="multipliers">
                      <div class="mga-wiki-icon">\u{1F4C8}</div>
                      <div class="mga-wiki-name">Multipliers</div>
                  </div>
                  <div class="mga-wiki-card" data-wiki="shops">
                      <div class="mga-wiki-icon">\u{1F3EA}</div>
                      <div class="mga-wiki-name">Shops</div>
                  </div>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F331} Crop Highlighting</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Visual highlighting system for crops. Use Ctrl+H to clear highlights, Ctrl+Shift+H to toggle this panel.
              </p>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Highlight Species:
                  </label>
                  <select class="mga-select" id="highlight-species-select">
                      <option value="">Select species to highlight...</option>
                      <option value="Carrot">\u{1F955} Carrot</option>
                      <option value="Strawberry">\u{1F353} Strawberry</option>
                      <option value="Aloe">\u{1F33F} Aloe</option>
                      <option value="Apple">\u{1F34E} Apple</option>
                      <option value="Tulip">\u{1F337} Tulip</option>
                      <option value="Tomato">\u{1F345} Tomato</option>
                      <option value="Blueberry">\u{1FAD0} Blueberry</option>
                      <option value="Daffodil">\u{1F33B} Daffodil</option>
                      <option value="Corn">\u{1F33D} Corn</option>
                      <option value="Watermelon">\u{1F349} Watermelon</option>
                      <option value="Pumpkin">\u{1F383} Pumpkin</option>
                      <option value="Echeveria">\u{1F335} Echeveria</option>
                      <option value="Coconut">\u{1F965} Coconut</option>
                      <option value="Banana">\u{1F34C} Banana</option>
                      <option value="Lily">\u{1F33A} Lily</option>
                      <option value="BurrosTail">\u{1F33F} BurrosTail</option>
                      <option value="Mushroom">\u{1F344} Mushroom</option>
                      <option value="Cactus">\u{1F335} Cactus</option>
                      <option value="Bamboo">\u{1F38B} Bamboo</option>
                      <option value="Grape">\u{1F347} Grape</option>
                      <option value="Sunflower">\u{1F33B} Sunflower</option>
                      <option value="Pepper">\u{1F336}\uFE0F Pepper</option>
                      <option value="Lemon">\u{1F34B} Lemon</option>
                      <option value="PassionFruit">\u{1F96D} PassionFruit</option>
                      <option value="DragonFruit">\u{1F409} DragonFruit</option>
                      <option value="Lychee">\u{1F352} Lychee</option>
                      <option value="Starweaver">\u2B50 Starweaver</option>
                      <option value="Moonbinder">\u{1F319} Moonbinder</option>
                      <option value="Dawnbinder">\u{1F305} Dawnbinder</option>
                  </select>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Slot Index (0-2):
                  </label>
                  <input type="number" class="mga-input" id="highlight-slot-input"
                         min="0" max="2" value="0" style="width: 80px;">
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Hidden Species:
                  </label>
                  <select class="mga-select" id="hidden-species-select">
                      <option value="">None</option>
                      <option value="Carrot">\u{1F955} Carrot</option>
                      <option value="Strawberry">\u{1F353} Strawberry</option>
                      <option value="Aloe">\u{1F33F} Aloe</option>
                      <option value="Apple">\u{1F34E} Apple</option>
                      <option value="Tulip">\u{1F337} Tulip</option>
                      <option value="Tomato">\u{1F345} Tomato</option>
                      <option value="Blueberry">\u{1FAD0} Blueberry</option>
                      <option value="Daffodil">\u{1F33B} Daffodil</option>
                      <option value="Corn">\u{1F33D} Corn</option>
                      <option value="Watermelon">\u{1F349} Watermelon</option>
                      <option value="Pumpkin">\u{1F383} Pumpkin</option>
                      <option value="Echeveria">\u{1F335} Echeveria</option>
                      <option value="Coconut">\u{1F965} Coconut</option>
                      <option value="Banana">\u{1F34C} Banana</option>
                      <option value="Lily">\u{1F33A} Lily</option>
                      <option value="BurrosTail">\u{1F33F} BurrosTail</option>
                      <option value="Mushroom">\u{1F344} Mushroom</option>
                      <option value="Cactus">\u{1F335} Cactus</option>
                      <option value="Bamboo">\u{1F38B} Bamboo</option>
                      <option value="Grape">\u{1F347} Grape</option>
                      <option value="Sunflower">\u{1F33B} Sunflower</option>
                      <option value="Pepper">\u{1F336}\uFE0F Pepper</option>
                      <option value="Lemon">\u{1F34B} Lemon</option>
                      <option value="PassionFruit">\u{1F96D} PassionFruit</option>
                      <option value="DragonFruit">\u{1F409} DragonFruit</option>
                      <option value="Lychee">\u{1F352} Lychee</option>
                      <option value="Starweaver">\u2B50 Starweaver</option>
                      <option value="Moonbinder">\u{1F319} Moonbinder</option>
                      <option value="Dawnbinder">\u{1F305} Dawnbinder</option>
                  </select>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Hidden Scale (0.0 - 1.0):
                  </label>
                  <input type="number" class="mga-input" id="hidden-scale-input"
                         min="0" max="1" step="0.1" value="0.1" style="width: 80px;">
              </div>

              <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                  <button class="mga-btn" id="apply-highlighting-btn" style="background: #059669;">
                      \u2728 Apply Highlighting
                  </button>
                  <button class="mga-btn mga-btn-sm" id="clear-highlighting-btn" style="background: #dc2626;">
                      \u{1F5D1}\uFE0F Clear All
                  </button>
              </div>
          </div>
          <style>
              .mga-tools-grid {
                  display: grid;
                  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                  gap: 15px;
                  margin-top: 15px;
              }

              .mga-tool-card {
                  background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.02));
                  border: 1px solid rgba(255, 255, 255, 0.57);
                  border-radius: 8px;
                  padding: 15px;
                  cursor: pointer;
                  transition: all 0.3s ease;
                  text-align: center;
              }

              .mga-tool-card:hover {
                  background: linear-gradient(135deg, rgba(255, 255, 255, 0.55), rgba(255,255,255,0.04));
                  border-color: rgba(255, 255, 255, 0.73);
                  transform: translateY(-2px);
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.48);
              }

              .mga-tool-icon {
                  font-size: 2em;
                  margin-bottom: 8px;
              }

              .mga-tool-name {
                  font-weight: bold;
                  margin-bottom: 5px;
                  color: rgba(255,255,255,0.9);
              }

              .mga-tool-desc {
                  font-size: 0.85em;
                  color: rgba(255,255,255,0.6);
                  line-height: 1.3;
              }

              .mga-wiki-grid {
                  display: grid;
                  grid-template-columns: repeat(3, 1fr);
                  gap: 10px;
                  margin-top: 12px;
              }

              .mga-wiki-card {
                  background: linear-gradient(135deg, rgba(74, 158, 255, 0.28), rgba(74, 158, 255, 0.03));
                  border: 1px solid rgba(74, 158, 255, 0.48);
                  border-radius: 6px;
                  padding: 12px 8px;
                  cursor: pointer;
                  transition: all 0.2s ease;
                  text-align: center;
              }

              .mga-wiki-card:hover {
                  background: linear-gradient(135deg, rgba(74, 158, 255, 0.40), rgba(74, 158, 255, 0.28));
                  border-color: rgba(74, 158, 255, 0.4);
                  transform: translateY(-1px);
                  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.48);
              }

              .mga-wiki-icon {
                  font-size: 1.5em;
                  margin-bottom: 4px;
              }

              .mga-wiki-name {
                  font-size: 0.85em;
                  font-weight: 600;
                  color: rgba(255,255,255,0.9);
              }
          </style>
      `;
  }
  function getProtectTabContent(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const lockedCrops = UnifiedState3?.data?.lockedCrops || {};
    const sellThreshold = UnifiedState3?.data?.sellBlockThreshold || 1;
    return `
          <div class="mga-section">
              <div class="mga-section-title">\u{1F512} Crop Protection</div>
              <div style="padding: 12px; background: rgba(74, 158, 255, 0.30); border-radius: 6px; border-left: 3px solid #4a9eff; margin-bottom: 16px;">
                  <p style="margin-bottom: 8px; font-size: 13px;"><strong>How it works:</strong></p>
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 <strong>Lock crops</strong> to prevent accidental harvesting</p>
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 All crops are <strong>unlocked by default</strong></p>
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 Locked crops <strong>cannot be harvested</strong> until unlocked</p>
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 <strong>Lock All Mutations:</strong> Locks all mutation types at once</p>
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 <strong>Lock Only Non-Mutated:</strong> Locks ONLY crops with 0 mutations</p>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F331} Lock Specific Crops</div>
              <div style="margin-bottom: 12px;">
                  <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock by Species:</label>
                  <div id="protect-species-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-bottom: 12px;">
                      <!-- Species checkboxes will be generated here -->
                  </div>
              </div>

              <div style="margin-bottom: 12px;">
                  <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock by Mutations:</label>
                  <div id="protect-mutations-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-bottom: 12px;">
                      <!-- Mutation checkboxes will be generated here -->
                  </div>
              </div>

              <div style="margin-bottom: 12px;">
                  <button id="protect-clear-all" class="mga-button" style="background: rgba(239, 68, 68, 0.48); border: 1px solid rgba(239, 68, 68, 0.4);">
                      \u{1F513} Unlock All Crops
                  </button>
              </div>

              <div style="margin-top: 20px; padding: 15px; background: rgba(100, 200, 255, 0.30); border-radius: 8px; border: 1px solid rgba(100,200,255,0.3);">
                  <div style="font-weight: 600; margin-bottom: 10px; color: #64b5f6;">\u2117 Advanced Settings</div>
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px;">
                      <input type="checkbox" id="allow-frozen-pickup" class="mga-checkbox"
                             ${UnifiedState3?.data?.protectionSettings?.allowFrozenPickup ? "checked" : ""}>
                      <span>Allow pickup of protected crops when frozen</span>
                  </label>
                  <div style="font-size: 11px; color: #888; margin-top: 5px; margin-left: 26px;">
                      When enabled, locked Rainbow/Gold crops can still be harvested if they're frozen
                  </div>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F4B0} Crop Sell Protection</div>
              <div style="margin-bottom: 12px;">
                  <label style="display: block; margin-bottom: 8px; font-weight: 600;">Minimum Friend Bonus to Allow Selling Crops:</label>
                  <div style="display: flex; align-items: center; gap: 12px;">
                      <input type="range" id="protect-sell-threshold" min="1.0" max="1.5" step="0.05" value="${sellThreshold}"
                          style="flex: 1; height: 6px; background: rgba(74,158,255,0.3); border-radius: 3px; outline: none;">
                      <span id="protect-sell-threshold-value" style="min-width: 80px; font-weight: 600; color: #4a9eff;">${sellThreshold.toFixed(2)}x (${((sellThreshold - 1) * 100).toFixed(0)}%)</span>
                  </div>
                  <p style="font-size: 11px; color: #888; margin-top: 8px;">
                      Set to 1.0x to allow selling anytime. Max 1.5x (50% bonus). Higher values require better friend bonus.
                  </p>
                  <p style="font-size: 11px; color: #4a9eff; margin-top: 8px; font-weight: 600;">
                      Note: Friend bonus does NOT affect pet selling in the game.
                  </p>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F43E} Pet Protection</div>
              <div style="padding: 12px; background: rgba(74, 158, 255, 0.30); border-radius: 6px; border-left: 3px solid #4a9eff; margin-bottom: 16px;">
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 Lock pets by ability to prevent accidental selling</p>
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 Protect valuable pets with rare abilities</p>
              </div>
              <div style="margin-bottom: 12px;">
                  <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock Pets with These Abilities:</label>
                  <div id="protect-pet-abilities-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px;">
                      <!-- Pet ability checkboxes will be generated here -->
                  </div>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F3DB}\uFE0F Decor Protection</div>
              <div style="padding: 12px; background: rgba(74, 158, 255, 0.30); border-radius: 6px; border-left: 3px solid #4a9eff; margin-bottom: 16px;">
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 Lock decor items to prevent accidental pickup</p>
                  <p style="margin-bottom: 4px; font-size: 12px;">\u2022 All decor is <strong>unlocked by default</strong></p>
              </div>
              <div style="margin-bottom: 12px;">
                  <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock by Decor Type:</label>
                  <div id="protect-decor-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; max-height: 300px; overflow-y: auto; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
                      <!-- Decor checkboxes will be generated here -->
                  </div>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F4CB} Currently Protected</div>
              <div id="protect-status-display" style="padding: 12px; background: rgba(0, 0, 0, 0.48); border-radius: 6px; font-size: 12px; min-height: 60px;">
                  <div style="color: #888;">No crops are currently locked.</div>
              </div>
          </div>
      `;
  }
  function getHelpTabContent() {
    return `
          <div class="mga-section">
              <div class="mga-section-title">\u{1F680} Getting Started</div>
              <div style="margin-bottom: 16px;">
                  <p style="margin-bottom: 8px;"><strong>Magic Garden Unified</strong> provides a hybrid dock interface with powerful tools for managing pets, tracking abilities, shop automation, and resource monitoring.</p>
                  <p style="margin-bottom: 8px;">Click dock icons to open sidebars, or Shift+Click to open floating widgets. Drag the dock from its edges to reposition.</p>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F39B}\uFE0F Dock Controls</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Click Icon:</strong> Opens slide-out sidebar</li>
                  <li style="margin-bottom: 4px;"><strong>Shift+Click Icon:</strong> Opens floating popout widget</li>
                  <li style="margin-bottom: 4px;"><strong>Drag from edges:</strong> Reposition the dock (grab cursor appears near edges)</li>
                  <li style="margin-bottom: 4px;"><strong>\u2194 Icon:</strong> Toggle horizontal/vertical orientation</li>
                  <li style="margin-bottom: 4px;"><strong>\u22EF Icon:</strong> Hover to reveal Tools, Settings, Hotkeys, Notifications, Help</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u2328\uFE0F Keyboard Shortcuts</div>
              <div class="mga-help-grid" style="display: grid; grid-template-columns: auto 1fr; gap: 8px 12px; margin-bottom: 16px;">
                  <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+=</code>
                  <span>Increase dock size (Micro \u2192 Mini \u2192 Tiny \u2192 Small \u2192 Medium \u2192 Large)</span>
                  <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+-</code>
                  <span>Decrease dock size (Large \u2192 Medium \u2192 Small \u2192 Tiny \u2192 Mini \u2192 Micro)</span>
                  <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+M</code>
                  <span>Toggle toolbar visibility (show/hide entire dock and sidebar)</span>
                  <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+B</code>
                  <span>Toggle Shop (opens/closes both seed and egg sidebars)</span>
                  <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Escape</code>
                  <span>Close shop sidebars</span>
                  <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Custom</code>
                  <span>Set your own hotkeys for tabs and pet presets in Hotkeys tab (\u2328\uFE0F)</span>
              </div>
              <p style="font-size: 11px; color: #888; margin-top: 12px; padding: 8px; background: rgba(255, 200, 100, 0.30); border-radius: 4px; border-left: 3px solid #ffc864;">
                  <strong>\u26A0\uFE0F Note:</strong> Ctrl+1-9 removed to avoid conflicts with game hotbar controls.<br>
                  Use the Hotkeys tab to set custom keys for opening tabs and loading pet presets!
              </p>
              <p style="font-size: 11px; color: #888; margin-top: 8px; padding: 8px; background: rgba(74, 158, 255, 0.30); border-radius: 4px; border-left: 3px solid #4a9eff;">
                  <strong>\u{1F3AE} Pet Preset Hotkeys:</strong><br>
                  \u2022 Click "Set Hotkey" button next to any preset<br>
                  \u2022 Press your desired key combination<br>
                  \u2022 Hotkey will instantly load that preset when pressed<br>
                  \u2022 Perfect for quick pet swapping during gameplay!
              </p>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F4CA} Turtle Timer & Slot Value</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Slot Value:</strong> Always shows when standing on crops (\u{1F4B0} gold text)</li>
                  <li style="margin-bottom: 4px;"><strong>Turtle Timer:</strong> Green countdown shown when turtle pet is active</li>
                  <li style="margin-bottom: 4px;"><strong>Display Location:</strong> Appears below crop growth timer in-game</li>
                  <li style="margin-bottom: 4px;"><strong>Values:</strong> Calculated from species value \xD7 scale \xD7 hybrid multiplier \xD7 friend bonus</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F534}\u{1F7E2} Version Indicator</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Green Dot (\u25CF):</strong> You're up to date! \u2713</li>
                  <li style="margin-bottom: 4px;"><strong>Yellow Dot (\u25CF):</strong> Development version (newer than GitHub)</li>
                  <li style="margin-bottom: 4px;"><strong>Red Dot (\u25CF):</strong> Update available</li>
                  <li style="margin-bottom: 4px;"><strong>Orange Dot (\u25CF):</strong> Version check failed (network/404 error)</li>
                  <li style="margin-bottom: 4px;"><strong>Click Dot:</strong> Manually refresh version check (bypasses GitHub cache)</li>
                  <li style="margin-bottom: 4px;"><strong>Shift+Click Dot:</strong> Open script on GitHub (when red/orange)</li>
                  <li style="margin-bottom: 4px;"><strong>Location:</strong> Hover \u22EF icon in dock to reveal version dot</li>
                  <li style="margin-bottom: 4px;"><strong>How it works:</strong> Checks GitHub for version.json or magicgardenunified.user.js (tries main/master branches with cache-busting)</li>
                  <li style="margin-bottom: 4px;"><strong>Cache delay:</strong> GitHub CDN caches files ~2-5 min, click dot to force refresh</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F43E} Pet Management</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Save Presets:</strong> Store your current pet setup with a custom name</li>
                  <li style="margin-bottom: 4px;"><strong>Load Presets:</strong> Quickly deploy saved pet configurations</li>
                  <li style="margin-bottom: 4px;"><strong>Reorder Presets:</strong> Use \u2191\u2193 arrows or drag-and-drop to organize your preset list</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F512} Crop Protection</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Lock Species:</strong> Prevent harvesting specific crop types (e.g., Pepper, Starweaver)</li>
                  <li style="margin-bottom: 4px;"><strong>Lock Mutations:</strong> Block harvesting crops with certain mutations (Rainbow, Frozen)</li>
                  <li style="margin-bottom: 4px;"><strong>All Unlocked by Default:</strong> Crops can be harvested normally until you lock them</li>
                  <li style="margin-bottom: 4px;"><strong>Sell Protection:</strong> Set minimum friend bonus threshold (1.0x-1.5x / 0%-50%) before selling allowed</li>
                  <li style="margin-bottom: 4px;"><strong>Smart Blocking:</strong> Prevents both manual and automated harvesting of locked crops</li>
                  <li style="margin-bottom: 4px;"><strong>Real-time Updates:</strong> Changes take effect immediately without reload</li>
                  <li style="margin-bottom: 4px;"><strong>Status Display:</strong> View all currently protected crops at a glance</li>
              </ul>
              <p style="font-size: 11px; color: #888; margin-top: 12px; padding: 8px; background: rgba(74, 158, 255, 0.30); border-radius: 4px; border-left: 3px solid #4a9eff;">
                  <strong>\u{1F4A1} Pro Tip:</strong> Use crop protection to safeguard valuable mutations while auto-harvesting everything else. Set sell protection to 1.5x (50% bonus) to ensure you only sell during maximum friend bonus!
              </p>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u26A1 Ability Tracking</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Automatic Logging:</strong> All pet abilities are tracked automatically</li>
                  <li style="margin-bottom: 4px;"><strong>Filter by Category:</strong> View specific types of abilities (XP, Selling, etc.)</li>
                  <li style="margin-bottom: 4px;"><strong>Filter by Pet:</strong> See abilities from specific pet species</li>
                  <li style="margin-bottom: 4px;"><strong>Detailed Timestamps:</strong> Enable to show HH:MM:SS format timestamps</li>
                  <li style="margin-bottom: 4px;"><strong>Export Data:</strong> Download ability logs as CSV for analysis</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F331} Seeds & Automation</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Mass Deletion:</strong> Select multiple seed types for bulk deletion</li>
                  <li style="margin-bottom: 4px;"><strong>Auto-Delete:</strong> Automatically remove unwanted seeds as they appear</li>
                  <li style="margin-bottom: 4px;"><strong>Value Calculation:</strong> See total value of selected seeds before deletion</li>
                  <li style="margin-bottom: 4px;"><strong>Quick Selection:</strong> Use preset buttons for common seed types</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F6D2} Shop Interface</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Dual Sidebars:</strong> Seeds on left, eggs on right (both open together)</li>
                  <li style="margin-bottom: 4px;"><strong>Color-Coded Names:</strong> Item rarity shown by text color (rainbow for celestial)</li>
                  <li style="margin-bottom: 4px;"><strong>Auto-Restock Detection:</strong> Purchase tracking resets when shop restocks</li>
                  <li style="margin-bottom: 4px;"><strong>Sort & Filter:</strong> Show available only, sort by value</li>
                  <li style="margin-bottom: 4px;"><strong>Quick Purchase:</strong> Buy 1 or All buttons for each item</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F514} Notifications</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Shop Monitoring:</strong> Get alerts when rare seeds/eggs appear</li>
                  <li style="margin-bottom: 4px;"><strong>Multiple Notifications:</strong> Single click dismisses all pending alerts</li>
                  <li style="margin-bottom: 4px;"><strong>Continuous Mode:</strong> Must be enabled via checkbox for persistent alerts</li>
                  <li style="margin-bottom: 4px;"><strong>Sound Types:</strong> Choose from beep, alarm, fanfare, or continuous alerts</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F3A8} Customization</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Themes:</strong> Switch between normal, dark, and other visual themes</li>
                  <li style="margin-bottom: 4px;"><strong>Compact Modes:</strong> Use compact or ultra-compact layouts to save space</li>
                  <li style="margin-bottom: 4px;"><strong>Overlays:</strong> Pop out tabs into separate in-game overlays</li>
                  <li style="margin-bottom: 4px;"><strong>Crop Highlighting:</strong> Visually highlight specific crops in your garden</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u2753 Troubleshooting</div>
              <ul style="margin-left: 16px; margin-bottom: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Crop Highlighting Not Working:</strong> Ensure the game is fully loaded before using highlighting</li>
                  <li style="margin-bottom: 4px;"><strong>Notifications Not Playing:</strong> Check volume settings and browser audio permissions</li>
                  <li style="margin-bottom: 4px;"><strong>Pet Presets Not Saving:</strong> Wait for success confirmation before switching tabs</li>
                  <li style="margin-bottom: 4px;"><strong>Performance Issues:</strong> Try compact mode or disable debug logging in settings</li>
              </ul>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F4A1} Tips & Best Practices</div>
              <ul style="margin-left: 16px;">
                  <li style="margin-bottom: 4px;"><strong>Regular Backups:</strong> Export ability logs periodically for data safety</li>
                  <li style="margin-bottom: 4px;"><strong>Preset Organization:</strong> Use descriptive names and reorder presets by frequency of use</li>
                  <li style="margin-bottom: 4px;"><strong>Notification Management:</strong> Enable continuous mode only for critical alerts</li>
                  <li style="margin-bottom: 4px;"><strong>Resource Monitoring:</strong> Use the Values tab to track inventory and garden worth</li>
              </ul>
          </div>
      `;
  }
  function getHotkeysTabContent(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const hotkeys = UnifiedState3?.data?.hotkeys || { enabled: false, gameKeys: {}, mgToolsKeys: {} };
    return `
          <div class="mga-section">
              <div class="mga-section-title">\u{1F3AE} Custom Hotkeys</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Click any key button to set a custom keybind. Press ESC to cancel.
              </p>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px;">
                      <input type="checkbox" id="hotkeys-enabled" class="mga-checkbox"
                             ${hotkeys.enabled ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>Enable custom hotkeys</span>
                  </label>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title" style="font-size: 13px;">Game Controls</div>
                  ${Object.entries(hotkeys.gameKeys || {}).map(
      ([key, config2]) => `
                      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 5px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                          <span style="font-size: 12px; flex: 1;">${config2.name}</span>
                          <button class="hotkey-button" data-key="${key}" style="
                              padding: 4px 8px;
                              background: ${config2.custom ? "rgba(100, 255, 100, 0.48)" : "rgba(74, 158, 255, 0.48)"};
                              border: 1px solid ${config2.custom ? "#64ff64" : "#4a9eff"};
                              border-radius: 4px;
                              color: white;
                              font-size: 11px;
                              min-width: 80px;
                              cursor: pointer;
                          ">
                              ${config2.custom ? `${config2.original.toUpperCase()} \u2192 ${config2.custom.toUpperCase()}` : config2.original.toUpperCase()}
                          </button>
                          ${config2.custom ? `
                              <button class="hotkey-reset" data-key="${key}" style="
                                  margin-left: 5px;
                                  padding: 2px 6px;
                                  background: rgba(255, 100, 100, 0.48);
                                  border: 1px solid #ff6464;
                                  border-radius: 3px;
                                  color: white;
                                  font-size: 10px;
                                  cursor: pointer;
                              ">\u21BA</button>
                          ` : ""}
                      </div>
                  `
    ).join("")}
              </div>

              <div class="mga-section">
                  <div class="mga-section-title" style="font-size: 13px;">MGTools Navigation & Features</div>
                  ${Object.entries(hotkeys.mgToolsKeys || {}).map(
      ([key, config2]) => `
                      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 5px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                          <span style="font-size: 12px; flex: 1;">${config2.name}</span>
                          <button class="hotkey-button-mgtools" data-key="${key}" style="
                              padding: 4px 8px;
                              background: ${config2.custom ? "rgba(100, 255, 100, 0.48)" : "rgba(74, 158, 255, 0.48)"};
                              border: 1px solid ${config2.custom ? "#64ff64" : "#4a9eff"};
                              border-radius: 4px;
                              color: white;
                              font-size: 11px;
                              min-width: 80px;
                              cursor: pointer;
                          ">
                              ${config2.custom ? config2.custom.toUpperCase() : "Not Set"}
                          </button>
                          ${config2.custom ? `
                              <button class="hotkey-reset-mgtools" data-key="${key}" style="
                                  margin-left: 5px;
                                  padding: 2px 6px;
                                  background: rgba(255, 100, 100, 0.48);
                                  border: 1px solid #ff6464;
                                  border-radius: 3px;
                                  color: white;
                                  font-size: 10px;
                                  cursor: pointer;
                              ">\u21BA</button>
                          ` : ""}
                      </div>
                  `
    ).join("")}
              </div>

              <div style="display: flex; gap: 10px; margin-top: 15px;">
                  <button id="hotkeys-reset-all" class="mga-button" style="flex: 1;">
                      Reset All
                  </button>
                  <button id="hotkeys-export" class="mga-button" style="flex: 1;">
                      Export Config
                  </button>
              </div>
          </div>
      `;
  }

  // src/ui/hotkey-help.js
  var hotkey_help_exports = {};
  __export(hotkey_help_exports, {
    hideHotkeyHelp: () => hideHotkeyHelp,
    showHotkeyHelp: () => showHotkeyHelp
  });

  // src/controller/shortcuts.js
  var shortcuts_exports = {};
  __export(shortcuts_exports, {
    ShortcutsController: () => ShortcutsController,
    formatShortcut: () => formatShortcut,
    getShortcutsByCategory: () => getShortcutsByCategory
  });
  var SHORTCUTS = {
    // Help & Info
    SHOW_HELP: { key: "?", modifiers: { shift: true }, action: "show-help", description: "Show keyboard shortcuts help" },
    // Panel Navigation
    TOGGLE_MAIN_PANEL: { key: "m", modifiers: {}, action: "toggle-main-panel", description: "Toggle main panel" },
    FOCUS_SEARCH: { key: "/", modifiers: {}, action: "focus-search", description: "Focus search field" },
    // Tab Switching
    TAB_PETS: { key: "1", modifiers: { alt: true }, action: "switch-tab-pets", description: "Switch to Pets tab" },
    TAB_ABILITIES: {
      key: "2",
      modifiers: { alt: true },
      action: "switch-tab-abilities",
      description: "Switch to Abilities tab"
    },
    TAB_SEEDS: { key: "3", modifiers: { alt: true }, action: "switch-tab-seeds", description: "Switch to Seeds tab" },
    TAB_VALUES: { key: "4", modifiers: { alt: true }, action: "switch-tab-values", description: "Switch to Values tab" },
    TAB_TIMERS: { key: "5", modifiers: { alt: true }, action: "switch-tab-timers", description: "Switch to Timers tab" },
    TAB_ROOMS: { key: "6", modifiers: { alt: true }, action: "switch-tab-rooms", description: "Switch to Rooms tab" },
    TAB_SHOP: { key: "7", modifiers: { alt: true }, action: "switch-tab-shop", description: "Switch to Shop tab" },
    TAB_SETTINGS: {
      key: "8",
      modifiers: { alt: true },
      action: "switch-tab-settings",
      description: "Switch to Settings tab"
    },
    // Quick Actions
    REFRESH_DATA: { key: "r", modifiers: { ctrl: true }, action: "refresh-data", description: "Refresh data" },
    TOGGLE_COMPACT: { key: "c", modifiers: { ctrl: true }, action: "toggle-compact", description: "Toggle compact mode" },
    // Escape
    CLOSE_MODAL: { key: "Escape", modifiers: {}, action: "close-modal", description: "Close modal/popout" }
  };
  var ShortcutsController = class {
    constructor(options = {}) {
      this.enabled = true;
      this.shortcuts = { ...SHORTCUTS };
      this.listeners = [];
      this.boundHandleKeyDown = null;
      this.boundHandleKeyUp = null;
      Logger.info("SHORTCUTS", "ShortcutsController initialized");
    }
    /**
     * Check if modifiers match
     * @param {KeyboardEvent} event - Keyboard event
     * @param {Object} modifiers - Required modifiers
     * @returns {boolean} - True if modifiers match
     */
    _modifiersMatch(event, modifiers = {}) {
      const ctrl = modifiers.ctrl || false;
      const alt = modifiers.alt || false;
      const shift = modifiers.shift || false;
      const meta = modifiers.meta || false;
      return event.ctrlKey === ctrl && event.altKey === alt && event.shiftKey === shift && event.metaKey === meta;
    }
    /**
     * Handle keydown event
     * @param {KeyboardEvent} event - Keyboard event
     */
    _handleKeyDown(event) {
      if (!this.enabled) return;
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable)) {
        if (event.key !== "Escape") {
          return;
        }
      }
      for (const [name, shortcut] of Object.entries(this.shortcuts)) {
        const keyMatches = event.key === shortcut.key || event.code === shortcut.key;
        const modifiersMatch = this._modifiersMatch(event, shortcut.modifiers);
        if (keyMatches && modifiersMatch) {
          Logger.debug("SHORTCUTS", `Shortcut triggered: ${name} (${shortcut.action})`);
          event.preventDefault();
          event.stopPropagation();
          emit(`shortcut:${shortcut.action}`, {
            name,
            key: shortcut.key,
            modifiers: shortcut.modifiers,
            description: shortcut.description
          });
          break;
        }
      }
    }
    /**
     * Handle keyup event
     * @param {KeyboardEvent} event - Keyboard event
     */
    _handleKeyUp(event) {
    }
    /**
     * Start listening for keyboard shortcuts
     */
    start() {
      if (this.boundHandleKeyDown) {
        Logger.warn("SHORTCUTS", "Shortcuts already started");
        return;
      }
      this.boundHandleKeyDown = this._handleKeyDown.bind(this);
      this.boundHandleKeyUp = this._handleKeyUp.bind(this);
      document.addEventListener("keydown", this.boundHandleKeyDown, true);
      document.addEventListener("keyup", this.boundHandleKeyUp, true);
      Logger.info("SHORTCUTS", "Keyboard shortcuts started");
    }
    /**
     * Stop listening for keyboard shortcuts
     */
    stop() {
      if (!this.boundHandleKeyDown) {
        Logger.warn("SHORTCUTS", "Shortcuts not running");
        return;
      }
      document.removeEventListener("keydown", this.boundHandleKeyDown, true);
      document.removeEventListener("keyup", this.boundHandleKeyUp, true);
      this.boundHandleKeyDown = null;
      this.boundHandleKeyUp = null;
      Logger.info("SHORTCUTS", "Keyboard shortcuts stopped");
    }
    /**
     * Enable shortcuts
     */
    enable() {
      this.enabled = true;
      Logger.debug("SHORTCUTS", "Shortcuts enabled");
    }
    /**
     * Disable shortcuts
     */
    disable() {
      this.enabled = false;
      Logger.debug("SHORTCUTS", "Shortcuts disabled");
    }
    /**
     * Register a new shortcut
     * @param {string} name - Shortcut name
     * @param {Object} config - Shortcut configuration
     */
    register(name, config2) {
      this.shortcuts[name] = config2;
      Logger.debug("SHORTCUTS", `Registered shortcut: ${name}`);
    }
    /**
     * Unregister a shortcut
     * @param {string} name - Shortcut name
     */
    unregister(name) {
      delete this.shortcuts[name];
      Logger.debug("SHORTCUTS", `Unregistered shortcut: ${name}`);
    }
    /**
     * Get all registered shortcuts
     * @returns {Object} - Shortcuts map
     */
    getShortcuts() {
      return { ...this.shortcuts };
    }
  };
  function formatShortcut(shortcut) {
    const parts = [];
    if (shortcut.modifiers.ctrl) parts.push("Ctrl");
    if (shortcut.modifiers.alt) parts.push("Alt");
    if (shortcut.modifiers.shift) parts.push("Shift");
    if (shortcut.modifiers.meta) parts.push("Cmd");
    parts.push(shortcut.key.toUpperCase());
    return parts.join(" + ");
  }
  function getShortcutsByCategory() {
    return {
      "Help & Info": [SHORTCUTS.SHOW_HELP],
      "Panel Navigation": [SHORTCUTS.TOGGLE_MAIN_PANEL, SHORTCUTS.FOCUS_SEARCH],
      "Tab Switching": [
        SHORTCUTS.TAB_PETS,
        SHORTCUTS.TAB_ABILITIES,
        SHORTCUTS.TAB_SEEDS,
        SHORTCUTS.TAB_VALUES,
        SHORTCUTS.TAB_TIMERS,
        SHORTCUTS.TAB_ROOMS,
        SHORTCUTS.TAB_SHOP,
        SHORTCUTS.TAB_SETTINGS
      ],
      "Quick Actions": [SHORTCUTS.REFRESH_DATA, SHORTCUTS.TOGGLE_COMPACT],
      Navigation: [SHORTCUTS.CLOSE_MODAL]
    };
  }
  Logger.info("SHORTCUTS", "Shortcuts controller module loaded");

  // src/ui/hotkey-help.js
  var helpOverlay = null;
  function showHotkeyHelp(options = {}) {
    const { shortcuts = null } = options;
    if (helpOverlay) {
      hideHotkeyHelp();
    }
    const shortcutsByCategory = shortcuts || getShortcutsByCategory();
    helpOverlay = el("div", {
      className: "mgtools-hotkey-help-overlay",
      style: {
        position: "fixed",
        top: "0",
        left: "0",
        right: "0",
        bottom: "0",
        background: "rgba(0, 0, 0, 0.75)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: "99999999",
        animation: "mgtools-fade-in 0.2s ease-out"
      }
    });
    const modal = el("div", {
      className: "mgtools-hotkey-help-modal",
      style: {
        background: "white",
        borderRadius: "12px",
        padding: "24px",
        maxWidth: "700px",
        maxHeight: "80vh",
        overflowY: "auto",
        boxShadow: "0 8px 32px rgba(0, 0, 0, 0.3)",
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
      }
    });
    const title = el(
      "h2",
      {
        style: {
          margin: "0 0 20px 0",
          fontSize: "24px",
          fontWeight: "600",
          color: "#333",
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between"
        }
      },
      "Keyboard Shortcuts"
    );
    const closeBtn = el(
      "button",
      {
        className: "mgtools-hotkey-help-close",
        style: {
          padding: "8px 12px",
          border: "none",
          borderRadius: "6px",
          background: "#f3f4f6",
          color: "#6b7280",
          fontSize: "14px",
          fontWeight: "500",
          cursor: "pointer",
          transition: "background 0.2s"
        }
      },
      "\u2715 Close"
    );
    closeBtn.addEventListener("click", hideHotkeyHelp);
    closeBtn.addEventListener("mouseenter", () => {
      closeBtn.style.background = "#e5e7eb";
    });
    closeBtn.addEventListener("mouseleave", () => {
      closeBtn.style.background = "#f3f4f6";
    });
    title.appendChild(closeBtn);
    const grid = el("div", {
      style: {
        display: "grid",
        gap: "24px"
      }
    });
    for (const [category, categoryShortcuts] of Object.entries(shortcutsByCategory)) {
      const categorySection = el("div", {
        style: {
          borderBottom: "1px solid #e5e7eb",
          paddingBottom: "16px"
        }
      });
      const categoryTitle = el(
        "h3",
        {
          style: {
            margin: "0 0 12px 0",
            fontSize: "14px",
            fontWeight: "600",
            color: "#6b7280",
            textTransform: "uppercase",
            letterSpacing: "0.5px"
          }
        },
        category
      );
      const shortcutList = el("div", {
        style: {
          display: "grid",
          gap: "8px"
        }
      });
      categoryShortcuts.forEach((shortcut) => {
        const shortcutRow = el("div", {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            padding: "8px 12px",
            background: "#f9fafb",
            borderRadius: "6px"
          }
        });
        const description = el(
          "span",
          {
            style: {
              fontSize: "14px",
              color: "#374151"
            }
          },
          shortcut.description
        );
        const keys = el(
          "kbd",
          {
            style: {
              padding: "4px 8px",
              borderRadius: "4px",
              background: "white",
              border: "1px solid #d1d5db",
              fontSize: "13px",
              fontFamily: "monospace",
              color: "#1f2937",
              boxShadow: "0 1px 2px rgba(0, 0, 0, 0.05)"
            }
          },
          formatShortcut(shortcut)
        );
        shortcutRow.appendChild(description);
        shortcutRow.appendChild(keys);
        shortcutList.appendChild(shortcutRow);
      });
      categorySection.appendChild(categoryTitle);
      categorySection.appendChild(shortcutList);
      grid.appendChild(categorySection);
    }
    modal.appendChild(title);
    modal.appendChild(grid);
    helpOverlay.appendChild(modal);
    helpOverlay.addEventListener("click", (e) => {
      if (e.target === helpOverlay) {
        hideHotkeyHelp();
      }
    });
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        hideHotkeyHelp();
        document.removeEventListener("keydown", handleEscape);
      }
    };
    document.addEventListener("keydown", handleEscape);
    document.body.appendChild(helpOverlay);
    Logger.info("HOTKEY_HELP", "Hotkey help overlay shown");
    injectHelpAnimations();
    return helpOverlay;
  }
  function hideHotkeyHelp() {
    if (!helpOverlay) {
      return;
    }
    helpOverlay.style.animation = "mgtools-fade-out 0.2s ease-out";
    setTimeout(() => {
      if (helpOverlay && helpOverlay.parentNode) {
        helpOverlay.parentNode.removeChild(helpOverlay);
      }
      helpOverlay = null;
      Logger.info("HOTKEY_HELP", "Hotkey help overlay hidden");
    }, 200);
  }
  var animationsInjected2 = false;
  function injectHelpAnimations() {
    if (animationsInjected2) return;
    const css = `
    @keyframes mgtools-fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes mgtools-fade-out {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    /* Scrollbar styling for help modal */
    .mgtools-hotkey-help-modal::-webkit-scrollbar {
      width: 8px;
    }

    .mgtools-hotkey-help-modal::-webkit-scrollbar-track {
      background: #f3f4f6;
      border-radius: 4px;
    }

    .mgtools-hotkey-help-modal::-webkit-scrollbar-thumb {
      background: #d1d5db;
      border-radius: 4px;
    }

    .mgtools-hotkey-help-modal::-webkit-scrollbar-thumb:hover {
      background: #9ca3af;
    }
  `;
    try {
      const style = document.createElement("style");
      style.textContent = css;
      document.head.appendChild(style);
      animationsInjected2 = true;
      Logger.debug("HOTKEY_HELP", "Help overlay animations injected");
    } catch (error) {
      Logger.error("HOTKEY_HELP", "Failed to inject animations", error);
    }
  }
  ensureStyles();
  Logger.info("HOTKEY_HELP", "Hotkey help UI module loaded");

  // src/ui/asset-manager.js
  var asset_manager_exports = {};
  __export(asset_manager_exports, {
    createAssetManager: () => createAssetManager,
    initializeAssetManager: () => initializeAssetManager
  });
  function createAssetManager(dependencies = {}) {
    const {
      CompatibilityMode: CompatibilityMode2,
      Logger: Logger2,
      GM_addElement: gmAddElement = typeof GM_addElement !== "undefined" ? GM_addElement : null,
      GM_addStyle: gmAddStyle = typeof GM_addStyle !== "undefined" ? GM_addStyle : null,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null
    } = dependencies;
    function addStyles(css, id) {
      if (gmAddElement && CompatibilityMode2?.flags?.enabled) {
        try {
          const attrs = { textContent: css };
          if (id) attrs.id = id;
          gmAddElement("style", attrs);
          Logger2?.debug("ASSETS", `Added styles via GM_addElement${id ? ` (${id})` : ""} (Discord-safe)`);
          return;
        } catch (e) {
          Logger2?.warn("ASSETS", "GM_addElement failed, falling back to standard method", e);
        }
      }
      if (CompatibilityMode2?.flags?.domOnlyStyles) {
        const style = targetDocument2.createElement("style");
        style.textContent = css;
        if (id) style.id = id;
        targetDocument2.head.appendChild(style);
        Logger2?.debug("ASSETS", `Injected inline styles${id ? ` (${id})` : ""}`);
      } else {
        if (gmAddStyle) {
          gmAddStyle(css);
        } else {
          const style = targetDocument2.createElement("style");
          style.textContent = css;
          if (id) style.id = id;
          targetDocument2.head.appendChild(style);
        }
        Logger2?.debug("ASSETS", `Added styles${id ? ` (${id})` : ""}`);
      }
    }
    function loadFonts() {
      if (CompatibilityMode2?.flags?.blockExternalFonts) {
        addStyles(
          `
          .mgtools-ui *, .mga-dock *, .mga-sidebar *, .mga-panel * {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                         Roboto, Helvetica, Arial, sans-serif !important;
          }
          .fancy-header, .mgtools-header {
            font-family: Georgia, "Times New Roman", serif !important;
            font-style: italic;
          }
        `,
          "mgtools-compat-fonts"
        );
        Logger2?.info("ASSETS", "Using system fonts (compat mode)");
      } else {
        Logger2?.debug("ASSETS", "External fonts allowed (normal mode)");
      }
    }
    function getIcon(name) {
      const icons = {
        pet: "\u{1F43E}",
        timer: "\u23F0",
        shop: "\u{1F6D2}",
        seeds: "\u{1F331}",
        values: "\u{1F48E}",
        abilities: "\u26A1",
        rooms: "\u{1F3E0}",
        tools: "\u{1F527}",
        settings: "\u2699\uFE0F",
        hotkeys: "\u2328\uFE0F",
        help: "\u2753",
        alert: "\u{1F514}",
        close: "\u2716\uFE0F",
        refresh: "\u{1F504}",
        save: "\u{1F4BE}",
        export: "\u{1F4E4}",
        import: "\u{1F4E5}"
      };
      return icons[name] || "\u{1F4E6}";
    }
    return {
      addStyles,
      loadFonts,
      getIcon
    };
  }
  function initializeAssetManager(dependencies = {}) {
    const assetManager = createAssetManager(dependencies);
    assetManager.loadFonts();
    return assetManager;
  }

  // src/controller/version-check.js
  var version_check_exports = {};
  __export(version_check_exports, {
    checkAndPromptUpdate: () => checkAndPromptUpdate,
    detectCurrentBranch: () => detectCurrentBranch,
    runVersionCheck: () => runVersionCheck,
    scheduleVersionChecks: () => scheduleVersionChecks
  });
  async function runVersionCheck(options = {}) {
    const { badgeRoot = null, isLiveBeta = false, onSwitchBranch = null } = options;
    if (!badgeRoot || !(badgeRoot instanceof HTMLElement)) {
      Logger.error("VERSION_CHECK", "Invalid badgeRoot provided to runVersionCheck");
      return { success: false, error: "Invalid container" };
    }
    Logger.info("VERSION_CHECK", "Running version check...");
    try {
      const versionMeta = await fetchLatestVersionMeta();
      if (!versionMeta || !versionMeta.version) {
        Logger.warn("VERSION_CHECK", "Failed to fetch version metadata");
        return { success: false, error: "Fetch failed" };
      }
      const { version: availableVersion, branch: availableBranch } = versionMeta;
      const currentVersion = CONFIG.VERSION.CURRENT;
      const currentBranch = isLiveBeta ? "Live Beta" : "Stable";
      Logger.info(
        "VERSION_CHECK",
        `Current: v${currentVersion} (${currentBranch}), Available: v${availableVersion} (${availableBranch})`
      );
      const comparison = compareVersions(currentVersion, availableVersion);
      const isOutdated = comparison < 0;
      renderVersionBadge(badgeRoot, {
        currentVersion,
        availableVersion,
        branch: currentBranch,
        isOutdated
      });
      if (isOutdated && typeof onSwitchBranch === "function") {
        wireVersionSwitchHandlers(badgeRoot, {
          onSwitch: (switchData) => {
            Logger.info("VERSION_CHECK", `User initiating branch switch: ${switchData.from} \u2192 ${switchData.to}`);
            onSwitchBranch(switchData);
          }
        });
        showVersionOutdatedToast({
          currentVersion,
          availableVersion,
          branch: currentBranch,
          targetBranch: availableBranch
        });
        Logger.warn("VERSION_CHECK", `Version outdated: v${currentVersion} \u2192 v${availableVersion}`);
      } else if (isOutdated) {
        Logger.warn("VERSION_CHECK", "Version outdated but no switch handler provided");
      } else {
        Logger.info("VERSION_CHECK", "Version is up-to-date");
      }
      return {
        success: true,
        currentVersion,
        availableVersion,
        currentBranch,
        availableBranch,
        isOutdated,
        comparison
      };
    } catch (error) {
      Logger.error("VERSION_CHECK", "Version check failed", error);
      return { success: false, error: error.message };
    }
  }
  function scheduleVersionChecks(options = {}) {
    const {
      badgeRoot = null,
      intervalMs = 60 * 60 * 1e3,
      // 1 hour default
      isLiveBeta = false,
      onSwitchBranch = null,
      runImmediately = true
    } = options;
    if (!badgeRoot || !(badgeRoot instanceof HTMLElement)) {
      Logger.error("VERSION_CHECK", "Invalid badgeRoot provided to scheduleVersionChecks");
      return { start: () => {
      }, stop: () => {
      } };
    }
    let intervalId = null;
    let isRunning3 = false;
    const start = () => {
      if (isRunning3) {
        Logger.warn("VERSION_CHECK", "Version checks already running");
        return;
      }
      Logger.info("VERSION_CHECK", `Scheduling version checks every ${intervalMs}ms`);
      if (runImmediately) {
        runVersionCheck({
          badgeRoot,
          isLiveBeta,
          onSwitchBranch
        }).catch((error) => {
          Logger.error("VERSION_CHECK", "Initial version check failed", error);
        });
      }
      intervalId = setInterval(() => {
        runVersionCheck({
          badgeRoot,
          isLiveBeta,
          onSwitchBranch
        }).catch((error) => {
          Logger.error("VERSION_CHECK", "Scheduled version check failed", error);
        });
      }, intervalMs);
      isRunning3 = true;
      Logger.debug("VERSION_CHECK", "Version check scheduler started");
    };
    const stop = () => {
      if (!isRunning3) {
        Logger.warn("VERSION_CHECK", "Version checks not running");
        return;
      }
      if (intervalId !== null) {
        clearInterval(intervalId);
        intervalId = null;
      }
      isRunning3 = false;
      Logger.debug("VERSION_CHECK", "Version check scheduler stopped");
    };
    return { start, stop };
  }
  async function checkAndPromptUpdate(options = {}) {
    const { badgeRoot = null, isLiveBeta = false, onUpdateAvailable = null } = options;
    Logger.info("VERSION_CHECK", "Manual version refresh requested");
    const result = await runVersionCheck({
      badgeRoot,
      isLiveBeta,
      onSwitchBranch: (switchData) => {
        Logger.info("VERSION_CHECK", `Manual update: ${switchData.from} \u2192 ${switchData.to}`);
        if (typeof onUpdateAvailable === "function") {
          onUpdateAvailable(switchData);
        }
      }
    });
    if (result.success && result.isOutdated) {
      Logger.info("VERSION_CHECK", "Update available via manual check");
      return true;
    } else if (result.success) {
      Logger.info("VERSION_CHECK", "No update available");
      return false;
    } else {
      Logger.error("VERSION_CHECK", "Manual version check failed");
      return false;
    }
  }
  function detectCurrentBranch() {
    if (typeof GM_info !== "undefined" && GM_info?.script?.updateURL) {
      const isLiveBeta = GM_info.script.updateURL.includes("Live-Beta");
      return {
        isLiveBeta,
        branch: isLiveBeta ? "Live Beta" : "Stable",
        source: "GM_info"
      };
    }
    const currentVersion = CONFIG.VERSION.CURRENT;
    if (currentVersion.includes("beta") || currentVersion.includes("Beta")) {
      return {
        isLiveBeta: true,
        branch: "Live Beta",
        source: "version_string"
      };
    }
    return {
      isLiveBeta: false,
      branch: "Stable",
      source: "default"
    };
  }
  Logger.info("VERSION_CHECK", "Version check controller module loaded");

  // src/controller/room-poll.js
  var room_poll_exports = {};
  __export(room_poll_exports, {
    RoomPollController: () => RoomPollController
  });
  var pollTimer = null;
  var currentBackoffMs = 0;
  var config = {
    roomIdOrCode: null,
    intervalMs: 5e3,
    jitterMs: 500,
    maxBackoffMs: 3e4
  };
  var eventHandlers2 = {
    open: [],
    update: [],
    error: [],
    close: []
  };
  var isRunning = false;
  var hasOpenedOnce = false;
  function emit2(event, data) {
    if (eventHandlers2[event]) {
      eventHandlers2[event].forEach((handler) => {
        try {
          handler(data);
        } catch (e) {
          Logger.error("ROOM_POLL", `Event handler error for ${event}`, e);
        }
      });
    }
  }
  function applyJitter(baseMs, jitterMs) {
    const jitter = Math.random() * jitterMs;
    return baseMs + jitter;
  }
  function calculateBackoff(currentMs, maxMs) {
    if (currentMs === 0) {
      return 1e3;
    }
    const next = Math.min(currentMs * 2, maxMs);
    return next;
  }
  function resetBackoff() {
    currentBackoffMs = 0;
  }
  async function pollOnce() {
    if (!isRunning || !config.roomIdOrCode) {
      return;
    }
    try {
      const result = await fetchRoomInfo(config.roomIdOrCode);
      if (!result.ok) {
        throw new Error(`Room API returned status ${result.status}`);
      }
      const players = parsePlayerCount(result.parsed);
      const data = result.parsed;
      const ts = Date.now();
      if (!hasOpenedOnce) {
        hasOpenedOnce = true;
        emit2("open", { ts, players, data });
        Logger.info("ROOM_POLL", `Opened connection for room: ${config.roomIdOrCode}`);
      }
      emit2("update", { players, data, ts });
      Logger.debug("ROOM_POLL", `Update received: ${players} players`);
      resetBackoff();
      const nextInterval = applyJitter(config.intervalMs, config.jitterMs);
      pollTimer = setTimeout(() => pollOnce(), nextInterval);
    } catch (err) {
      Logger.warn("ROOM_POLL", `Poll failed: ${err.message}`);
      const ts = Date.now();
      emit2("error", { err, ts });
      currentBackoffMs = calculateBackoff(currentBackoffMs, config.maxBackoffMs);
      Logger.info("ROOM_POLL", `Backing off for ${currentBackoffMs}ms`);
      const retryDelay = applyJitter(currentBackoffMs, config.jitterMs);
      pollTimer = setTimeout(() => pollOnce(), retryDelay);
    }
  }
  var RoomPollController = {
    /**
     * Start polling for room updates
     * @param {Object} opts - Configuration options
     * @param {string} opts.roomIdOrCode - Room ID or code to poll
     * @param {number} [opts.intervalMs=5000] - Poll interval in milliseconds
     * @param {number} [opts.jitterMs=500] - Max jitter to add to intervals
     * @param {number} [opts.maxBackoffMs=30000] - Maximum backoff delay
     */
    start(opts) {
      if (!opts.roomIdOrCode) {
        throw new Error("roomIdOrCode is required");
      }
      this.stop();
      config = {
        roomIdOrCode: opts.roomIdOrCode,
        intervalMs: opts.intervalMs ?? 5e3,
        jitterMs: opts.jitterMs ?? 500,
        maxBackoffMs: opts.maxBackoffMs ?? 3e4
      };
      isRunning = true;
      hasOpenedOnce = false;
      currentBackoffMs = 0;
      Logger.info(
        "ROOM_POLL",
        `Starting poll for room: ${config.roomIdOrCode} (interval: ${config.intervalMs}ms, jitter: ${config.jitterMs}ms)`
      );
      pollOnce();
    },
    /**
     * Stop polling and clear timers
     */
    stop() {
      if (!isRunning) {
        return;
      }
      isRunning = false;
      if (pollTimer) {
        clearTimeout(pollTimer);
        pollTimer = null;
      }
      Logger.info("ROOM_POLL", "Stopped polling");
      emit2("close", { ts: Date.now() });
      hasOpenedOnce = false;
      currentBackoffMs = 0;
    },
    /**
     * Register event handler
     * @param {string} event - Event name ('open', 'update', 'error', 'close')
     * @param {Function} handler - Event handler function
     *
     * Event data:
     * - open: { ts, players, data }
     * - update: { players, data, ts }
     * - error: { err, ts }
     * - close: { ts }
     */
    on(event, handler) {
      if (eventHandlers2[event]) {
        eventHandlers2[event].push(handler);
      } else {
        Logger.warn("ROOM_POLL", `Unknown event: ${event}`);
      }
    },
    /**
     * Unregister event handler
     * @param {string} event - Event name
     * @param {Function} handler - Event handler function
     */
    off(event, handler) {
      if (eventHandlers2[event]) {
        eventHandlers2[event] = eventHandlers2[event].filter((h) => h !== handler);
      }
    },
    /**
     * Get current status
     * @returns {Object} - { isRunning, roomIdOrCode, intervalMs, backoffMs }
     */
    getStatus() {
      return {
        isRunning,
        roomIdOrCode: config.roomIdOrCode,
        intervalMs: config.intervalMs,
        backoffMs: currentBackoffMs
      };
    }
  };

  // src/controller/app-core.js
  var app_core_exports = {};
  __export(app_core_exports, {
    AppCore: () => AppCore
  });
  var isRunning2 = false;
  var eventHandlers3 = [];
  var versionScheduler = null;
  var roomPollController = null;
  var shortcutsController = null;
  function wireRoomPollEvents() {
    const handlers = [];
    const onOpen = (data) => {
      Logger.debug("APP_CORE", "Room poll opened, forwarding to UI");
      emit("conn:open", data);
    };
    const onUpdate = (data) => {
      Logger.debug("APP_CORE", `Room poll update: ${data.players} players`);
      emit("conn:update", data);
    };
    const onError = (data) => {
      Logger.warn("APP_CORE", `Room poll error: ${data.err.message}`);
      emit("conn:error", data);
    };
    const onClose = (data) => {
      Logger.debug("APP_CORE", "Room poll closed");
      emit("conn:close", data);
    };
    RoomPollController.on("open", onOpen);
    RoomPollController.on("update", onUpdate);
    RoomPollController.on("error", onError);
    RoomPollController.on("close", onClose);
    handlers.push(
      { controller: RoomPollController, event: "open", handler: onOpen },
      { controller: RoomPollController, event: "update", handler: onUpdate },
      { controller: RoomPollController, event: "error", handler: onError },
      { controller: RoomPollController, event: "close", handler: onClose }
    );
    return handlers;
  }
  function wireShortcutEvents() {
    const handlers = [];
    const onShortcutHelp = (data) => {
      Logger.debug("APP_CORE", `Shortcut help requested: ${data.description}`);
    };
    const onShortcutAction = (data) => {
      Logger.debug("APP_CORE", `Shortcut action: ${data.name}`);
    };
    on("shortcut:show-help", onShortcutHelp);
    on("shortcut:*", onShortcutAction);
    handlers.push(
      { bus: "ui", event: "shortcut:show-help", handler: onShortcutHelp },
      { bus: "ui", event: "shortcut:*", handler: onShortcutAction }
    );
    return handlers;
  }
  var AppCore = {
    /**
     * Start the application core
     * @param {Object} opts - Configuration options
     * @param {string} opts.roomIdOrCode - Room ID or code to monitor
     * @param {number} [opts.pollIntervalMs=5000] - Room poll interval in milliseconds
     * @param {number} [opts.jitterMs=500] - Jitter for poll interval
     * @param {HTMLElement} [opts.versionBadgeRoot=null] - Container for version badge UI
     * @param {boolean} [opts.isLiveBeta=false] - Whether running on Live Beta branch
     * @param {Function} [opts.onSwitchBranch=null] - Callback when user switches branch
     * @param {number} [opts.versionCheckIntervalMs=3600000] - Version check interval (1 hour default)
     */
    start(opts = {}) {
      if (isRunning2) {
        Logger.warn("APP_CORE", "Core already running");
        return;
      }
      Logger.info("APP_CORE", "Starting application core...");
      const {
        roomIdOrCode = null,
        pollIntervalMs = 5e3,
        jitterMs = 500,
        versionBadgeRoot = null,
        isLiveBeta = false,
        onSwitchBranch = null,
        versionCheckIntervalMs = 60 * 60 * 1e3
        // 1 hour
      } = opts;
      if (versionBadgeRoot) {
        Logger.debug("APP_CORE", "Starting version check scheduler");
        versionScheduler = scheduleVersionChecks({
          badgeRoot: versionBadgeRoot,
          intervalMs: versionCheckIntervalMs,
          isLiveBeta,
          onSwitchBranch,
          runImmediately: true
        });
        versionScheduler.start();
      } else {
        Logger.warn("APP_CORE", "No version badge root provided, skipping version checks");
      }
      if (roomIdOrCode) {
        Logger.debug("APP_CORE", `Starting room poll for: ${roomIdOrCode}`);
        const roomHandlers = wireRoomPollEvents();
        eventHandlers3.push(...roomHandlers);
        RoomPollController.start({
          roomIdOrCode,
          intervalMs: pollIntervalMs,
          jitterMs
        });
        roomPollController = RoomPollController;
      } else {
        Logger.warn("APP_CORE", "No room ID provided, skipping room poll");
      }
      Logger.debug("APP_CORE", "Starting shortcuts controller");
      shortcutsController = new ShortcutsController();
      shortcutsController.start();
      const shortcutHandlers = wireShortcutEvents();
      eventHandlers3.push(...shortcutHandlers);
      isRunning2 = true;
      Logger.info("APP_CORE", "Application core started successfully");
    },
    /**
     * Stop the application core
     */
    stop() {
      if (!isRunning2) {
        Logger.warn("APP_CORE", "Core not running");
        return;
      }
      Logger.info("APP_CORE", "Stopping application core...");
      if (versionScheduler) {
        Logger.debug("APP_CORE", "Stopping version scheduler");
        versionScheduler.stop();
        versionScheduler = null;
      }
      if (roomPollController) {
        Logger.debug("APP_CORE", "Stopping room poll controller");
        roomPollController.stop();
        roomPollController = null;
      }
      if (shortcutsController) {
        Logger.debug("APP_CORE", "Stopping shortcuts controller");
        shortcutsController.stop();
        shortcutsController = null;
      }
      eventHandlers3.forEach(({ controller, bus, event, handler }) => {
        if (controller && controller.off) {
          Logger.debug("APP_CORE", `Unregistering controller event: ${event}`);
          controller.off(event, handler);
        } else if (bus === "ui") {
          Logger.debug("APP_CORE", `Unregistering UI bus event: ${event}`);
          off(event, handler);
        }
      });
      eventHandlers3 = [];
      isRunning2 = false;
      Logger.info("APP_CORE", "Application core stopped");
    },
    /**
     * Get current status
     * @returns {Object} - { isRunning, controllers }
     */
    getStatus() {
      return {
        isRunning: isRunning2,
        controllers: {
          versionScheduler: versionScheduler !== null,
          roomPoll: roomPollController !== null,
          shortcuts: shortcutsController !== null
        },
        eventHandlerCount: eventHandlers3.length
      };
    }
  };

  // src/init/early-traps.js
  var early_traps_exports = {};
  __export(early_traps_exports, {
    installAllEarlyTraps: () => installAllEarlyTraps,
    installCSPGuard: () => installCSPGuard,
    installEarlyRoomConnectionTrap: () => installEarlyRoomConnectionTrap,
    logDiagnostics: () => logDiagnostics,
    rcSend: () => rcSend
  });
  function installEarlyRoomConnectionTrap(dependencies = {}) {
    const {
      unsafeWindow: unsafeWin,
      // Passed via dependencies - no default to avoid circular reference
      window: win = typeof window !== "undefined" ? window : null,
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      }, warn: () => {
      } },
      Object: ObjectClass = typeof Object !== "undefined" ? Object : null,
      Array: ArrayClass = typeof Array !== "undefined" ? Array : null
    } = dependencies;
    const unsafeWindow2 = unsafeWin || (typeof globalThis.unsafeWindow !== "undefined" ? globalThis.unsafeWindow : null);
    const KEY = "MagicCircle_RoomConnection";
    const targetWin = unsafeWindow2 || win;
    if (!targetWin) {
      consoleFn.warn("[MGTools] No target window available for RoomConnection trap");
      return;
    }
    if (targetWin.__mg_rc_trap_installed) return;
    targetWin.__mg_rc_trap_installed = true;
    function installHooks(rc) {
      if (!rc || rc.__mg_scope_installed) return;
      rc.__mg_scope_installed = true;
      const setLast = (sp) => {
        if (ArrayClass.isArray(sp)) {
          targetWin.__mga_lastScopePath = sp.slice();
        }
      };
      const origSend = rc.sendMessage?.bind(rc);
      if (origSend) {
        rc.sendMessage = function(msg) {
          try {
            setLast(msg?.scopePath);
          } catch (e) {
          }
          return origSend(msg);
        };
      }
      const origDispatch = rc.dispatch?.bind(rc) || rc._dispatch?.bind(rc);
      if (origDispatch) {
        rc.dispatch = function(evt) {
          try {
            setLast(evt?.scopePath);
          } catch (e) {
          }
          return origDispatch(evt);
        };
      }
    }
    if (targetWin[KEY]) {
      try {
        installHooks(targetWin[KEY]);
      } catch (e) {
        consoleFn.warn("[MGTools ScopePatch] install now failed", e);
      }
      return;
    }
    let _rc;
    ObjectClass.defineProperty(targetWin, KEY, {
      configurable: true,
      enumerable: true,
      get() {
        return _rc;
      },
      set(v) {
        _rc = v;
        try {
          installHooks(v);
        } catch (e) {
          consoleFn.warn("[MGTools ScopePatch] install on set failed", e);
        }
      }
    });
  }
  async function rcSend(payload, options = {}, dependencies = {}) {
    const {
      unsafeWindow: unsafeWin,
      // Passed via dependencies - no default to avoid circular reference
      window: win = typeof window !== "undefined" ? window : null,
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      }, warn: () => {
      }, error: () => {
      } },
      setTimeout: setTimeoutFn = typeof setTimeout !== "undefined" ? setTimeout : null,
      Promise: PromiseClass = typeof Promise !== "undefined" ? Promise : null,
      Array: ArrayClass = typeof Array !== "undefined" ? Array : null
    } = dependencies;
    const unsafeWindow2 = unsafeWin || (typeof globalThis.unsafeWindow !== "undefined" ? globalThis.unsafeWindow : null);
    const { retries = 10, delay = 120 } = options;
    const targetWin = unsafeWindow2 || win;
    if (!targetWin) {
      consoleFn.warn("[MGTools] No target window available for rcSend");
      return;
    }
    if (!payload || typeof payload !== "object") {
      consoleFn.warn("[MGTools] rcSend invalid payload:", payload);
      return;
    }
    for (let i = 0; i <= retries; i++) {
      const sp = targetWin.__mga_lastScopePath;
      if (ArrayClass.isArray(sp)) {
        payload.scopePath = sp.slice();
        break;
      }
      if (i === retries) {
        payload.scopePath = ["Room"];
        consoleFn.warn('[MGTools] Using fallback scopePath ["Room"]');
      }
      await new PromiseClass((r) => setTimeoutFn(r, delay));
    }
    try {
      targetWin.MagicCircle_RoomConnection?.sendMessage(payload);
    } catch (e) {
      consoleFn.error("[MGTools] rcSend error", e);
    }
  }
  function installCSPGuard(dependencies = {}) {
    const {
      window: win = typeof window !== "undefined" ? window : null,
      document: doc = typeof document !== "undefined" ? document : null,
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      } }
    } = dependencies;
    if (!doc || !win) {
      return;
    }
    try {
      const isDiscord = /discord|overlay|electron/i.test(win.navigator?.userAgent || "") || win.DiscordNative || win.__discordApp;
      if (isDiscord) {
        consoleFn.log("\u{1F6E1}\uFE0F [CSP] External font loads disabled in Discord context.");
      }
      const origCreateElement = doc.constructor.prototype.createElement;
      doc.constructor.prototype.createElement = function(tag) {
        const el2 = origCreateElement.call(this, tag);
        try {
          if (isDiscord && tag && tag.toLowerCase() === "link") {
            const origSetAttribute = el2.setAttribute;
            el2.setAttribute = function(name, value) {
              if (name === "href" && typeof value === "string" && /fonts\.googleapis/i.test(value)) {
                consoleFn.log("\u{1F6E1}\uFE0F [CSP] Prevented external font link injection:", value);
                return;
              }
              return origSetAttribute.apply(this, arguments);
            };
          }
        } catch (e) {
        }
        return el2;
      };
    } catch (e) {
    }
  }
  function logDiagnostics(dependencies = {}) {
    const {
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      }, error: () => {
      } },
      window: win = typeof window !== "undefined" ? window : null,
      Date: DateClass = typeof Date !== "undefined" ? Date : null,
      navigator: nav = typeof navigator !== "undefined" ? navigator : null
    } = dependencies;
    consoleFn.error("\u{1F6A8}\u{1F6A8}\u{1F6A8} MGTOOLS LOADING - IF YOU SEE THIS, SCRIPT IS RUNNING \u{1F6A8}\u{1F6A8}\u{1F6A8}");
    consoleFn.log("[MGTOOLS-DEBUG] 1. Script file loaded");
    consoleFn.log("[MGTOOLS-DEBUG] \u26A1 VERSION: 2.0.0 - Pet auto-favorite fixes + Micro/Mini dock sizes");
    consoleFn.log("[MGTOOLS-DEBUG] \u{1F550} Load Time:", new DateClass().toISOString());
    consoleFn.log("[MGTOOLS-DEBUG] 2. Location:", win?.location?.href || "unknown");
    consoleFn.log("[MGTOOLS-DEBUG] 3. Navigator:", nav?.userAgent || "unknown");
    consoleFn.log("[MGTOOLS-DEBUG] 4. Window type:", win === win?.top ? "TOP" : "IFRAME");
  }
  function installAllEarlyTraps(dependencies = {}) {
    logDiagnostics(dependencies);
    installCSPGuard(dependencies);
    installEarlyRoomConnectionTrap(dependencies);
  }

  // src/init/legacy-bootstrap.js
  var legacy_bootstrap_exports = {};
  __export(legacy_bootstrap_exports, {
    addDemoBanner: () => addDemoBanner,
    cleanupCorruptedDockPosition: () => cleanupCorruptedDockPosition2,
    continueInitialization: () => continueInitialization,
    generateDemoTiles: () => generateDemoTiles,
    initializeBasedOnEnvironment: () => initializeBasedOnEnvironment,
    initializeScript: () => initializeScript,
    initializeStandalone: () => initializeStandalone,
    setupDemoTimers: () => setupDemoTimers,
    sortInventoryKeepHeadAndSendMovesOptimized: () => sortInventoryKeepHeadAndSendMovesOptimized,
    waitForGameReady: () => waitForGameReady
  });
  function cleanupCorruptedDockPosition2({ localStorage: localStorage3, console: console2 }) {
    try {
      const dockPos = localStorage3.getItem("mgh_dock_position");
      if (dockPos) {
        try {
          const parsed = JSON.parse(dockPos);
          if (typeof parsed !== "object" || parsed === null || parsed.x !== void 0 && typeof parsed.x !== "number" || parsed.y !== void 0 && typeof parsed.y !== "number") {
            console2.warn("\u26A0\uFE0F Corrupted dock position detected, clearing...");
            localStorage3.removeItem("mgh_dock_position");
          }
        } catch (e) {
          console2.warn("\u26A0\uFE0F Invalid dock position JSON, clearing...", e);
          localStorage3.removeItem("mgh_dock_position");
        }
      }
    } catch (error) {
      console2.error("\u274C Error cleaning dock position:", error);
    }
  }
  function generateDemoTiles(count, { dateNow, mathRandom }) {
    const tiles = {};
    const species = ["Carrot", "Apple", "Banana", "Lily", "Dragon Fruit"];
    for (let i = 0; i < count; i++) {
      tiles[i] = {
        objectType: "plant",
        slots: [
          {
            species: species[i % species.length],
            endTime: dateNow() - 1e3,
            // Ready for harvest
            targetScale: 1 + mathRandom() * 0.5,
            // Random scale
            mutations: i % 3 === 0 ? ["Gold"] : []
            // Some have mutations
          }
        ]
      };
    }
    return tiles;
  }
  function sortInventoryKeepHeadAndSendMovesOptimized(inventoryObj, options = {}, deps) {
    const { connection, console: console2 } = deps;
    if (!inventoryObj || !Array.isArray(inventoryObj.items)) {
      console2.error("[MGTOOLS-FIX-D] Invalid inventory object passed to sorter.");
      return null;
    }
    const items = inventoryObj.items;
    const fixedCount = Number(options.fixedCount || 9);
    const petSortBy = options.petSortBy === "rarity" ? "rarity" : "xp";
    const defaultPetRarityMap = {
      Capybara: 0,
      Peacock: 0.1,
      Butterfly: 0.2,
      // Mythical
      Turtle: 1,
      Goat: 1.1,
      // Legendary
      Cow: 2,
      Pig: 2.1,
      // Rare
      Chicken: 3,
      Dragonfly: 3.1,
      // Uncommon
      Bee: 4,
      Worm: 4.1,
      Snail: 4.2
      // Common
    };
    const petRarityMap = Object.assign({}, defaultPetRarityMap, options.petRarityMap || {});
    const toNum = (v) => typeof v === "number" ? v : Number(v) || 0;
    const toStr = (v) => v == null ? "" : String(v);
    function groupRank(item) {
      if (!item) return 6;
      switch (item.itemType) {
        case "Seed":
          return 0;
        case "Produce":
          return 1;
        case "Pet":
          return 2;
        case "Egg":
          return 3;
        case "Decor":
          return 4;
        default:
          return 5;
      }
    }
    function seedMetric(it) {
      return toNum(it.quantity);
    }
    function produceMetric(it) {
      return toNum(it.scale);
    }
    function petXpMetric(it) {
      return toNum(it.xp);
    }
    function eggMetric(it) {
      return toNum(it.quantity);
    }
    function decorMetric(it) {
      return toStr(it.decorId).toLowerCase();
    }
    function fallbackKey(it) {
      return (it && (it.species || it.decorId || it.toolId || it.eggId || it.id || "")).toString().toLowerCase();
    }
    function petRarityRank(species) {
      if (!species) return Number.MAX_SAFE_INTEGER;
      if (Object.prototype.hasOwnProperty.call(petRarityMap, species)) return petRarityMap[species];
      const lower = species.toLowerCase();
      for (const k of Object.keys(petRarityMap)) {
        if (k.toLowerCase() === lower) return petRarityMap[k];
      }
      return Number.MAX_SAFE_INTEGER;
    }
    function cmp(a, b) {
      const ga = groupRank(a);
      const gb = groupRank(b);
      if (ga !== gb) return ga - gb;
      switch (ga) {
        case 0: {
          const d = seedMetric(b) - seedMetric(a);
          if (d !== 0) return d;
          break;
        }
        case 1: {
          const d = produceMetric(b) - produceMetric(a);
          if (d !== 0) return d;
          break;
        }
        case 2: {
          if (petSortBy === "rarity") {
            const ra = petRarityRank(a.petSpecies || a.species);
            const rb = petRarityRank(b.petSpecies || b.species);
            if (ra !== rb) return ra - rb;
            const d = petXpMetric(b) - petXpMetric(a);
            if (d !== 0) return d;
            const sa = (a.petSpecies || a.species || "").toString().toLowerCase();
            const sb = (b.petSpecies || b.species || "").toString().toLowerCase();
            if (sa < sb) return -1;
            if (sa > sb) return 1;
            break;
          } else {
            const d = petXpMetric(b) - petXpMetric(a);
            if (d !== 0) return d;
          }
          break;
        }
        case 3: {
          const d = eggMetric(b) - eggMetric(a);
          if (d !== 0) return d;
          break;
        }
        case 4: {
          const da = decorMetric(a);
          const db = decorMetric(b);
          if (da < db) return -1;
          if (da > db) return 1;
          break;
        }
        default:
          break;
      }
      const fa = fallbackKey(a);
      const fb = fallbackKey(b);
      if (fa < fb) return -1;
      if (fa > fb) return 1;
      return 0;
    }
    function getMoveItemId(item) {
      if (!item) return null;
      if (item.id) return item.id;
      if (item.species) return item.species;
      if (item.toolId) return item.toolId;
      if (item.eggId) return item.eggId;
      if (item.decorId) return item.decorId;
      return null;
    }
    const head = items.slice(0, fixedCount);
    const tail = items.slice(fixedCount);
    const sortedTail = tail.slice().sort(cmp);
    const targetOrder = head.concat(sortedTail);
    const working = items.slice();
    function findIndexInWorking(desiredItem) {
      if (!desiredItem) return -1;
      if (desiredItem.id) {
        for (let i = 0; i < working.length; i++) {
          const it = working[i];
          if (it && it.id && it.id === desiredItem.id) return i;
        }
      }
      const candidates = [];
      for (let i = 0; i < working.length; i++) {
        const it = working[i];
        if (!it) continue;
        if (desiredItem.species && it.species && it.species === desiredItem.species) {
          candidates.push({ idx: i, score: toNum(it.quantity) });
          continue;
        }
        if (desiredItem.toolId && it.toolId && it.toolId === desiredItem.toolId) {
          candidates.push({ idx: i, score: toNum(it.quantity) });
          continue;
        }
        if (desiredItem.eggId && it.eggId && it.eggId === desiredItem.eggId) {
          candidates.push({ idx: i, score: toNum(it.quantity) });
          continue;
        }
        if (desiredItem.decorId && it.decorId && it.decorId === desiredItem.decorId) {
          candidates.push({ idx: i, score: 0 });
          continue;
        }
        if (desiredItem.itemType === "Pet" && desiredItem.petSpecies && it.itemType === "Pet" && it.petSpecies === desiredItem.petSpecies) {
          candidates.push({ idx: i, score: toNum(it.xp) });
          continue;
        }
      }
      if (candidates.length === 0) {
        const want = getMoveItemId(desiredItem);
        if (!want) return -1;
        for (let i = 0; i < working.length; i++) {
          const it = working[i];
          if (!it) continue;
          if (it.id && it.id === want || it.species && it.species === want || it.toolId && it.toolId === want || it.eggId && it.eggId === want || it.decorId && it.decorId === want) {
            return i;
          }
        }
        return -1;
      }
      candidates.sort((a, b) => b.score - a.score);
      return candidates[0].idx;
    }
    function sendMove(moveItemId, toIndex) {
      if (!moveItemId || typeof toIndex !== "number") return;
      const msg = {
        scopePath: ["Room", "Quinoa"],
        type: "MoveInventoryItem",
        moveItemId,
        toInventoryIndex: toIndex
      };
      if (connection && typeof connection.sendMessage === "function") {
        connection.sendMessage(msg);
      } else {
        console2.warn("[MGTOOLS-FIX-D] MagicCircle_RoomConnection not available \u2014 simulated move:", msg);
      }
    }
    const moves = [];
    for (let targetIndex = fixedCount; targetIndex < targetOrder.length; targetIndex++) {
      const desiredItem = targetOrder[targetIndex];
      const workingItem = working[targetIndex];
      const desiredKey = getMoveItemId(desiredItem);
      const workingKey = getMoveItemId(workingItem);
      const alreadySame = desiredKey && workingKey && (desiredKey === workingKey || desiredItem.species && workingItem.species && desiredItem.species === workingItem.species);
      if (alreadySame) continue;
      const curIndex = findIndexInWorking(desiredItem);
      if (curIndex === -1) {
        console2.warn("[MGTOOLS-FIX-D] Could not find desired item in current inventory for", desiredItem);
        continue;
      }
      const moveId = getMoveItemId(desiredItem);
      if (!moveId) {
        console2.warn("[MGTOOLS-FIX-D] No moveItemId for", desiredItem);
        continue;
      }
      moves.push({ moveId, from: curIndex, to: targetIndex });
      const [moved] = working.splice(curIndex, 1);
      working.splice(targetIndex, 0, moved);
    }
    for (const m of moves) {
      sendMove(m.moveId, m.to);
    }
    console2.log("[MGTOOLS-FIX-D] \u2705 Sort completed. Moves sent:", moves.length, moves);
    return targetOrder;
  }
  function initializeStandalone(deps) {
    const {
      UnifiedState: UnifiedState3,
      document: document2,
      createDemoData,
      loadSavedData,
      createUnifiedUI: createUnifiedUI2,
      ensureUIHealthy: ensureUIHealthy2,
      setupToolbarToggle: setupToolbarToggle2,
      setupDockSizeControl: setupDockSizeControl2,
      addDemoBanner: addDemoBanner2,
      setupDemoTimers: setupDemoTimers2,
      console: console2,
      productionLog: productionLog3,
      debugError: debugError2,
      cleanupCorruptedDockPosition: cleanupCorruptedDockPosition3,
      generateDemoTiles: generateDemoTiles2
    } = deps;
    if (UnifiedState3.initialized) {
      productionLog3("\u26A0\uFE0F Magic Garden Unified Assistant already initialized, skipping...");
      return;
    }
    productionLog3("\u{1F3AE} Magic Garden Assistant - Demo Mode");
    productionLog3("\u{1F4A1} Running in standalone mode with demo data");
    productionLog3("\u{1F4DD} Note: This is a demonstration - no real game integration");
    if (document2.readyState === "loading") {
      productionLog3("\u23F3 DOM not ready, waiting for DOMContentLoaded...");
      document2.addEventListener("DOMContentLoaded", () => initializeStandalone(deps));
      return;
    }
    try {
      const demoData = createDemoData();
      UnifiedState3.atoms.inventory = demoData.inventory;
      UnifiedState3.atoms.myGarden = {
        garden: {
          tileObjects: generateDemoTiles2(demoData.garden.readyTiles)
        }
      };
      UnifiedState3.atoms.friendBonus = 1.2;
      productionLog3("\u{1F4DD} Skipping demo ability logs injection - using real logs only");
      UnifiedState3.data.timers = demoData.timers;
      productionLog3("\u{1F4BE} Loading saved settings...");
      loadSavedData();
      productionLog3("\u{1F3A8} Creating Demo UI...");
      cleanupCorruptedDockPosition3();
      createUnifiedUI2();
      ensureUIHealthy2();
      setupToolbarToggle2();
      setupDockSizeControl2();
      addDemoBanner2();
      productionLog3("\u23F0 Setting up demo timers...");
      setupDemoTimers2();
      UnifiedState3.initialized = true;
      productionLog3("\u2705 Magic Garden Assistant Demo initialized successfully!");
      productionLog3("\u{1F3AF} Try the features - they work with realistic demo data");
    } catch (error) {
      console2.error("\u274C Failed to initialize demo mode:", error);
      debugError2("STANDALONE_INIT", "Demo initialization failed", error);
      UnifiedState3.initialized = false;
    }
  }
  function addDemoBanner({ UnifiedState: UnifiedState3, document: document2 }) {
    const panel = UnifiedState3.panels.main;
    if (!panel) return;
    const banner = document2.createElement("div");
    banner.style.cssText = `
    background: linear-gradient(90deg, #3b82f6, #8b5cf6);
    color: white;
    text-align: center;
    padding: 6px 12px;
    font-size: 11px;
    font-weight: 600;
    position: relative;
    margin: -1px -1px 8px -1px;
    border-radius: 6px 6px 0 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.30);
  `;
    banner.innerHTML = "\u{1F3AE} DEMO MODE - Showcasing full functionality with sample data";
    const header = panel.querySelector(".mga-header");
    if (header) {
      panel.insertBefore(banner, header.nextSibling);
    }
  }
  function setupDemoTimers({ UnifiedState: UnifiedState3, timerManager, initializeTimerManager: initializeTimerManager2, updateTimerDisplay: updateTimerDisplay2 }) {
    const manager = timerManager || initializeTimerManager2();
    manager.startTimer("demo-timer", 1e3, () => {
      if (UnifiedState3.data.timers.seed > 0) UnifiedState3.data.timers.seed--;
      if (UnifiedState3.data.timers.egg > 0) UnifiedState3.data.timers.egg--;
      if (UnifiedState3.data.timers.tool > 0) UnifiedState3.data.timers.tool--;
      updateTimerDisplay2();
    });
  }
  function initializeScript(deps) {
    const {
      UnifiedState: UnifiedState3,
      document: document2,
      targetWindow: targetWindow3,
      continueInitialization: continueInitialization2,
      setTimeout: setTimeout2,
      performanceNow,
      startIntervals,
      console: console2,
      productionLog: productionLog3,
      productionWarn: productionWarn3,
      MGA_DEBUG
    } = deps;
    if (MGA_DEBUG) {
      MGA_DEBUG.logStage("INITIALIZE_SCRIPT_CALLED", {
        initialized: UnifiedState3.initialized,
        domState: document2.readyState,
        retryAttempt: targetWindow3.MGA_initRetryCount || 0
      });
    }
    if (UnifiedState3.initialized) {
      productionLog3("\u26A0\uFE0F Magic Garden Unified Assistant already initialized, skipping...");
      if (MGA_DEBUG) {
        MGA_DEBUG.logStage("ALREADY_INITIALIZED", { skipReason: "UnifiedState.initialized is true" });
      }
      return;
    }
    if (document2.readyState === "loading") {
      productionLog3("\u23F3 DOM not ready, waiting for DOMContentLoaded...");
      if (MGA_DEBUG) {
        MGA_DEBUG.logStage("DOM_NOT_READY", { domState: document2.readyState });
      }
      document2.addEventListener("DOMContentLoaded", () => initializeScript(deps));
      return;
    }
    productionLog3("\u23F3 Waiting for game initialization to complete...");
    let retryCount = 0;
    const maxRetries = 3;
    const gameAlreadyReady = (targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache) && targetWindow3.MagicCircle_RoomConnection;
    const initialDelay = gameAlreadyReady ? 0 : 2e3;
    const attemptInit = () => {
      const gameReadiness = {
        jotaiAtomCache: !!targetWindow3.jotaiAtomCache,
        magicCircleConnection: !!targetWindow3.MagicCircle_RoomConnection,
        jotaiType: typeof targetWindow3.jotaiAtomCache,
        connectionType: typeof targetWindow3.MagicCircle_RoomConnection
      };
      if (MGA_DEBUG) {
        MGA_DEBUG.logStage("GAME_READINESS_CHECK", {
          retryCount,
          maxRetries,
          gameReadiness,
          timestamp: performanceNow()
        });
      }
      if (targetWindow3.jotaiAtomCache && targetWindow3.MagicCircle_RoomConnection) {
        productionLog3("\u2705 Game ready, initializing script...");
        if (MGA_DEBUG) {
          MGA_DEBUG.logStage("GAME_READY", gameReadiness);
          if (MGA_DEBUG.performanceMetrics) {
            MGA_DEBUG.performanceMetrics.gameReady = performanceNow();
          }
        }
        continueInitialization2(deps);
      } else if (retryCount < maxRetries) {
        retryCount++;
        productionLog3(
          `\u23F3 Game not ready (jotaiAtomCache: ${!!targetWindow3.jotaiAtomCache}, RoomConnection: ${!!targetWindow3.MagicCircle_RoomConnection}), retry ${retryCount}/${maxRetries} in 1s...`
        );
        if (MGA_DEBUG) {
          MGA_DEBUG.logStage("GAME_NOT_READY_RETRYING", { retryCount, gameReadiness });
        }
        setTimeout2(attemptInit, 1e3);
      } else {
        productionWarn3("\u26A0\uFE0F Max retries reached, initializing anyway...");
        if (MGA_DEBUG) {
          MGA_DEBUG.logStage("MAX_RETRIES_REACHED", { retryCount, gameReadiness });
        }
        continueInitialization2(deps);
      }
    };
    setTimeout2(attemptInit, initialDelay);
    setTimeout2(() => {
      if (typeof targetWindow3.notificationInterval === "undefined" || !targetWindow3._mgaIntervalsStarted) {
        productionWarn3("\u26A0\uFE0F [FAILSAFE] Intervals not started after 30s, forcing start...");
        try {
          if (typeof startIntervals === "function") {
            startIntervals();
            productionLog3("\u2705 [FAILSAFE] Successfully started intervals");
          } else {
            console2.error("\u274C [FAILSAFE] startIntervals function not found!");
          }
        } catch (e) {
          console2.error("\u274C [FAILSAFE] Could not start intervals:", e);
        }
      } else {
        productionLog3("\u2705 [FAILSAFE] Intervals already running, no action needed");
      }
    }, 3e4);
  }
  function continueInitialization(deps) {
    const {
      UnifiedState: UnifiedState3,
      targetWindow: targetWindow3,
      document: document2,
      setTimeout: setTimeout2,
      performanceNow,
      console: console2,
      productionLog: productionLog3,
      productionWarn: productionWarn3,
      debugLog: debugLog3,
      debugError: debugError2,
      MGA_DEBUG,
      loadSavedData,
      cleanupCorruptedDockPosition: cleanupCorruptedDockPosition3,
      createUnifiedUI: createUnifiedUI2,
      ensureUIHealthy: ensureUIHealthy2,
      setupToolbarToggle: setupToolbarToggle2,
      setupDockSizeControl: setupDockSizeControl2,
      initializeSortInventoryButton,
      initializeInstantFeedButtons: initializeInstantFeedButtons2,
      initializeAtoms,
      initializeTurtleTimer: initializeTurtleTimer3,
      startIntervals,
      applyTheme,
      applyUltraCompactMode: applyUltraCompactMode2,
      applyWeatherSetting,
      initializeKeyboardShortcuts,
      updateTabContent,
      getContentForTab: getContentForTab2,
      setupSeedsTabHandlers,
      setupPetsTabHandlers: setupPetsTabHandlers2,
      initializeTeleportSystem,
      setupCropHighlightingSystem: setupCropHighlightingSystem2,
      initializeHotkeySystem: initializeHotkeySystem2,
      setManagedInterval: setManagedInterval2,
      clearManagedInterval: clearManagedInterval2
    } = deps;
    productionLog3("\u{1F331} Magic Garden Unified Assistant initializing...");
    productionLog3("\u{1F4CA} Connection Status:", targetWindow3.MagicCircle_RoomConnection ? "\u2705 Available" : "\u274C Not found");
    if (MGA_DEBUG) {
      MGA_DEBUG.logStage("CONTINUE_INITIALIZATION", {
        connectionStatus: !!targetWindow3.MagicCircle_RoomConnection,
        jotaiStatus: !!targetWindow3.jotaiAtomCache,
        domState: document2.readyState,
        timestamp: performanceNow()
      });
    }
    productionLog3("\u{1F4DD} [IDLE-PREVENTION] Idle prevention already applied at script start");
    try {
      productionLog3("\u{1F4BE} Loading saved data...");
      loadSavedData();
      if (MGA_DEBUG) {
        MGA_DEBUG.logStage("CREATE_UI_STARTING", {
          dataLoaded: !!UnifiedState3.data,
          petPresets: Object.keys(UnifiedState3.data?.petPresets || {}).length,
          targetDocumentReady: !!document2.body
        });
      }
      try {
        cleanupCorruptedDockPosition3();
        createUnifiedUI2();
        ensureUIHealthy2();
        setupToolbarToggle2();
        setupDockSizeControl2();
        if (MGA_DEBUG) {
          MGA_DEBUG.logStage("CREATE_UI_COMPLETED", {
            uiElements: document2.querySelectorAll(".mga-panel, .mga-toggle-btn").length,
            mainPanelExists: !!document2.querySelector(".mga-panel"),
            toggleBtnExists: !!document2.querySelector(".mga-toggle-btn")
          });
          if (MGA_DEBUG.performanceMetrics) {
            MGA_DEBUG.performanceMetrics.uiCreated = performanceNow();
          }
        }
        (async () => {
          try {
            console2.log("[MGTools Feed] \u{1F50D} Waiting for Jotai atom cache before initializing feed buttons...");
            const maxWait = 1e4;
            const startTime = Date.now();
            let atomCacheReady = false;
            while (Date.now() - startTime < maxWait) {
              if (targetWindow3.jotaiAtomCache) {
                const elapsed = Date.now() - startTime;
                console2.log(`[MGTools Feed] \u2705 Jotai atom cache ready after ${elapsed}ms`);
                UnifiedState3.jotaiReady = true;
                atomCacheReady = true;
                if (!deps.jotaiStore) {
                  deps.jotaiStore = deps.captureJotaiStore();
                  if (deps.jotaiStore) {
                    console2.log("[MGTools Feed] \u2705 Also captured Jotai store");
                  } else {
                    console2.log("[MGTools Feed] \u2139\uFE0F Store not captured, will use direct atom cache reading");
                  }
                }
                break;
              }
              await new Promise((r) => setTimeout2(r, 200));
            }
            if (!atomCacheReady) {
              console2.warn("[MGTools Feed] \u26A0\uFE0F Jotai atom cache not ready after timeout - initializing anyway");
              UnifiedState3.jotaiReady = false;
            }
            initializeInstantFeedButtons2();
          } catch (error) {
            console2.error("[MGTools] Error initializing instant feed buttons:", error);
          }
        })();
        setTimeout2(() => {
          try {
            initializeSortInventoryButton();
          } catch (error) {
            console2.error("[MGTools] Error initializing sort inventory button:", error);
          }
        }, 1500);
      } catch (error) {
        console2.error("\u274C Error creating UI:", error);
        try {
          const errorDiv = document2.createElement("div");
          errorDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(220, 38, 38, 0.95);
          color: white;
          padding: 20px;
          border-radius: 8px;
          z-index: 9999999;
          font-family: monospace;
          max-width: 500px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        `;
          errorDiv.innerHTML = `
          <div style="font-weight: bold; margin-bottom: 10px; font-size: 14px;">\u274C MGTools UI Failed to Load</div>
          <div style="font-size: 12px; margin-bottom: 10px; color: #fecaca;">${error.message}</div>
          <div style="font-size: 11px; color: #fef2f2;">Press F12 and check Console for details</div>
          <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 8px 16px; background: white; color: #dc2626; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Close</button>
        `;
          document2.body.appendChild(errorDiv);
        } catch (e) {
          console2.error("Failed to show error UI:", e);
        }
        if (MGA_DEBUG) {
          MGA_DEBUG.logError(error, "createUnifiedUI");
        }
        productionWarn3("\u26A0\uFE0F UI creation failed, but continuing with initialization...");
      }
      setTimeout2(() => {
        const checkedSeeds = document2.querySelectorAll(".seed-checkbox:checked");
      }, 100);
      productionLog3("\u{1F517} Initializing atom hooks...");
      initializeAtoms();
      productionLog3("\u{1F422} Initializing turtle timer...");
      initializeTurtleTimer3();
      productionLog3("\u23F1\uFE0F Starting monitoring intervals...");
      startIntervals();
      productionLog3("\u{1F3A8} Applying saved theme settings...");
      applyTheme();
      if (UnifiedState3.data.settings.ultraCompactMode) {
        productionLog3("\u{1F4F1} Applying saved ultra-compact mode...");
        applyUltraCompactMode2(true);
      }
      productionLog3("\u{1F327}\uFE0F Applying saved weather setting...");
      applyWeatherSetting();
      initializeKeyboardShortcuts();
      productionLog3("\u{1F504} Applying delayed UI refresh to ensure saved state is displayed...");
      setTimeout2(() => {
        productionLog3("\u{1F504} [DATA-PERSISTENCE] Applying delayed UI refresh...");
        productionLog3("\u{1F4CA} [DATA-PERSISTENCE] Current state:", {
          petPresets: Object.keys(UnifiedState3.data.petPresets).length,
          seedsToDelete: UnifiedState3.data.seedsToDelete.length,
          autoDeleteEnabled: UnifiedState3.data.autoDeleteEnabled
        });
        if (typeof updateTabContent === "function") {
          updateTabContent();
          productionLog3("\u2705 [DATA-PERSISTENCE] UI refreshed with saved state");
        }
        if (UnifiedState3.data?.popouts?.overlays) {
          UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
            if (overlay && document2.contains(overlay)) {
              try {
                const content = getContentForTab2(tabName, true);
                const contentEl = overlay.querySelector(".mga-overlay-content, .mga-content");
                if (contentEl) {
                  contentEl.innerHTML = content;
                  if (tabName === "seeds" && typeof setupSeedsTabHandlers === "function") {
                    setupSeedsTabHandlers(overlay);
                  } else if (tabName === "pets" && typeof setupPetsTabHandlers2 === "function") {
                    setupPetsTabHandlers2(overlay);
                  }
                  productionLog3(`\u2705 [DATA-PERSISTENCE] Refreshed ${tabName} overlay with saved state`);
                }
              } catch (error) {
                productionWarn3(`\u26A0\uFE0F [DATA-PERSISTENCE] Failed to refresh ${tabName} overlay:`, error);
              }
            }
          });
        }
      }, 1e3);
      initializeTeleportSystem();
      setupCropHighlightingSystem2();
      initializeHotkeySystem2();
      if (targetWindow3.MGA_Tooltips) {
        targetWindow3.MGA_Tooltips.init();
        productionLog3("\u{1F4AC} Tooltip system initialized");
      }
      UnifiedState3.initialized = true;
      targetWindow3._MGA_INITIALIZED = true;
      try {
        delete targetWindow3._MGA_INITIALIZING;
      } catch (e) {
        targetWindow3._MGA_INITIALIZING = false;
      }
      targetWindow3._MGA_TIMESTAMP = Date.now();
      if (targetWindow3.MGA_ConflictDetection) {
        const mainScriptDetected = targetWindow3.MGA_ConflictDetection.detectMainScript();
        if (mainScriptDetected) {
          productionLog3("\u{1F512} [MGA-ISOLATION] External scripts detected - creating protective barriers");
          targetWindow3.MGA_ConflictDetection.createIsolationBarrier();
          targetWindow3.MGA_ConflictDetection.preventAccess();
        }
        const integrityOk = targetWindow3.MGA_ConflictDetection.checkGlobalIntegrity();
        const isolationOk = targetWindow3.MGA_ConflictDetection.validateIsolation();
        if (integrityOk && isolationOk) {
          productionLog3("\u2705 [MGA-ISOLATION] Final integrity check passed - no conflicts detected");
          if (mainScriptDetected) {
            productionLog3("\u2705 [MGA-ISOLATION] Complete isolation validated - external script protection active");
          }
        } else {
          productionWarn3("\u26A0\uFE0F [MGA-ISOLATION] Final integrity check found potential conflicts");
          if (!integrityOk) productionWarn3("\u26A0\uFE0F [MGA-ISOLATION] Global integrity issues detected");
          if (!isolationOk) productionWarn3("\u26A0\uFE0F [MGA-ISOLATION] Isolation validation failed");
        }
      } else {
        productionWarn3("\u26A0\uFE0F [MGA-ISOLATION] ConflictDetection not available - running without isolation");
      }
      productionLog3("\u2705 Magic Garden Unified Assistant initialized successfully!");
      targetWindow3.MGA_SHOW_UI = function() {
        console2.log("%c\u{1F527} MGTools Recovery", "color: #4CAF50; font-weight: bold; font-size: 14px");
        console2.log("Clearing corrupted UI state...");
        try {
          deps.localStorage.removeItem("mgh_toolbar_visible");
          deps.localStorage.removeItem("mgh_dock_position");
          deps.localStorage.removeItem("mgh_dock_orientation");
          console2.log("\u2705 State cleared. Reloading page...");
          setTimeout2(() => deps.location.reload(), 500);
        } catch (e) {
          console2.error("\u274C Recovery failed:", e);
          console2.log("Try manually: localStorage.clear() then refresh");
        }
      };
      console2.log(
        "%c\u{1F3AE} MGTools v" + (typeof deps.GM_info !== "undefined" ? deps.GM_info.script.version : "1.1.1") + " Loaded",
        "color: #4CAF50; font-weight: bold; font-size: 14px"
      );
      console2.log("%c\u{1F4A1} UI not showing? Run in console: MGA_SHOW_UI()", "color: #FFC107; font-size: 12px");
      const testUI = document2.querySelector('div[style*="Test UI Active"]') || document2.querySelector('div[style*="MGA Test UI"]') || Array.from(document2.querySelectorAll("div")).find(
        (div) => div.textContent && div.textContent.includes("Test UI Active")
      );
      if (testUI) {
        testUI.remove();
        debugLog3("UI_LIFECYCLE", "Test UI removed after successful initialization");
      }
      setManagedInterval2(
        "connectionCheck",
        () => {
          const hasConnection = targetWindow3.MagicCircle_RoomConnection && typeof targetWindow3.MagicCircle_RoomConnection.sendMessage === "function";
          if (!UnifiedState3.connectionStatus && hasConnection) {
            productionLog3("\u{1F50C} Game connection established!");
            UnifiedState3.connectionStatus = true;
          } else if (UnifiedState3.connectionStatus && !hasConnection) {
            productionWarn3("\u26A0\uFE0F Game connection lost!");
            UnifiedState3.connectionStatus = false;
          }
        },
        5e3
      );
    } catch (error) {
      console2.error("\u274C Failed to initialize Magic Garden Unified Assistant:", error);
      console2.error("Stack trace:", error.stack);
      UnifiedState3.initialized = false;
    }
  }
  function initializeBasedOnEnvironment(deps) {
    const { detectEnvironment: detectEnvironment3, initializeScript: initializeScript2, waitForGameReady: waitForGameReady2, initializeStandalone: initializeStandalone2, console: console2, productionLog: productionLog3 } = deps;
    console2.log("\u{1F50D}\u{1F50D}\u{1F50D} [EXECUTION] ENTERED initializeBasedOnEnvironment()");
    console2.log("\u{1F50D} [EXECUTION] About to call detectEnvironment()");
    const environment = detectEnvironment3();
    console2.log("\u{1F50D} [EXECUTION] detectEnvironment() returned:", environment);
    productionLog3("\u{1F4CA} Environment Analysis:", {
      domain: environment.domain,
      strategy: environment.initStrategy,
      isGame: environment.isGameEnvironment,
      hasAtoms: environment.hasJotaiAtoms,
      hasConnection: environment.hasMagicCircleConnection
    });
    switch (environment.initStrategy) {
      case "game-ready":
        productionLog3("\u2705 Game environment ready - initializing with full integration");
        initializeScript2(deps);
        break;
      case "game-wait":
        productionLog3("\u23F3 Game environment detected - waiting for game atoms...");
        waitForGameReady2(deps);
        break;
      case "standalone":
        productionLog3("\u{1F3AE} Standalone environment - initializing demo mode");
        initializeStandalone2(deps);
        break;
      case "skip":
        productionLog3("\u23ED\uFE0F Skipping initialization - script will run in game iframe only");
        break;
      default:
        productionLog3("\u2753 Unknown environment - attempting standalone mode");
        initializeStandalone2(deps);
        break;
    }
  }
  function waitForGameReady(deps) {
    const {
      targetWindow: targetWindow3,
      document: document2,
      initializeScript: initializeScript2,
      initializeStandalone: initializeStandalone2,
      setManagedInterval: setManagedInterval2,
      clearManagedInterval: clearManagedInterval2,
      console: console2,
      productionLog: productionLog3
    } = deps;
    let attempts = 0;
    const maxAttempts = 20;
    const checkGameReady = () => {
      const atomCache = targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache;
      const hasAtoms = atomCache && typeof atomCache === "object";
      const hasConnection = targetWindow3.MagicCircle_RoomConnection && typeof targetWindow3.MagicCircle_RoomConnection === "object";
      const hasBasicDom = document2.body && document2.readyState === "complete";
      const hasGameElements = document2.querySelector("canvas") || document2.querySelector('[class*="game"]') || document2.querySelector('[id*="game"]') || document2.querySelector('div[style*="position"]');
      const atomsReady = hasAtoms && atomCache.size > 0;
      if (atomsReady && hasConnection && hasBasicDom || hasBasicDom && hasGameElements && attempts >= 10) {
        if (atomsReady && hasConnection) {
          productionLog3("\u2705 Game atoms and connection fully ready - switching to full mode");
          productionLog3("\u{1F4CA} [GAME-READY] Atoms count:", atomCache.size);
        } else {
          productionLog3("\u2705 Game elements detected, proceeding with reduced functionality mode");
        }
        initializeScript2(deps);
        return true;
      }
      if (attempts % 8 === 0) {
        productionLog3("\u23F3 [GAME-WAIT] Still waiting...", {
          hasAtoms,
          atomsCount: hasAtoms ? atomCache.size : 0,
          hasConnection,
          hasBasicDom,
          hasGameElements,
          readyState: document2.readyState,
          attempt: attempts,
          willProceedAt: attempts >= 10 ? "Next check (fallback mode)" : `Attempt ${10 - attempts} more`
        });
      }
      return false;
    };
    if (!checkGameReady()) {
      setManagedInterval2(
        "gameCheck",
        () => {
          attempts++;
          if (checkGameReady() || attempts >= maxAttempts) {
            clearManagedInterval2("gameCheck");
            if (attempts >= maxAttempts) {
              productionLog3("\u26A0\uFE0F Game readiness timeout - falling back to demo mode");
              productionLog3("\u{1F4A1} You can try MGA.init() later if the game loads");
              initializeStandalone2(deps);
            }
          }
        },
        500
      );
    }
  }

  // src/init/public-api.js
  var public_api_exports = {};
  __export(public_api_exports, {
    createAbilityLogPersistence: () => createAbilityLogPersistence,
    createErrorRecovery: () => createErrorRecovery,
    createLoadingStates: () => createLoadingStates,
    createPerformanceUtils: () => createPerformanceUtils,
    createPublicAPI: () => createPublicAPI,
    createTooltips: () => createTooltips,
    default: () => public_api_default,
    installClearButtonHandler: () => installClearButtonHandler,
    installGMGetValueProxy: () => installGMGetValueProxy,
    installGMSetValueProxy: () => installGMSetValueProxy,
    installLocalStorageProxy: () => installLocalStorageProxy,
    installPublicAPI: () => installPublicAPI,
    wrapLogsArray: () => wrapLogsArray
  });
  function createAbilityLogPersistence(dependencies) {
    const {
      localStorage: storage,
      console: logger,
      GM_getValue: gmGetValue = null,
      GM_setValue: gmSetValue = null
    } = dependencies;
    const LOG_MAIN = "MGA_petAbilityLogs";
    const LOG_ARCH = "MGA_petAbilityLogs_archive";
    const FLAG = "MGA_logs_manually_cleared";
    function gmGet(key, defaultValue = null) {
      try {
        const raw = typeof gmGetValue === "function" ? gmGetValue(key, null) : null;
        if (raw == null) return defaultValue;
        return typeof raw === "string" ? JSON.parse(raw) : raw;
      } catch {
        return defaultValue;
      }
    }
    function gmSet(key, value) {
      try {
        if (typeof gmSetValue === "function") {
          gmSetValue(key, JSON.stringify(value));
        }
      } catch {
      }
    }
    function hardClear() {
      try {
        storage.setItem(FLAG, "true");
        gmSet(LOG_MAIN, []);
        gmSet(LOG_ARCH, []);
        try {
          storage.removeItem(LOG_MAIN);
          storage.removeItem(LOG_ARCH);
        } catch {
        }
        if (window.UnifiedState?.data) {
          window.UnifiedState.data.petAbilityLogs = [];
        }
        if (Array.isArray(window.petAbilityLogs)) {
          window.petAbilityLogs.length = 0;
        }
      } catch (error) {
        logger.error("[MGTools] hardClear logs failed", error);
      }
    }
    function clearFlagIfNeeded() {
      if (storage.getItem(FLAG) === "true") {
        try {
          storage.removeItem(FLAG);
        } catch {
        }
      }
    }
    return {
      hardClear,
      clearFlagIfNeeded,
      LOG_MAIN,
      LOG_ARCH,
      FLAG,
      gmGet,
      gmSet
    };
  }
  function installLocalStorageProxy(dependencies) {
    const { Storage: StoragePrototype, localStorage: storage, LOG_MAIN, LOG_ARCH, FLAG } = dependencies;
    try {
      const originalGetItem = StoragePrototype.prototype.getItem;
      if (!originalGetItem.__mgtoolsPatched) {
        StoragePrototype.prototype.getItem = function(key) {
          if ((key === LOG_MAIN || key === LOG_ARCH) && storage.getItem(FLAG) === "true") {
            return "[]";
          }
          return originalGetItem.apply(this, arguments);
        };
        StoragePrototype.prototype.getItem.__mgtoolsPatched = true;
      }
    } catch (error) {
    }
  }
  function installGMGetValueProxy(dependencies) {
    const { window: win, localStorage: storage, GM_getValue: gmGetValue, LOG_MAIN, LOG_ARCH, FLAG } = dependencies;
    try {
      if (typeof gmGetValue === "function" && !gmGetValue.__mgtoolsPatched) {
        const originalGMGetValue = gmGetValue;
        win.GM_getValue = function(key, defaultValue) {
          if ((key === LOG_MAIN || key === LOG_ARCH) && storage.getItem(FLAG) === "true") {
            return "[]";
          }
          return originalGMGetValue.apply(this, arguments);
        };
        win.GM_getValue.__mgtoolsPatched = true;
      }
    } catch (error) {
    }
  }
  function installGMSetValueProxy(dependencies) {
    const { window: win, localStorage: storage, GM_setValue: gmSetValue, LOG_MAIN, FLAG } = dependencies;
    try {
      if (typeof gmSetValue === "function" && !gmSetValue.__mgtoolsPatched) {
        const originalGMSetValue = gmSetValue;
        win.GM_setValue = function(key, value) {
          if (key === LOG_MAIN) {
            try {
              const arr = Array.isArray(value) ? value : typeof value === "string" ? JSON.parse(value) : [];
              if (arr && arr.length) {
                storage.removeItem(FLAG);
              }
            } catch {
            }
          }
          return originalGMSetValue.apply(this, arguments);
        };
        win.GM_setValue.__mgtoolsPatched = true;
      }
    } catch (error) {
    }
  }
  function installClearButtonHandler(dependencies) {
    const { document: doc, hardClear } = dependencies;
    doc.addEventListener(
      "click",
      (event) => {
        const target = event.target && event.target.closest(
          '#clear-ability-logs,[data-role="clear-ability-logs"],[data-action="clear-ability-logs"],[data-mga-clear-logs],#mga-clear-logs'
        );
        if (target) {
          hardClear();
        }
      },
      true
      // Use capture phase to intercept before other handlers
    );
  }
  function createLogFingerprint(logEntry) {
    const abilityType = logEntry && logEntry.abilityType || "";
    const petName = logEntry && logEntry.petName || "";
    const timestamp = String(logEntry && logEntry.timestamp || 0);
    let hash = 2166136261 >>> 0;
    const str = abilityType + "|" + petName + "|" + timestamp;
    for (let i = 0; i < str.length; i++) {
      hash ^= str.charCodeAt(i);
      hash = Math.imul(hash, 16777619);
    }
    return (hash >>> 0).toString(36);
  }
  function wrapLogsArray(array, clearFlagCallback) {
    let arrayLocal = array;
    if (!Array.isArray(arrayLocal)) {
      arrayLocal = [];
    }
    const seen = /* @__PURE__ */ new Set();
    const dedupePush = (item) => {
      const id = item.id || createLogFingerprint(item);
      if (seen.has(id)) {
        return 0;
      }
      seen.add(id);
      arrayLocal.push({ ...item, id });
      return 1;
    };
    for (const item of arrayLocal) {
      seen.add(item.id || createLogFingerprint(item));
    }
    return new Proxy(arrayLocal, {
      get(target, prop, receiver) {
        if (["push", "unshift", "splice", "concat"].includes(prop)) {
          return function(...args) {
            let added = 0;
            if (prop === "push" || prop === "unshift") {
              for (const item of args) {
                added += dedupePush(item);
              }
              if (added > 0 && clearFlagCallback) {
                clearFlagCallback();
              }
              return target.length;
            }
            if (prop === "splice") {
              if (args.length > 2) {
                const start = args[0] >>> 0;
                const deleteCount = args[1] >>> 0;
                const newItems = args.slice(2);
                const before = target.slice(0, start);
                const after = target.slice(start + deleteCount);
                const rebuilt = wrapLogsArray(before, clearFlagCallback);
                for (const item of newItems) {
                  dedupePush.call({ arr: rebuilt }, item);
                }
                for (const item of after) {
                  dedupePush.call({ arr: rebuilt }, item);
                }
                while (target.length) target.pop();
                for (const item of rebuilt) target.push(item);
                if (clearFlagCallback) {
                  clearFlagCallback();
                }
                return [];
              }
            }
            return Array.prototype[prop].apply(target, args);
          };
        }
        return Reflect.get(target, prop, receiver);
      },
      set(target, key, value) {
        if (!isNaN(key)) {
          const added = dedupePush(value);
          if (added > 0 && clearFlagCallback) {
            clearFlagCallback();
          }
          return true;
        }
        return Reflect.set(target, key, value);
      }
    });
  }
  function createPublicAPI(dependencies) {
    const {
      UnifiedState: UnifiedState3,
      productionLog: productionLog3,
      initializeScript: initializeScript2,
      targetWindow: targetWindow3,
      targetDocument: targetDocument2,
      updateTabContent,
      updateTimerDisplay: updateTimerDisplay2,
      updateValues: updateValues2,
      updateTimers: updateTimers2,
      openTabInPopout: openTabInPopout2,
      openTabInSeparateWindow: openTabInSeparateWindow2,
      createInGameOverlay: createInGameOverlay2,
      closeInGameOverlay: closeInGameOverlay2,
      refreshOverlayContent: refreshOverlayContent2,
      applyTheme,
      safeSendMessage: safeSendMessage2,
      MGA_saveJSON: MGA_saveJSON2,
      MGA_manageLogMemory: MGA_manageLogMemory2,
      MGA_debouncedSave,
      updateAbilityLogDisplay: updateAbilityLogDisplay3,
      updatePureOverlayContent: updatePureOverlayContent2,
      addResizeHandleToOverlay: addResizeHandleToOverlay2,
      getAbilitiesTabContent: getAbilitiesTabContent2,
      updatePetPresetDropdown: updatePetPresetDropdown2,
      refreshSeparateWindowPopouts: refreshSeparateWindowPopouts2,
      exportAbilityLogs: exportAbilityLogs2,
      getActivePetsFromRoomState: getActivePetsFromRoomState2,
      updateActivePetsFromRoomState: updateActivePetsFromRoomState2
    } = dependencies;
    return {
      // Direct state access
      state: UnifiedState3,
      // ==================== MANUAL CONTROLS ====================
      /**
       * Shows the main MGA panel.
       * @returns {void}
       * @example
       * MGA.showPanel(); // Panel becomes visible
       */
      showPanel: () => {
        if (UnifiedState3.panels.main) {
          UnifiedState3.panels.main.style.display = "block";
        }
      },
      /**
       * Hides the main MGA panel.
       * @returns {void}
       * @example
       * MGA.hidePanel(); // Panel becomes hidden
       */
      hidePanel: () => {
        if (UnifiedState3.panels.main) {
          UnifiedState3.panels.main.style.display = "none";
        }
      },
      /**
       * Manually initializes the script.
       * Use if script doesn't auto-initialize.
       * @returns {void}
       * @example
       * MGA.init(); // Manually start initialization
       */
      init: () => {
        productionLog3("\u{1F504} Manual initialization requested...");
        UnifiedState3.initialized = false;
        initializeScript2();
      },
      /**
       * Force reinitialization by clearing all flags and reloading.
       * Recovery function for stuck initialization.
       * @returns {void}
       * @example
       * MGA.forceReinit(); // Clear flags and reload page
       */
      forceReinit: () => {
        productionLog3("\u{1F504} Force reinitialization requested...");
        try {
          delete targetWindow3._MGA_INITIALIZING;
        } catch (e) {
          targetWindow3._MGA_INITIALIZING = void 0;
        }
        try {
          delete targetWindow3._MGA_INITIALIZED;
        } catch (e) {
          targetWindow3._MGA_INITIALIZED = void 0;
        }
        try {
          delete targetWindow3._MGA_TIMESTAMP;
        } catch (e) {
          targetWindow3._MGA_TIMESTAMP = void 0;
        }
        targetWindow3._MGA_FORCE_INIT = true;
        location.reload();
      },
      /**
       * Checks data persistence status.
       * Logs current state of petPresets, seeds, and raw storage values.
       * @returns {void}
       * @example
       * MGA.checkPersistence();
       * // Logs:
       * // Pet Presets in State: 3
       * // Pet Presets in Storage: EXISTS
       * // Seeds in State: 5
       * // ...
       */
      checkPersistence: () => {
        productionLog3("\u{1F4CA} Data Persistence Check:");
        productionLog3("  Pet Presets in State:", Object.keys(UnifiedState3.data.petPresets).length);
        productionLog3("  Pet Presets in Storage:", localStorage.getItem("MGA_petPresets") ? "EXISTS" : "MISSING");
        productionLog3("  Seeds in State:", UnifiedState3.data.seedsToDelete.length);
        productionLog3("  Seeds in Storage:", localStorage.getItem("MGA_seedsToDelete") ? "EXISTS" : "MISSING");
        if (localStorage.getItem("MGA_petPresets")) {
          productionLog3("  Raw Presets:", localStorage.getItem("MGA_petPresets"));
        }
        if (localStorage.getItem("MGA_seedsToDelete")) {
          productionLog3("  Raw Seeds:", localStorage.getItem("MGA_seedsToDelete"));
        }
      },
      // ==================== POP-OUT FUNCTIONALITY ====================
      /**
       * Pop-out window controls.
       * @namespace
       */
      popout: {
        /**
         * Opens a tab in a new browser tab (popout mode).
         * @param {string} tabName - Tab name to open
         * @returns {void}
         * @example
         * MGA.popout.openTab('abilities'); // Opens abilities in new tab
         */
        openTab: (tabName) => openTabInPopout2(tabName),
        /**
         * Opens a tab in a separate browser window.
         * @param {string} tabName - Tab name to open
         * @returns {void}
         * @example
         * MGA.popout.openSeparateWindow('pets'); // Opens pets in new window
         */
        openSeparateWindow: (tabName) => openTabInSeparateWindow2(tabName),
        /**
         * Creates an in-game overlay for a tab.
         * @param {string} tabName - Tab name to overlay
         * @returns {void}
         * @example
         * MGA.popout.createOverlay('timers'); // Creates overlay for timers
         */
        createOverlay: (tabName) => createInGameOverlay2(tabName),
        /**
         * Closes an in-game overlay.
         * @param {string} tabName - Tab name to close
         * @returns {void}
         * @example
         * MGA.popout.closeOverlay('timers'); // Closes timers overlay
         */
        closeOverlay: (tabName) => closeInGameOverlay2(tabName),
        /**
         * Refreshes overlay content.
         * @param {string} tabName - Tab name to refresh
         * @returns {void}
         * @example
         * MGA.popout.refreshOverlay('abilities'); // Refreshes abilities overlay
         */
        refreshOverlay: (tabName) => refreshOverlayContent2(tabName)
      },
      // ==================== DEBUG FUNCTIONS ====================
      /**
       * Debug utilities for development and testing.
       * @namespace
       */
      debug: {
        /**
         * Logs the entire UnifiedState object.
         * @returns {void}
         * @example
         * MGA.debug.logState(); // Logs UnifiedState to console
         */
        logState: () => productionLog3("MGA State:", UnifiedState3),
        /**
         * Logs all atom values.
         * @returns {void}
         * @example
         * MGA.debug.logAtoms(); // Logs atoms to console
         */
        logAtoms: () => productionLog3("Atoms:", UnifiedState3.atoms),
        /**
         * Logs all data values.
         * @returns {void}
         * @example
         * MGA.debug.logData(); // Logs data to console
         */
        logData: () => productionLog3("Data:", UnifiedState3.data),
        /**
         * Tests the universal theming system.
         * Temporarily applies rainbow theme for 5 seconds.
         * @returns {void}
         * @example
         * MGA.debug.testTheming();
         * // Applies rainbow theme for 5s, then restores original
         */
        testTheming: () => {
          productionLog3("\u{1F3A8} Testing universal theming system...");
          productionLog3("Current theme:", UnifiedState3.currentTheme);
          productionLog3("Active overlays:", UnifiedState3.data.popouts.overlays.size);
          productionLog3("Theme sync working:", !!UnifiedState3.currentTheme);
          const originalStyle = UnifiedState3.data.settings.gradientStyle;
          UnifiedState3.data.settings.gradientStyle = "rainbow-burst";
          UnifiedState3.data.settings.opacity = 75;
          applyTheme();
          productionLog3("\u2705 Test theme applied! Check all windows for rainbow theme.");
          productionLog3("\u{1F4A1} Open a pop-out or overlay to see the theme in action!");
          setTimeout(() => {
            UnifiedState3.data.settings.gradientStyle = originalStyle;
            UnifiedState3.data.settings.opacity = 95;
            applyTheme();
            productionLog3("\u{1F504} Original theme restored.");
          }, 5e3);
        },
        /**
         * Checks if game connection is available.
         * @returns {boolean} True if connection available
         * @example
         * if (MGA.debug.checkConnection()) {
         *   console.log('Connected to game');
         * }
         */
        checkConnection: () => {
          const hasConnection = targetWindow3.MagicCircle_RoomConnection && typeof targetWindow3.MagicCircle_RoomConnection.sendMessage === "function";
          productionLog3("\u{1F50C} Connection Status:", hasConnection ? "\u2705 Available" : "\u274C Not Available");
          productionLog3("\u{1F4E1} RoomConnection Object:", targetWindow3.MagicCircle_RoomConnection);
          return hasConnection;
        },
        /**
         * Tests the safeSendMessage function.
         * @returns {boolean} True if send succeeded
         * @example
         * if (MGA.debug.testSendMessage()) {
         *   console.log('Send message works');
         * }
         */
        testSendMessage: () => {
          productionLog3("\u{1F9EA} Testing safeSendMessage...");
          const result = safeSendMessage2({
            scopePath: ["Room"],
            type: "Ping"
          });
          productionLog3("Result:", result ? "\u2705 Success" : "\u274C Failed");
          return result;
        },
        /**
         * Debugs storage state.
         * @returns {void}
         * @example
         * MGA.debug.debugStorage(); // Logs all storage keys/values
         */
        debugStorage: () => targetWindow3.MGA_debugStorage(),
        /**
         * Adds a test ability log entry.
         * @returns {void}
         * @example
         * MGA.debug.testAbilityLog();
         * // Adds test log and updates UI
         */
        testAbilityLog: () => {
          UnifiedState3.data.petAbilityLogs.unshift({
            petName: "Test Pet",
            abilityType: "Test Ability",
            timestamp: Date.now(),
            timeString: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
            data: { test: true }
          });
          UnifiedState3.data.petAbilityLogs = MGA_manageLogMemory2(UnifiedState3.data.petAbilityLogs);
          MGA_debouncedSave("MGA_petAbilityLogs", UnifiedState3.data.petAbilityLogs);
          if (UnifiedState3.activeTab === "abilities") {
            updateTabContent();
          }
          UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
            if (overlay && document.contains(overlay) && tabName === "abilities") {
              if (overlay.className.includes("mga-overlay-content-only")) {
                updatePureOverlayContent2(overlay, tabName);
                debugLog("OVERLAY_LIFECYCLE", "Updated pure abilities overlay after test ability");
              } else {
                const overlayContent = overlay.querySelector(".mga-overlay-content > div");
                if (overlayContent) {
                  overlayContent.innerHTML = getAbilitiesTabContent2();
                  setTimeout(() => updateAbilityLogDisplay3(overlay), 10);
                  setTimeout(() => {
                    if (!overlay.querySelector(".mga-resize-handle")) {
                      addResizeHandleToOverlay2(overlay);
                      productionLog3("\u{1F527} [RESIZE] Re-added missing resize handle to ability logs overlay");
                    }
                  }, 50);
                }
              }
            }
          });
        },
        /**
         * Sets test timer values.
         * @returns {void}
         * @example
         * MGA.debug.testTimer();
         * // Sets seed=120, egg=240, tool=180, lunar=3600
         */
        testTimer: () => {
          UnifiedState3.data.timers = {
            seed: 120,
            egg: 240,
            tool: 180,
            lunar: 3600
          };
          if (UnifiedState3.activeTab === "timers") {
            updateTimerDisplay2();
          }
        },
        /**
         * Sets test value amounts.
         * @returns {void}
         * @example
         * MGA.debug.testValues();
         * // Sets test values for inventory/tile/garden
         */
        testValues: () => {
          UnifiedState3.data.inventoryValue = 123456;
          UnifiedState3.data.tileValue = 78900;
          UnifiedState3.data.gardenValue = 456789;
          if (UnifiedState3.activeTab === "values") {
            updateTabContent();
          }
        }
      },
      // ==================== MANUAL REFRESH FUNCTIONS ====================
      /**
       * Manual refresh controls for each tab.
       * @namespace
       */
      refresh: {
        /**
         * Refreshes pets tab (targeted update to prevent UI interruption).
         * @returns {void}
         * @example
         * MGA.refresh.pets(); // Updates pet preset dropdown
         */
        pets: () => {
          if (UnifiedState3.activeTab === "pets") {
            const context = targetDocument2.getElementById("mga-tab-content");
            if (context) {
              updatePetPresetDropdown2(context);
              refreshSeparateWindowPopouts2("pets");
              UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
                if (overlay && document.contains(overlay) && tabName === "pets") {
                  if (overlay.className.includes("mga-overlay-content-only")) {
                    updatePureOverlayContent2(overlay, tabName);
                  }
                }
              });
            }
          }
        },
        /**
         * Refreshes abilities tab.
         * @returns {void}
         * @example
         * MGA.refresh.abilities(); // Reloads ability log display
         */
        abilities: () => {
          if (UnifiedState3.activeTab === "abilities") updateTabContent();
        },
        /**
         * Refreshes seeds tab.
         * @returns {void}
         * @example
         * MGA.refresh.seeds(); // Reloads seed deletion list
         */
        seeds: () => {
          if (UnifiedState3.activeTab === "seeds") updateTabContent();
        },
        /**
         * Refreshes values tab.
         * @returns {void}
         * @example
         * MGA.refresh.values(); // Recalculates all values
         */
        values: () => {
          updateValues2();
          if (UnifiedState3.activeTab === "values") updateTabContent();
        },
        /**
         * Refreshes timers tab.
         * @returns {void}
         * @example
         * MGA.refresh.timers(); // Updates all timer displays
         */
        timers: () => {
          updateTimers2();
          if (UnifiedState3.activeTab === "timers") updateTimerDisplay2();
        },
        /**
         * Refreshes all tabs.
         * @returns {void}
         * @example
         * MGA.refresh.all(); // Full refresh of all data
         */
        all: () => {
          updateTabContent();
          updateValues2();
          updateTimers2();
        }
      },
      // ==================== EXPORT FUNCTIONS ====================
      /**
       * Data export controls.
       * @namespace
       */
      export: {
        /**
         * Exports pet presets to JSON file.
         * @returns {void}
         * @example
         * MGA.export.petPresets();
         * // Downloads: MGA_PetPresets.json
         */
        petPresets: () => {
          const data = JSON.stringify(UnifiedState3.data.petPresets, null, 2);
          const blob = new Blob([data], { type: "application/json" });
          const link = targetDocument2.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = "MGA_PetPresets.json";
          link.click();
        },
        /**
         * Exports ability logs to JSON file.
         * @returns {void}
         * @example
         * MGA.export.abilityLogs();
         * // Downloads: MGA_AbilityLogs_YYYY-MM-DD.json
         */
        abilityLogs: () => exportAbilityLogs2(),
        /**
         * Exports all data (presets, logs, settings) to JSON file.
         * @returns {void}
         * @example
         * MGA.export.allData();
         * // Downloads: MGA_AllData_YYYY-MM-DD.json
         */
        allData: () => {
          const data = JSON.stringify(
            {
              petPresets: UnifiedState3.data.petPresets,
              petAbilityLogs: UnifiedState3.data.petAbilityLogs,
              settings: {
                seedsToDelete: UnifiedState3.data.seedsToDelete,
                autoDeleteEnabled: UnifiedState3.data.autoDeleteEnabled
              }
            },
            null,
            2
          );
          const blob = new Blob([data], { type: "application/json" });
          const link = targetDocument2.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = `MGA_AllData_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
          link.click();
        }
      },
      // ==================== IMPORT FUNCTIONS ====================
      /**
       * Data import controls.
       * @namespace
       */
      import: {
        /**
         * Imports pet presets from JSON string.
         * @param {string} jsonString - JSON string to import
         * @returns {void}
         * @example
         * MGA.import.petPresets('{"preset1": {...}}');
         * // Imports and saves presets
         */
        petPresets: (jsonString) => {
          try {
            const data = JSON.parse(jsonString);
            UnifiedState3.data.petPresets = data;
            MGA_saveJSON2("MGA_petPresets", data);
            if (UnifiedState3.activeTab === "pets") {
              const context = targetDocument2.getElementById("mga-tab-content");
              if (context) {
                updatePetPresetDropdown2(context);
                refreshSeparateWindowPopouts2("pets");
              }
            }
            productionLog3("\u2705 Pet presets imported successfully");
          } catch (e) {
            console.error("\u274C Failed to import pet presets:", e);
          }
        },
        /**
         * Imports all data from JSON string.
         * @param {string} jsonString - JSON string to import
         * @returns {void}
         * @example
         * MGA.import.allData('{"petPresets": {...}, "petAbilityLogs": [...]}');
         * // Imports all data and updates UI
         */
        allData: (jsonString) => {
          try {
            const data = JSON.parse(jsonString);
            if (data.petPresets) {
              UnifiedState3.data.petPresets = data.petPresets;
              MGA_saveJSON2("MGA_petPresets", data.petPresets);
            }
            if (data.petAbilityLogs) {
              UnifiedState3.data.petAbilityLogs = data.petAbilityLogs;
              MGA_saveJSON2("MGA_petAbilityLogs", data.petAbilityLogs);
            }
            if (data.settings) {
              if (data.settings.seedsToDelete) {
                UnifiedState3.data.seedsToDelete = data.settings.seedsToDelete;
              }
              if (typeof data.settings.autoDeleteEnabled === "boolean") {
                UnifiedState3.data.autoDeleteEnabled = data.settings.autoDeleteEnabled;
              }
            }
            updateTabContent();
            productionLog3("\u2705 All data imported successfully");
          } catch (e) {
            console.error("\u274C Failed to import data:", e);
          }
        }
      },
      // ==================== CLEAR FUNCTIONS ====================
      /**
       * Data clearing controls.
       * @namespace
       */
      clear: {
        /**
         * Clears all pet presets (with confirmation).
         * @returns {void}
         * @example
         * MGA.clear.petPresets();
         * // Prompts user, then clears if confirmed
         */
        petPresets: () => {
          if (confirm("Clear all pet presets?")) {
            UnifiedState3.data.petPresets = {};
            MGA_saveJSON2("MGA_petPresets", {});
            if (UnifiedState3.activeTab === "pets") {
              const context = targetDocument2.getElementById("mga-tab-content");
              if (context) {
                updatePetPresetDropdown2(context);
                refreshSeparateWindowPopouts2("pets");
              }
            }
          }
        },
        /**
         * Clears all ability logs (with confirmation).
         * @returns {void}
         * @example
         * MGA.clear.abilityLogs();
         * // Prompts user, then clears if confirmed
         */
        abilityLogs: () => {
          if (confirm("Clear all ability logs?")) {
            UnifiedState3.data.petAbilityLogs = [];
            MGA_saveJSON2("MGA_petAbilityLogs", []);
            if (UnifiedState3.activeTab === "abilities") {
              updateTabContent();
            }
            UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === "abilities") {
                if (overlay.className.includes("mga-overlay-content-only")) {
                  updatePureOverlayContent2(overlay, tabName);
                  debugLog("OVERLAY_LIFECYCLE", "Updated pure abilities overlay after clearing logs");
                } else {
                  const overlayContent = overlay.querySelector(".mga-overlay-content > div");
                  if (overlayContent) {
                    overlayContent.innerHTML = getAbilitiesTabContent2();
                    setTimeout(() => updateAbilityLogDisplay3(overlay), 10);
                    setTimeout(() => {
                      if (!overlay.querySelector(".mga-resize-handle")) {
                        addResizeHandleToOverlay2(overlay);
                        productionLog3("\u{1F527} [RESIZE] Re-added missing resize handle to ability logs overlay");
                      }
                    }, 50);
                  }
                }
              }
            });
          }
        },
        /**
         * Clears ALL saved data (with confirmation).
         * @returns {void}
         * @example
         * MGA.clear.allData();
         * // Prompts user, then clears everything if confirmed
         */
        allData: () => {
          if (confirm("Clear ALL saved data? This cannot be undone!")) {
            UnifiedState3.data.petPresets = {};
            UnifiedState3.data.petAbilityLogs = [];
            UnifiedState3.data.seedsToDelete = [];
            UnifiedState3.data.autoDeleteEnabled = false;
            MGA_saveJSON2("MGA_petPresets", {});
            MGA_saveJSON2("MGA_petAbilityLogs", []);
            updateTabContent();
          }
        }
      },
      // ==================== DEBUG CONTROLS ====================
      /**
       * Debug controls for development and testing.
       * @namespace
       */
      debugControls: {
        /**
         * Forces re-initialization by setting force flag and reloading.
         * @returns {void}
         * @example
         * MGA.debugControls.forceInit();
         * // Sets _MGA_FORCE_INIT=true and reloads
         */
        forceInit: () => {
          productionLog3("\u{1F504} [DEBUG] Force re-initialization requested");
          targetWindow3._MGA_FORCE_INIT = true;
          location.reload();
        },
        /**
         * Resets initialization flags without reloading.
         * @returns {void}
         * @example
         * MGA.debugControls.resetFlags();
         * // Clears all init flags
         */
        resetFlags: () => {
          productionLog3("\u{1F504} [DEBUG] Resetting initialization flags");
          targetWindow3._MGA_INITIALIZED = false;
          try {
            delete targetWindow3._MGA_INITIALIZING;
          } catch (e) {
            targetWindow3._MGA_INITIALIZING = false;
          }
          targetWindow3._MGA_FORCE_INIT = false;
          productionLog3("\u2705 [DEBUG] Flags reset - you can now re-run the script");
        },
        /**
         * Checks current pet state from multiple sources.
         * @returns {Object} Pet state from UnifiedState, window, and Room
         * @example
         * const pets = MGA.debugControls.checkPets();
         * console.log('Active pets:', pets.unifiedState);
         */
        checkPets: () => {
          productionLog3("\u{1F43E} [DEBUG] Current pet state:");
          productionLog3("\u2022 UnifiedState.atoms.activePets:", UnifiedState3.atoms.activePets);
          productionLog3("\u2022 window.activePets:", targetWindow3.activePets);
          productionLog3("\u2022 Room state pets:", getActivePetsFromRoomState2());
          return {
            unifiedState: UnifiedState3.atoms.activePets,
            windowPets: targetWindow3.activePets,
            roomState: getActivePetsFromRoomState2()
          };
        },
        /**
         * Manually refreshes pets from room state.
         * @returns {Array} Updated pet list
         * @example
         * const pets = MGA.debugControls.refreshPets();
         * console.log('Refreshed pets:', pets);
         */
        refreshPets: () => {
          productionLog3("\u{1F504} [DEBUG] Manually refreshing pets from room state");
          const pets = updateActivePetsFromRoomState2();
          productionLog3("\u2705 [DEBUG] Pets refreshed:", pets);
          return pets;
        },
        /**
         * Lists all active managed intervals.
         * @returns {Object} Interval status object
         * @example
         * const intervals = MGA.debugControls.listIntervals();
         * console.log('Active intervals:', intervals);
         */
        listIntervals: () => {
          productionLog3("\u23F0 [DEBUG] Active managed intervals:");
          Object.entries(UnifiedState3.intervals).forEach(([name, interval]) => {
            productionLog3(`\u2022 ${name}: ${interval ? "Running" : "Stopped"}`);
          });
          return UnifiedState3.intervals;
        }
      }
    };
  }
  function createLoadingStates(dependencies) {
    const { Array: ArrayConstructor } = dependencies;
    return {
      /**
       * Shows loading spinner in element.
       * @param {HTMLElement} element - Element to show loading in
       * @param {string} [text='Loading...'] - Loading text
       * @returns {void}
       */
      show: (element, text = "Loading...") => {
        if (!element) return;
        const loadingHtml = `
        <div class="mga-loading">
          <div class="mga-loading-spinner"></div>
          <span>${text}</span>
        </div>
      `;
        element.innerHTML = loadingHtml;
      },
      /**
       * Shows skeleton loading animation.
       * @param {HTMLElement} element - Element to show skeleton in
       * @param {number} [lines=3] - Number of skeleton lines
       * @returns {void}
       */
      showSkeleton: (element, lines = 3) => {
        if (!element) return;
        const skeletonLines = ArrayConstructor(lines).fill(0).map(
          () => `<div class="mga-skeleton" style="height: 20px; margin-bottom: 8px; width: ${Math.floor(Math.random() * 40 + 60)}%;"></div>`
        ).join("");
        element.innerHTML = `<div style="padding: 20px;">${skeletonLines}</div>`;
      },
      /**
       * Hides loading and shows content.
       * @param {HTMLElement} element - Element to update
       * @param {string} content - Content HTML to show
       * @param {boolean} [fadeIn=true] - Whether to fade in
       * @returns {void}
       */
      hide: (element, content, fadeIn = true) => {
        if (!element) return;
        element.innerHTML = content;
        if (fadeIn) {
          element.classList.add("mga-fade-in");
          setTimeout(() => element.classList.remove("mga-fade-in"), 300);
        }
      },
      /**
       * Adds loading spinner to button.
       * @param {HTMLElement} button - Button element
       * @param {string} originalText - Original button text (unused, for API compatibility)
       * @returns {void}
       */
      addToButton: (button, originalText) => {
        if (!button) return;
        button.disabled = true;
        button.innerHTML = `<div class="mga-loading-spinner" style="margin-right: 4px; width: 16px; height: 16px;"></div>Loading...`;
      },
      /**
       * Removes loading spinner from button.
       * @param {HTMLElement} button - Button element
       * @param {string} originalText - Original button text to restore
       * @returns {void}
       */
      removeFromButton: (button, originalText) => {
        if (!button) return;
        button.disabled = false;
        button.innerHTML = originalText;
      }
    };
  }
  function createErrorRecovery(dependencies) {
    const { targetDocument: targetDocument2, debugError: debugError2, debugLog: debugLog3 } = dependencies;
    return {
      /**
       * Wraps a function with error handling.
       * @param {Function} fn - Function to wrap
       * @param {Function|null} fallback - Fallback function on error
       * @param {string} [context='Unknown'] - Context name for logging
       * @returns {Function} Wrapped function
       */
      wrapFunction: (fn, fallback = null, context = "Unknown") => {
        return function(...args) {
          try {
            return fn.apply(this, args);
          } catch (error) {
            debugError2("ERROR_RECOVERY", `Error in ${context}`, error);
            const errorToast = targetDocument2.createElement("div");
            errorToast.style.cssText = `
            position: fixed; top: 20px; right: 20px; z-index: 20000;
            background: rgba(220, 38, 38, 0.95); color: white;
            padding: 12px 20px; border-radius: 8px;
            font-family: Arial, sans-serif; font-size: 13px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: mga-fade-in 0.3s ease-out;
          `;
            errorToast.innerHTML = `\u26A0\uFE0F Something went wrong in ${context}. Please try again.`;
            targetDocument2.body.appendChild(errorToast);
            setTimeout(() => {
              errorToast.style.animation = "mga-fade-out 0.3s ease-in forwards";
              setTimeout(() => targetDocument2.body.removeChild(errorToast), 300);
            }, 4e3);
            return fallback ? fallback.apply(this, args) : null;
          }
        };
      },
      /**
       * Wraps async function with error handling.
       * @param {Function} asyncFn - Async function to wrap
       * @param {*} fallback - Fallback value on error
       * @param {string} [context='Async Operation'] - Context name for logging
       * @returns {Promise<*>} Promise resolving to result or fallback
       */
      safeAsync: async (asyncFn, fallback = null, context = "Async Operation") => {
        try {
          return await asyncFn();
        } catch (error) {
          debugError2("ERROR_RECOVERY", `Async error in ${context}`, error);
          return fallback;
        }
      },
      /**
       * Retries operation with exponential backoff.
       * @param {Function} operation - Async operation to retry
       * @param {number} [maxRetries=3] - Maximum retry attempts
       * @param {number} [delay=1000] - Base delay in ms
       * @param {string} [context='Operation'] - Context name for logging
       * @returns {Promise<*>} Promise resolving to operation result
       * @throws {Error} If all retries fail
       */
      retryOperation: async (operation, maxRetries = 3, delay = 1e3, context = "Operation") => {
        for (let i = 0; i < maxRetries; i++) {
          try {
            return await operation();
          } catch (error) {
            if (i === maxRetries - 1) {
              debugError2("ERROR_RECOVERY", `Final retry failed for ${context}`, error);
              throw error;
            }
            debugLog3("ERROR_RECOVERY", `Retry ${i + 1}/${maxRetries} for ${context}`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      }
    };
  }
  function createPerformanceUtils(dependencies) {
    const { document: doc, requestAnimationFrame: requestAnimationFrame2, setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = dependencies;
    return {
      /**
       * Debounces a function.
       * @param {Function} func - Function to debounce
       * @param {number} wait - Wait time in ms
       * @returns {Function} Debounced function
       */
      debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout2(timeout);
            func(...args);
          };
          clearTimeout2(timeout);
          timeout = setTimeout2(later, wait);
        };
      },
      /**
       * Throttles a function.
       * @param {Function} func - Function to throttle
       * @param {number} limit - Throttle limit in ms
       * @returns {Function} Throttled function
       */
      throttle: (func, limit) => {
        let inThrottle;
        return function() {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout2(() => inThrottle = false, limit);
          }
        };
      },
      /**
       * Batches DOM updates using requestAnimationFrame.
       * @param {Array<Function>} updates - Array of update functions
       * @returns {void}
       */
      batchDOMUpdates: (updates) => {
        requestAnimationFrame2(() => {
          const fragment = doc.createDocumentFragment();
          updates.forEach((update) => {
            if (typeof update === "function") {
              update(fragment);
            }
          });
        });
      },
      /**
       * Optimizes element for scrolling performance.
       * @param {HTMLElement} element - Element to optimize
       * @returns {void}
       */
      optimizeScrolling: (element) => {
        if (!element) return;
        element.style.willChange = "scroll-position";
        element.style.transform = "translateZ(0)";
      }
    };
  }
  function createTooltips(dependencies) {
    const { targetDocument: targetDocument2, document: doc, window: win, isMGAEvent } = dependencies;
    let tooltip = null;
    let showTimeout = null;
    const hideTimeout = null;
    let currentEvent = null;
    const position = (e) => {
      const rect = tooltip.getBoundingClientRect();
      const padding = 10;
      let x = e.clientX + padding;
      let y = e.clientY - rect.height - padding;
      if (x + rect.width > win.innerWidth) {
        x = e.clientX - rect.width - padding;
      }
      if (y < 0) {
        y = e.clientY + padding;
      }
      tooltip.style.left = x + "px";
      tooltip.style.top = y + "px";
    };
    const show = (element, text) => {
      tooltip.textContent = text;
      if (currentEvent) {
        position(currentEvent);
      }
      tooltip.classList.add("show");
    };
    const hide = () => {
      tooltip.classList.remove("show");
      tooltip.style.left = "-9999px";
      tooltip.style.top = "-9999px";
      currentEvent = null;
    };
    const handleMouseEnter = (e) => {
      const element = e.target?.closest?.("[data-tooltip]");
      if (!element) return;
      if (e.target && typeof e.target.matches === "function" && (e.target.matches("button, input, select, .mga-btn") || e.target.closest("button, .mga-btn"))) {
        return;
      }
      const text = element.dataset.tooltip;
      const delay = element.dataset.tooltipDelay || 500;
      currentEvent = e;
      showTimeout = setTimeout(() => {
        show(element, text);
      }, parseInt(delay));
    };
    const handleMouseLeave = (e) => {
      const element = e.target?.closest?.("[data-tooltip]");
      if (!element) return;
      clearTimeout(showTimeout);
      hide();
    };
    const handleMouseMove = (e) => {
      if (!isMGAEvent(e)) {
        return;
      }
      if (e.target && typeof e.target.matches === "function" && (e.target.matches("button, input, select, .mga-btn") || e.target.closest("button, .mga-btn"))) {
        return;
      }
      currentEvent = e;
      if (tooltip && tooltip.classList.contains("show")) {
        const tooltipElement = e.target?.closest?.("[data-tooltip]");
        if (!tooltipElement) {
          hide();
          return;
        }
        position(e);
      }
    };
    return {
      /**
       * Initializes tooltip system.
       * @returns {void}
       */
      init: () => {
        if (!tooltip) {
          tooltip = targetDocument2.createElement("div");
          tooltip.className = "mga-tooltip";
          targetDocument2.body.appendChild(tooltip);
        }
        doc.addEventListener("mouseenter", handleMouseEnter, true);
        doc.addEventListener("mouseleave", handleMouseLeave, true);
        doc.addEventListener("mousemove", handleMouseMove, true);
      },
      /**
       * Adds tooltip to element.
       * @param {HTMLElement} element - Element to add tooltip to
       * @param {string} text - Tooltip text
       * @param {Object} [options={}] - Tooltip options
       * @param {number} [options.delay] - Delay before showing (ms)
       * @returns {void}
       */
      addToElement: (element, text, options = {}) => {
        if (!element) return;
        element.setAttribute("data-tooltip", text);
        if (options.delay) element.setAttribute("data-tooltip-delay", options.delay);
      },
      /**
       * Removes tooltip from element.
       * @param {HTMLElement} element - Element to remove tooltip from
       * @returns {void}
       */
      removeFromElement: (element) => {
        if (!element) return;
        element.removeAttribute("data-tooltip");
        element.removeAttribute("data-tooltip-delay");
      }
    };
  }
  function installPublicAPI(dependencies) {
    const { window: win, document: doc, localStorage: storage } = dependencies;
    const persistence = createAbilityLogPersistence({
      localStorage: storage,
      console,
      GM_getValue: typeof GM_getValue !== "undefined" ? GM_getValue : null,
      GM_setValue: typeof GM_setValue !== "undefined" ? GM_setValue : null
    });
    installLocalStorageProxy({
      Storage,
      localStorage: storage,
      LOG_MAIN: persistence.LOG_MAIN,
      LOG_ARCH: persistence.LOG_ARCH,
      FLAG: persistence.FLAG
    });
    if (typeof GM_getValue !== "undefined") {
      installGMGetValueProxy({
        window: win,
        localStorage: storage,
        GM_getValue,
        LOG_MAIN: persistence.LOG_MAIN,
        LOG_ARCH: persistence.LOG_ARCH,
        FLAG: persistence.FLAG
      });
    }
    if (typeof GM_setValue !== "undefined") {
      installGMSetValueProxy({
        window: win,
        localStorage: storage,
        GM_setValue,
        LOG_MAIN: persistence.LOG_MAIN,
        FLAG: persistence.FLAG
      });
    }
    installClearButtonHandler({
      document: doc,
      hardClear: persistence.hardClear
    });
    win.MGTOOLS_hardClearAbilityLogs = persistence.hardClear;
    win.MGA = createPublicAPI(dependencies);
    win.MGA_LoadingStates = createLoadingStates({
      Array
    });
    win.MGA_ErrorRecovery = createErrorRecovery({
      targetDocument: dependencies.targetDocument,
      debugError: dependencies.debugError,
      debugLog: dependencies.debugLog
    });
    win.MGA_Performance = createPerformanceUtils({
      document: doc,
      requestAnimationFrame: win.requestAnimationFrame.bind(win),
      setTimeout: win.setTimeout.bind(win),
      clearTimeout: win.clearTimeout.bind(win)
    });
    win.MGA_Tooltips = createTooltips({
      targetDocument: dependencies.targetDocument,
      document: doc,
      window: win,
      isMGAEvent: dependencies.isMGAEvent
    });
  }
  var public_api_default = {
    // Persistence workarounds
    createAbilityLogPersistence,
    installLocalStorageProxy,
    installGMGetValueProxy,
    installGMSetValueProxy,
    installClearButtonHandler,
    wrapLogsArray,
    // Public API
    createPublicAPI,
    // Utility APIs
    createLoadingStates,
    createErrorRecovery,
    createPerformanceUtils,
    createTooltips,
    // Installation
    installPublicAPI
  };

  // src/init/bootstrap.js
  var bootstrap_exports = {};
  __export(bootstrap_exports, {
    bootstrapStart: () => bootstrapStart,
    bootstrapStop: () => bootstrapStop,
    getBootstrapStatus: () => getBootstrapStatus
  });
  var isBootstrapped = false;
  var eventHandlers4 = [];
  var bootstrapConfig = null;
  function bootstrapStart(opts = {}) {
    if (isBootstrapped) {
      Logger.warn("BOOTSTRAP", "Application already bootstrapped");
      return;
    }
    Logger.info("BOOTSTRAP", "Starting MGTools application...");
    bootstrapConfig = { ...opts };
    Logger.debug("BOOTSTRAP", "Ensuring UI styles");
    ensureStyles();
    Logger.debug("BOOTSTRAP", "Wiring top-level UI events");
    wireTopLevelEvents();
    Logger.debug("BOOTSTRAP", "Starting AppCore");
    AppCore.start(opts);
    isBootstrapped = true;
    Logger.info("BOOTSTRAP", "MGTools application started successfully");
    emit("bootstrap:complete", {
      timestamp: Date.now(),
      config: bootstrapConfig
    });
  }
  function bootstrapStop() {
    if (!isBootstrapped) {
      Logger.warn("BOOTSTRAP", "Application not bootstrapped");
      return;
    }
    Logger.info("BOOTSTRAP", "Stopping MGTools application...");
    emit("bootstrap:stopping", {
      timestamp: Date.now()
    });
    Logger.debug("BOOTSTRAP", "Stopping AppCore");
    AppCore.stop();
    Logger.debug("BOOTSTRAP", "Removing top-level event handlers");
    unwireTopLevelEvents();
    bootstrapConfig = null;
    isBootstrapped = false;
    Logger.info("BOOTSTRAP", "MGTools application stopped");
  }
  function getBootstrapStatus() {
    return {
      isBootstrapped,
      config: bootstrapConfig ? { ...bootstrapConfig } : null,
      appCoreStatus: AppCore.getStatus()
    };
  }
  function wireTopLevelEvents() {
    const onToastCreated = (data) => {
      Logger.debug("BOOTSTRAP", `Toast created: ${data.type} - "${data.message}"`);
    };
    const onShortcutTriggered = (data) => {
      Logger.debug("BOOTSTRAP", `Shortcut triggered: ${data.name}`);
    };
    on("toast:created", onToastCreated);
    on("shortcut:*", onShortcutTriggered);
    eventHandlers4.push(
      { event: "toast:created", handler: onToastCreated },
      { event: "shortcut:*", handler: onShortcutTriggered }
    );
    Logger.debug("BOOTSTRAP", `Wired ${eventHandlers4.length} top-level event handlers`);
  }
  function unwireTopLevelEvents() {
    eventHandlers4.forEach(({ event, handler }) => {
      off(event, handler);
    });
    eventHandlers4 = [];
    Logger.debug("BOOTSTRAP", "Unwired all top-level event handlers");
  }
  Logger.info("BOOTSTRAP", "Bootstrap module loaded (no side effects)");

  // src/init/event-handlers.js
  var event_handlers_exports = {};
  __export(event_handlers_exports, {
    EventHandlers: () => EventHandlers,
    setupAutoSave: () => setupAutoSave,
    setupCleanupHandler: () => setupCleanupHandler,
    setupEventHandlers: () => setupEventHandlers
  });
  function setupAutoSave(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      setManagedInterval: setManagedInterval2,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      interval = 3e4
      // 30 seconds default
    } = dependencies;
    if (!setManagedInterval2) {
      console.warn("\u26A0\uFE0F setManagedInterval not provided, auto-save cannot be setup");
      return;
    }
    setManagedInterval2(
      "autoSave",
      () => {
        if (!UnifiedState3 || !MGA_saveJSON2) {
          console.warn("\u26A0\uFE0F UnifiedState or MGA_saveJSON not available for auto-save");
          return;
        }
        MGA_saveJSON2("MGA_petPresets", UnifiedState3.data.petPresets);
        const clearSession = typeof localStorage !== "undefined" && localStorage.getItem("MGA_logs_clear_session") || null;
        if (!clearSession || Date.now() - parseInt(clearSession, 10) > 864e5) {
          MGA_saveJSON2("MGA_petAbilityLogs", UnifiedState3.data.petAbilityLogs);
        }
        MGA_saveJSON2("MGA_seedsToDelete", UnifiedState3.data.seedsToDelete);
        MGA_saveJSON2("MGA_autoDeleteEnabled", UnifiedState3.data.autoDeleteEnabled);
        if (targetWindow3 && targetWindow3.resourceDashboard) {
          targetWindow3.resourceDashboard.updateResourceHistory();
        }
      },
      interval,
      { UnifiedState: UnifiedState3 }
    );
  }
  function setupCleanupHandler(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      clearAllManagedIntervals: clearAllManagedIntervals2,
      closeAllPopoutWindows: closeAllPopoutWindows2,
      debugLog: debugLog3 = console.log,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null
    } = dependencies;
    if (!targetWindow3) {
      console.warn("\u26A0\uFE0F targetWindow not available, cleanup handler cannot be setup");
      return;
    }
    targetWindow3.addEventListener("beforeunload", () => {
      if (UnifiedState3 && MGA_saveJSON2) {
        MGA_saveJSON2("MGA_petPresets", UnifiedState3.data.petPresets);
        const clearSession = typeof localStorage !== "undefined" && localStorage.getItem("MGA_logs_clear_session") || null;
        if (!clearSession || Date.now() - parseInt(clearSession, 10) > 864e5) {
          MGA_saveJSON2("MGA_petAbilityLogs", UnifiedState3.data.petAbilityLogs);
        }
        MGA_saveJSON2("MGA_seedsToDelete", UnifiedState3.data.seedsToDelete);
        MGA_saveJSON2("MGA_autoDeleteEnabled", UnifiedState3.data.autoDeleteEnabled);
      }
      if (clearAllManagedIntervals2) {
        clearAllManagedIntervals2({ UnifiedState: UnifiedState3 });
      }
      if (closeAllPopoutWindows2) {
        closeAllPopoutWindows2({ UnifiedState: UnifiedState3 });
      }
      debugLog3("PERFORMANCE", "Cleanup completed on window unload");
    });
  }
  function setupEventHandlers(dependencies = {}) {
    setupAutoSave(dependencies);
    setupCleanupHandler(dependencies);
  }
  var EventHandlers = {
    setupAutoSave,
    setupCleanupHandler,
    setupEventHandlers
  };

  // src/features/pets.js
  var pets_exports = {};
  __export(pets_exports, {
    HUNGER_BOOST_VALUES: () => HUNGER_BOOST_VALUES,
    KNOWN_ABILITY_TYPES: () => KNOWN_ABILITY_TYPES2,
    MGA_getAllLogs: () => MGA_getAllLogs,
    MGA_manageLogMemory: () => MGA_manageLogMemory,
    SPECIES_HUNGER_DEPLETION_TIME: () => SPECIES_HUNGER_DEPLETION_TIME,
    SPECIES_MAX_HUNGER: () => SPECIES_MAX_HUNGER,
    addPresetToList: () => addPresetToList,
    calculateTimeUntilHungry: () => calculateTimeUntilHungry,
    categorizeAbility: () => categorizeAbility,
    categorizeAbilityToFilterKey: () => categorizeAbilityToFilterKey,
    checkPetHunger: () => checkPetHunger,
    createInstantFeedButton: () => createInstantFeedButton,
    cycleToNextPreset: () => cycleToNextPreset,
    default: () => pets_default,
    ensurePresetOrder: () => ensurePresetOrder,
    estimateUntilLatestCrop: () => estimateUntilLatestCrop,
    exportAbilityLogs: () => exportAbilityLogs,
    exportPetPresets: () => exportPetPresets2,
    favoriteMutation: () => favoriteMutation,
    favoritePetAbility: () => favoritePetAbility,
    favoriteSpecies: () => favoriteSpecies,
    feedPetEnsureSync: () => feedPetEnsureSync,
    flashButton: () => flashButton,
    formatHungerTimer: () => formatHungerTimer,
    formatLogData: () => formatLogData,
    formatRelativeTime: () => formatRelativeTime,
    formatTimestamp: () => formatTimestamp,
    getAbilityExpectations: () => getAbilityExpectations,
    getActivePetsFromRoomState: () => getActivePetsFromRoomState,
    getAllUniqueAbilities: () => getAllUniqueAbilities,
    getAllUniquePets: () => getAllUniquePets,
    getDragAfterElement: () => getDragAfterElement,
    getEggExpectations: () => getEggExpectations,
    getGardenCropIfUnique: () => getGardenCropIfUnique,
    getGrowthExpectations: () => getGrowthExpectations,
    getPetsPopoutContent: () => getPetsPopoutContent2,
    getPetsTabContent: () => getPetsTabContent,
    getTurtleExpectations: () => getTurtleExpectations,
    handleInstantFeed: () => handleInstantFeed,
    importPetPresets: () => importPetPresets2,
    initAbilityCache: () => initAbilityCache,
    initAutoFavorite: () => initAutoFavorite,
    initializeInstantFeedButtons: () => initializeInstantFeedButtons,
    injectInstantFeedButtons: () => injectInstantFeedButtons,
    isKnownAbilityType: () => isKnownAbilityType2,
    loadPetPreset: () => loadPetPreset,
    loadPresetByNumber: () => loadPresetByNumber,
    monitorPetAbilities: () => monitorPetAbilities,
    movePreset: () => movePreset,
    normalizeAbilityName: () => normalizeAbilityName2,
    placePetPreset: () => placePetPreset,
    playAbilityNotificationSound: () => playAbilityNotificationSound,
    playPetNotificationSound: () => playPetNotificationSound,
    populateIndividualAbilities: () => populateIndividualAbilities,
    populatePetSpeciesList: () => populatePetSpeciesList,
    presetHasCropEater: () => presetHasCropEater,
    refreshPresetsList: () => refreshPresetsList,
    scanAndAlertHungryPets: () => scanAndAlertHungryPets,
    selectAllFilters: () => selectAllFilters,
    selectNoneFilters: () => selectNoneFilters,
    sendFeedPet: () => sendFeedPet,
    setupAbilitiesTabHandlers: () => setupAbilitiesTabHandlers,
    setupPetPopoutHandlers: () => setupPetPopoutHandlers2,
    setupPetsTabHandlers: () => setupPetsTabHandlers,
    shouldLogAbility: () => shouldLogAbility,
    unfavoriteMutation: () => unfavoriteMutation,
    unfavoritePetAbility: () => unfavoritePetAbility,
    unfavoriteSpecies: () => unfavoriteSpecies,
    updateAbilityLogDisplay: () => updateAbilityLogDisplay,
    updateActivePetsDisplay: () => updateActivePetsDisplay,
    updateActivePetsFromRoomState: () => updateActivePetsFromRoomState,
    updateAllAbilityLogDisplays: () => updateAllAbilityLogDisplays,
    updateAllLogVisibility: () => updateAllLogVisibility,
    updateLogVisibility: () => updateLogVisibility,
    updatePetPresetDropdown: () => updatePetPresetDropdown
  });
  var SPECIES_MAX_HUNGER = {
    Worm: 500,
    Snail: 1e3,
    Bee: 1500,
    Chicken: 3e3,
    Bunny: 750,
    Dragonfly: 250,
    Pig: 5e4,
    Cow: 25e3,
    Turtle: 1e5,
    Goat: 2e4,
    Squirrel: 15e3,
    Capybara: 15e4,
    Butterfly: 25e3,
    Peacock: 1e5
  };
  var SPECIES_HUNGER_DEPLETION_TIME = {
    Worm: 30 * 60 * 1e3,
    Snail: 60 * 60 * 1e3,
    Bee: 15 * 60 * 1e3,
    Chicken: 60 * 60 * 1e3,
    Bunny: 45 * 60 * 1e3,
    Dragonfly: 15 * 60 * 1e3,
    Pig: 60 * 60 * 1e3,
    Cow: 75 * 60 * 1e3,
    Turtle: 90 * 60 * 1e3,
    Goat: 60 * 60 * 1e3,
    Squirrel: 30 * 60 * 1e3,
    Capybara: 60 * 60 * 1e3,
    Butterfly: 30 * 60 * 1e3,
    Peacock: 60 * 60 * 1e3
  };
  var HUNGER_BOOST_VALUES = {
    "Hunger Boost I": 0.12,
    // 12% reduction per 100 STR
    "Hunger Boost II": 0.16
    // 16% reduction per 100 STR
  };
  var lastPetHungerStates = {};
  var petHungerLastAlertTime = {};
  function exportPetPresets2(UnifiedState3) {
    try {
      const presets = UnifiedState3.data.petPresets || {};
      const presetCount = Object.keys(presets).length;
      if (presetCount === 0) {
        alert("\u26A0\uFE0F No pet presets to export!\n\nCreate some presets first.");
        return;
      }
      const exportData = {
        version: "2.0.0",
        exportDate: (/* @__PURE__ */ new Date()).toISOString(),
        presetCount,
        presets,
        presetsOrder: UnifiedState3.data.petPresetsOrder || []
      };
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement("a");
      link.href = url;
      link.download = `mgtools-presets-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
      link.click();
      URL.revokeObjectURL(url);
      console.log(`\u2705 [EXPORT] Successfully exported ${presetCount} pet presets`);
      alert(`\u2705 Exported ${presetCount} pet presets!

File saved to Downloads folder.`);
    } catch (error) {
      console.error("\u274C [EXPORT] Failed to export presets:", error);
      alert(`\u274C Export failed!

Error: ${error.message}`);
    }
  }
  function importPetPresets2(UnifiedState3, MGA_saveJSON2) {
    try {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".json";
      input.onchange = async (e) => {
        try {
          const file = e.target.files[0];
          if (!file) return;
          const text = await file.text();
          const importData = JSON.parse(text);
          if (!importData.presets || typeof importData.presets !== "object") {
            throw new Error("Invalid preset file format");
          }
          const importCount = Object.keys(importData.presets).length;
          const currentCount = Object.keys(UnifiedState3.data.petPresets || {}).length;
          const confirmed = confirm(
            `\u{1F4E5} Import ${importCount} presets?

Current presets: ${currentCount}
Import date: ${importData.exportDate || "Unknown"}
Version: ${importData.version || "Unknown"}

\u26A0\uFE0F This will OVERWRITE your current presets!`
          );
          if (!confirmed) {
            console.log("\u23F8\uFE0F [IMPORT] User cancelled import");
            return;
          }
          UnifiedState3.data.petPresets = importData.presets;
          UnifiedState3.data.petPresetsOrder = importData.presetsOrder || [];
          MGA_saveJSON2("MGA_petPresets", importData.presets);
          MGA_saveJSON2("MGA_petPresetsOrder", importData.presetsOrder || []);
          console.log(`\u2705 [IMPORT] Successfully imported ${importCount} pet presets`);
          alert(`\u2705 Imported ${importCount} presets!

Page will reload to apply changes.`);
          setTimeout(() => window.location.reload(), 1e3);
        } catch (error) {
          console.error("\u274C [IMPORT] Failed to import presets:", error);
          alert(
            `\u274C Import failed!

Error: ${error.message}

Make sure you're importing a valid MGTools preset file.`
          );
        }
      };
      input.click();
    } catch (error) {
      console.error("\u274C [IMPORT] Failed to create import dialog:", error);
      alert(`\u274C Import failed!

Error: ${error.message}`);
    }
  }
  function checkPetHunger(UnifiedState3, playPetNotificationSound2, showNotificationToast2) {
    if (!UnifiedState3.data.settings.notifications.petHungerEnabled) return;
    try {
      const activePets = window.activePets || UnifiedState3.atoms.activePets || [];
      const thresholdPercent = UnifiedState3.data.settings.notifications.petHungerThreshold || 25;
      activePets.forEach((pet) => {
        if (!pet || !pet.id) return;
        const currentHunger = pet.hunger !== void 0 ? Number(pet.hunger) : null;
        if (currentHunger === null || isNaN(currentHunger)) {
          console.log(`\u26A0\uFE0F [PET-HUNGER] ${pet.petSpecies || "Pet"} has no hunger data - skipping`);
          return;
        }
        const petName = pet.petSpecies || "Pet";
        const estimatedMaxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 1e5;
        const hungerPercent = currentHunger / estimatedMaxHunger * 100;
        const lastHunger = lastPetHungerStates[pet.id] ?? currentHunger;
        const lastPercent = lastHunger / estimatedMaxHunger * 100;
        const ALERT_THROTTLE_MS = 5 * 60 * 1e3;
        const now = Date.now();
        const lastAlertTime = petHungerLastAlertTime[pet.id] || 0;
        const timeSinceLastAlert = now - lastAlertTime;
        if (UnifiedState3.data.settings?.debugMode) {
          console.log(
            `\u{1F43E} [PET-HUNGER-DEBUG] ${petName} (ID: ${pet.id}): ${hungerPercent.toFixed(1)}% (hunger=${currentHunger}/${estimatedMaxHunger}), threshold=${thresholdPercent}%, lastPercent=${lastPercent.toFixed(1)}%, timeSinceLastAlert=${(timeSinceLastAlert / 1e3).toFixed(0)}s`
          );
        }
        const CRITICAL_THROTTLE_MS = 60 * 1e3;
        const isCritical = hungerPercent <= 1;
        const criticalNeedsAlert = isCritical && (timeSinceLastAlert >= CRITICAL_THROTTLE_MS || !lastAlertTime);
        const needsAlert = hungerPercent < thresholdPercent && hungerPercent > 1 && (timeSinceLastAlert >= ALERT_THROTTLE_MS || !lastAlertTime);
        const justCrossed = hungerPercent < thresholdPercent && lastPercent >= thresholdPercent;
        if (needsAlert || justCrossed || criticalNeedsAlert) {
          const reason = isCritical ? "CRITICAL hunger level" : justCrossed ? "crossed threshold" : "below threshold (throttle expired)";
          console.log(
            `\u{1F43E} [PET-HUNGER] ${petName} is getting hungry! (${hungerPercent.toFixed(1)}% < ${thresholdPercent}%) - Reason: ${reason}`
          );
          const volume = UnifiedState3.data.settings.notifications.volume || 0.3;
          playPetNotificationSound2(volume);
          showNotificationToast2(`\u26A0\uFE0F ${petName} needs feeding! Only ${Math.round(hungerPercent)}% full`, "warning");
          petHungerLastAlertTime[pet.id] = now;
        }
        if (hungerPercent >= thresholdPercent && lastAlertTime > 0) {
          delete petHungerLastAlertTime[pet.id];
          if (UnifiedState3.data.settings?.debugMode) {
            console.log(`\u{1F43E} [PET-HUNGER-DEBUG] ${petName} fed above threshold, reset alert timer`);
          }
        }
        lastPetHungerStates[pet.id] = currentHunger;
      });
    } catch (error) {
      console.error("\u274C [PET-HUNGER] Error checking pet hunger:", error);
    }
  }
  function scanAndAlertHungryPets(UnifiedState3, playPetNotificationSound2, showNotificationToast2) {
    if (!UnifiedState3.data.settings.notifications.petHungerEnabled) return;
    try {
      const activePets = window.activePets || UnifiedState3.atoms.activePets || [];
      const thresholdPercent = UnifiedState3.data.settings.notifications.petHungerThreshold || 25;
      const now = Date.now();
      let hungryCount = 0;
      activePets.forEach((pet) => {
        if (!pet || !pet.id) return;
        const currentHunger = pet.hunger !== void 0 ? Number(pet.hunger) : null;
        if (currentHunger === null || isNaN(currentHunger)) {
          console.log(`\u26A0\uFE0F [PET-HUNGER] ${pet.petSpecies || "Pet"} has no hunger data in scan - skipping`);
          return;
        }
        const estimatedMaxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 1e5;
        const hungerPercent = currentHunger / estimatedMaxHunger * 100;
        const petName = pet.petSpecies || "Pet";
        if (hungerPercent < thresholdPercent) {
          hungryCount += 1;
          console.log(
            `\u{1F43E} [PET-HUNGER] Initial scan: ${petName} needs feeding! (${hungerPercent.toFixed(1)}% < ${thresholdPercent}%)`
          );
          showNotificationToast2(`\u26A0\uFE0F ${petName} needs feeding! Only ${Math.round(hungerPercent)}% full`, "warning");
          petHungerLastAlertTime[pet.id] = now;
          lastPetHungerStates[pet.id] = currentHunger;
        }
      });
      if (hungryCount > 0) {
        const volume = UnifiedState3.data.settings.notifications.volume || 0.3;
        playPetNotificationSound2(volume);
        console.log(`\u{1F43E} [PET-HUNGER] Initial scan found ${hungryCount} hungry pet(s)`);
      } else {
        console.log(`\u{1F43E} [PET-HUNGER] Initial scan: All pets are well-fed`);
      }
    } catch (error) {
      console.error("\u274C [PET-HUNGER] Error scanning for hungry pets:", error);
    }
  }
  function calculateTimeUntilHungry(pet, UnifiedState3) {
    if (!pet || typeof pet.hunger === "undefined") return null;
    const currentHunger = Number(pet.hunger) || 0;
    const maxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 1e5;
    const baseDepletionTime = SPECIES_HUNGER_DEPLETION_TIME[pet.petSpecies] || 60 * 60 * 1e3;
    if (currentHunger <= 0) return 0;
    let totalHungerReduction = 0;
    const activePets = window.activePets || UnifiedState3.atoms.activePets || [];
    if (UnifiedState3.data.settings?.debugMode) {
      console.log("\u{1F356} [HUNGER-CALC] Calculating for pet:", pet.petSpecies);
      console.log("\u{1F356} [HUNGER-CALC] Active pets:", activePets.length);
      activePets.forEach((p, i) => {
        console.log(`\u{1F356} [HUNGER-CALC] Pet ${i}:`, {
          species: p.petSpecies,
          abilities: p.abilities,
          strength: p.strength,
          str: p.str
        });
      });
    }
    activePets.forEach((p) => {
      if (p.abilities && Array.isArray(p.abilities)) {
        p.abilities.forEach((ability) => {
          if (UnifiedState3.data.settings?.debugMode) {
            console.log("\u{1F356} [HUNGER-CALC] Checking ability:", ability);
          }
          const abilityType = typeof ability === "string" ? ability : ability.abilityType || ability.type || ability;
          if (typeof abilityType === "string") {
            if (abilityType.includes("HungerBoost") || abilityType.includes("Hunger Boost")) {
              const reduction = abilityType.includes("II") ? HUNGER_BOOST_VALUES["Hunger Boost II"] : HUNGER_BOOST_VALUES["Hunger Boost I"];
              const strength = (p.strength || p.str || 100) / 100;
              totalHungerReduction += reduction * strength;
              if (UnifiedState3.data.settings?.debugMode) {
                console.log(
                  `\u{1F356} [HUNGER-CALC] Found ${abilityType} on ${p.petSpecies}, STR: ${p.strength || p.str}, reduction: ${reduction}, strength mult: ${strength}`
                );
              }
            }
          }
        });
      }
    });
    if (UnifiedState3.data.settings?.debugMode && totalHungerReduction > 0) {
      console.log(`\u{1F356} [HUNGER-CALC] Total hunger reduction: ${(totalHungerReduction * 100).toFixed(1)}%`);
    }
    totalHungerReduction = Math.min(totalHungerReduction, 0.9);
    const timeRemaining = baseDepletionTime / Math.max(0.1, 1 - totalHungerReduction) * (currentHunger / maxHunger);
    return Math.max(0, Math.round(timeRemaining));
  }
  function formatHungerTimer(milliseconds) {
    if (!milliseconds || milliseconds <= 0) return "Hungry!";
    const totalMinutes = Math.ceil(milliseconds / (60 * 1e3));
    return `${totalMinutes}m`;
  }
  function getActivePetsFromRoomState(targetWindow3, UnifiedState3) {
    console.log("\u{1F527} [DEBUG] getActivePetsFromRoomState() called - checking for pets...");
    try {
      const roomState = targetWindow3.MagicCircle_RoomConnection?.lastRoomStateJsonable;
      if (!roomState?.child?.data) {
        console.log("\u{1F43E} [SIMPLE-PETS] No room state data");
        return [];
      }
      let petData = null;
      if (roomState.child.data.field1 !== void 0) {
        petData = roomState.child.data;
        console.log("\u{1F43E} [SIMPLE-PETS] Found pet data in child.data directly");
      }
      if (!petData) {
        if (UnifiedState3.data.settings?.debugMode) {
          console.log("\u{1F43E} [SIMPLE-PETS] No pet data found in room state");
        }
        if (window.activePets && window.activePets.length > 0) {
          if (UnifiedState3.data.settings?.debugMode) {
            console.log("\u{1F43E} [FALLBACK] Using pets from myPetSlotsAtom:", window.activePets);
          }
          return window.activePets;
        }
        if (UnifiedState3.data.settings?.debugMode) {
          console.log("\u{1F43E} [SIMPLE-PETS] No pet data found in room state or atoms");
        }
        return [];
      }
      const pets = [];
      const fields = [petData.field1, petData.field2, petData.field3];
      fields.forEach((species, index) => {
        if (species && species !== "" && typeof species === "string") {
          pets.push({ petSpecies: species, slot: index + 1 });
        }
      });
      console.log("\u{1F43E} [SIMPLE-PETS] Extracted pets:", pets);
      return pets;
    } catch (error) {
      console.log("\u{1F43E} [SIMPLE-PETS] Error:", error.message);
      return [];
    }
  }
  function updateActivePetsFromRoomState(targetWindow3, UnifiedState3, updateActivePetsDisplay2 = null) {
    const roomPets = getActivePetsFromRoomState(targetWindow3, UnifiedState3);
    const previousCount = UnifiedState3.atoms.activePets?.length || 0;
    if (window.activePets && window.activePets.length > 0 && window.activePets[0] && window.activePets[0].hunger !== void 0) {
      console.log("\u{1F43E} [SIMPLE-PETS] Preserving existing full pet data from atom (has hunger)");
      roomPets.forEach((roomPet, index) => {
        if (window.activePets[index] && !window.activePets[index].petSpecies && roomPet.petSpecies) {
          window.activePets[index].petSpecies = roomPet.petSpecies;
          console.log(`\u{1F43E} [SIMPLE-PETS] Added missing species ${roomPet.petSpecies} to slot ${index + 1}`);
        }
      });
      UnifiedState3.atoms.activePets = window.activePets;
      return window.activePets;
    }
    UnifiedState3.atoms.activePets = roomPets;
    window.activePets = roomPets;
    const newCount = roomPets.length;
    if (newCount !== previousCount) {
      console.log(`\u{1F43E} [SIMPLE-PETS] Pet count changed: ${previousCount} \u2192 ${newCount}`);
      if (UnifiedState3.activeTab === "pets" && updateActivePetsDisplay2) {
        const context = document.getElementById("mga-tab-content");
        if (context) {
          updateActivePetsDisplay2(context);
        }
      }
    }
    return roomPets;
  }
  async function sendFeedPet(petItemId, cropItemId, rcSend2) {
    const payload = {
      type: "FeedPet",
      petItemId,
      cropItemId
    };
    console.log("[MGA] Feed payload:", payload);
    return rcSend2(payload);
  }
  async function feedPetEnsureSync(petItemId, cropItemId, petIndex, rcSend2, waitForServer, _enableDebugPeek = false) {
    const makePredicate = ({ payload }) => (msg) => {
      if (!msg || typeof msg !== "object") return false;
      if (msg.type === "FeedPetAck" && msg.ok && msg.petItemId === payload.petItemId) {
        return true;
      }
      if (msg.type === "PetFed" && msg.petItemId === payload.petItemId) {
        return true;
      }
      if (msg.type === "InventoryDelta" && msg.removed) {
        if (Array.isArray(msg.removed)) {
          return msg.removed.some((r) => r.id === payload.cropItemId || r === payload.cropItemId);
        }
      }
      const msgStr = JSON.stringify(msg);
      if (msgStr.includes(payload.petItemId) && msgStr.includes(payload.cropItemId)) {
        console.log("[Feed-Verify] \u{1F50D} Fallback match on IDs in:", msg.type || "unknown");
        return true;
      }
      return false;
    };
    console.log("[Feed-Debug] \u{1F680} Sending feed command");
    await sendFeedPet(petItemId, cropItemId, rcSend2);
    const ack = await waitForServer(makePredicate({ type: "FeedPet", payload: { petItemId, cropItemId } })).catch(
      () => null
    );
    if (ack) {
      console.log("[Feed-Verify] \u2705 verified by server event");
      return { verified: true };
    }
    console.warn("[Feed-Verify] \u274C no ack/delta in timeout period");
    return { verified: false };
  }
  function updatePetPresetDropdown(context, UnifiedState3, targetDocument2) {
    const select = context.querySelector("#preset-quick-select");
    if (!select) return;
    const currentValue = select.value;
    select.innerHTML = '<option value="">-- Select Preset --</option>';
    Object.keys(UnifiedState3.data.petPresets).forEach((name) => {
      const preset = UnifiedState3.data.petPresets[name];
      const option = targetDocument2.createElement("option");
      option.value = name;
      option.textContent = `${name} (${preset.map((p) => p.petSpecies).join(", ")})`;
      select.appendChild(option);
    });
    if (currentValue && UnifiedState3.data.petPresets[currentValue]) {
      select.value = currentValue;
    }
    if (UnifiedState3.data.settings?.debugMode) {
      console.log("[PETS_UI] Updated preset dropdown without full refresh");
    }
  }
  function updateActivePetsDisplay(context, UnifiedState3, calculateTimeUntilHungry2, formatHungerTimer2, retryCount = 0) {
    if (UnifiedState3.data.settings?.debugMode) {
      console.log("\u{1F43E} [ACTIVE-PETS] Updating display", {
        retryCount,
        unifiedStateActivePets: UnifiedState3.atoms.activePets?.length || 0,
        windowActivePets: window.activePets?.length || 0,
        context: context === document ? "document" : "overlay"
      });
    }
    const activePets = UnifiedState3.atoms.activePets || window.activePets || [];
    if (activePets.length === 0 && retryCount < 3) {
      if (UnifiedState3.data.settings?.debugMode) {
        console.log(`\u{1F43E} [ACTIVE-PETS] No pets found, retrying in ${100 * (retryCount + 1)}ms...`);
      }
      setTimeout(
        () => updateActivePetsDisplay(context, UnifiedState3, calculateTimeUntilHungry2, formatHungerTimer2, retryCount + 1),
        100 * (retryCount + 1)
      );
      return;
    }
    const activePetsDisplays = context.querySelectorAll(".mga-active-pets-display");
    activePetsDisplays.forEach((display) => {
      const innerHTML = activePets.length > 0 ? `
              <div class="mga-active-pets-header">Currently Equipped:</div>
              <div class="mga-active-pets-list">
                  ${activePets.map((p, index) => {
        const timeUntilHungry = calculateTimeUntilHungry2(p, UnifiedState3);
        const timerText = formatHungerTimer2(timeUntilHungry);
        const timerColor = timeUntilHungry === null ? "#999" : timeUntilHungry <= 0 ? "#8B0000" : timeUntilHungry < 5 * 60 * 1e3 ? "#ff4444" : timeUntilHungry < 15 * 60 * 1e3 ? "#ffa500" : "#4caf50";
        return `
                          <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                              <span class="mga-pet-badge">${p.petSpecies}</span>
                              <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                          </div>
                      `;
      }).join("")}
              </div>
          ` : `
              <div class="mga-empty-state">
                  <div class="mga-empty-state-icon">\u2014</div>
                  <div class="mga-empty-state-description">No pets currently active</div>
              </div>
          `;
      display.innerHTML = innerHTML;
    });
    if (UnifiedState3.data.settings?.debugMode) {
      console.log("\u{1F43E} [ACTIVE-PETS] Updated display elements:", {
        elementsFound: activePetsDisplays.length,
        activePetsCount: activePets.length
      });
    }
  }
  function ensurePresetOrder(UnifiedState3) {
    if (!UnifiedState3.data.petPresetsOrder || !Array.isArray(UnifiedState3.data.petPresetsOrder)) {
      UnifiedState3.data.petPresetsOrder = Object.keys(UnifiedState3.data.petPresets);
    } else {
      Object.keys(UnifiedState3.data.petPresets).forEach((name) => {
        if (!UnifiedState3.data.petPresetsOrder.includes(name)) {
          UnifiedState3.data.petPresetsOrder.push(name);
        }
      });
      UnifiedState3.data.petPresetsOrder = UnifiedState3.data.petPresetsOrder.filter(
        (name) => Object.prototype.hasOwnProperty.call(UnifiedState3.data.petPresets, name)
      );
    }
  }
  function movePreset(presetName, direction, context, UnifiedState3, MGA_saveJSON2, refreshPresetsList2, refreshSeparateWindowPopouts2, updateTabContent) {
    console.log(`\u{1F6A8} [CRITICAL] movePreset called: ${presetName} ${direction}`);
    console.log(`\u{1F6A8} [CRITICAL] Current order:`, UnifiedState3.data.petPresetsOrder);
    ensurePresetOrder(UnifiedState3);
    const currentIndex = UnifiedState3.data.petPresetsOrder.indexOf(presetName);
    if (currentIndex === -1) return;
    let newIndex;
    if (direction === "up" && currentIndex > 0) {
      newIndex = currentIndex - 1;
    } else if (direction === "down" && currentIndex < UnifiedState3.data.petPresetsOrder.length - 1) {
      newIndex = currentIndex + 1;
    } else {
      return;
    }
    const temp = UnifiedState3.data.petPresetsOrder[currentIndex];
    UnifiedState3.data.petPresetsOrder[currentIndex] = UnifiedState3.data.petPresetsOrder[newIndex];
    UnifiedState3.data.petPresetsOrder[newIndex] = temp;
    MGA_saveJSON2("MGA_petPresetsOrder", UnifiedState3.data.petPresetsOrder);
    console.log(`\u{1F6A8} [CRITICAL] Order after swap:`, UnifiedState3.data.petPresetsOrder);
    refreshPresetsList2(context, UnifiedState3, MGA_saveJSON2);
    refreshSeparateWindowPopouts2("pets");
    if (UnifiedState3.activeTab === "pets") {
      updateTabContent();
    }
    console.log(`\u{1F4CB} [PET-PRESETS] Moved preset "${presetName}" ${direction}`);
  }
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll(".mga-preset:not(.dragging)")];
    return draggableElements.reduce(
      (closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          return { offset, element: child };
        } else {
          return closest;
        }
      },
      { offset: Number.NEGATIVE_INFINITY }
    ).element;
  }
  function refreshPresetsList(context, UnifiedState3, MGA_saveJSON2) {
    const presetsList = context.querySelector("#presets-list");
    if (!presetsList) return;
    presetsList.innerHTML = "";
    ensurePresetOrder(UnifiedState3);
    UnifiedState3.data.petPresetsOrder.forEach((name) => {
      if (UnifiedState3.data.petPresets[name]) {
        addPresetToList(context, name, UnifiedState3.data.petPresets[name], UnifiedState3, MGA_saveJSON2);
      }
    });
  }
  function addPresetToList(context, name, preset, UnifiedState3, _MGA_saveJSON) {
    const presetsList = context.querySelector("#presets-list");
    if (!presetsList) return;
    const targetDocument2 = context.ownerDocument || document;
    const presetDiv = targetDocument2.createElement("div");
    presetDiv.className = "mga-preset";
    presetDiv.draggable = true;
    presetDiv.dataset.presetName = name;
    const hotkey = UnifiedState3.data.petPresetHotkeys[name];
    presetDiv.innerHTML = `
          <div class="mga-preset-header" style="cursor: move;">
              <span class="mga-preset-name">\u22EE\u22EE ${name}</span>
              <button class="mga-hotkey-btn" data-preset="${name}" style="margin-left: auto; padding: 2px 8px; font-size: 11px; background: rgba(100, 200, 255, 0.48); border: 1px solid #4a9eff; border-radius: 4px; color: white; cursor: pointer;">
                  ${hotkey || "Set Hotkey"}
              </button>
          </div>
          <div class="mga-preset-pets">${preset.map((p) => p.petSpecies).join(", ")}</div>
          <div class="mga-preset-actions">
              <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                  <button class="mga-btn mga-btn-sm" data-action="move-up" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">\u2191</button>
                  <button class="mga-btn mga-btn-sm" data-action="move-down" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">\u2193</button>
                  <button class="mga-btn mga-btn-sm" data-action="save" data-preset="${name}">Save Current</button>
              </div>
              <div style="display: flex; gap: 4px;">
                  <button class="mga-btn mga-btn-sm" data-action="place" data-preset="${name}">Place</button>
                  <button class="mga-btn mga-btn-sm" data-action="remove" data-preset="${name}">Remove</button>
              </div>
          </div>
      `;
    presetsList.appendChild(presetDiv);
    if (UnifiedState3.data.settings?.debugMode) {
      console.log(`[PETS_UI] Added preset ${name} to list without full refresh`);
    }
  }
  function setupPetsTabHandlers(context, deps) {
    const {
      UnifiedState: UnifiedState3,
      MGA_saveJSON: MGA_saveJSON2,
      targetDocument: targetDocument2,
      movePreset: movePreset2,
      refreshPresetsList: refreshPresetsList2,
      updatePetPresetDropdown: updatePetPresetDropdown2,
      refreshSeparateWindowPopouts: refreshSeparateWindowPopouts2,
      showHotkeyRecordingModal,
      safeSendMessage: safeSendMessage2,
      updateActivePetsFromRoomState: updateActivePetsFromRoomState2,
      updateActivePetsDisplay: updateActivePetsDisplayFn,
      updatePureOverlayContent: updatePureOverlayContent2,
      startRecordingHotkeyMGTools: startRecordingHotkeyMGTools2,
      debouncedPlacePetPreset,
      calculateTimeUntilHungry: calculateTimeUntilHungry2,
      formatHungerTimer: formatHungerTimer2,
      exportPetPresets: exportPetPresetsFn,
      importPetPresets: importPetPresetsFn
    } = deps;
    console.log("\u{1F6A8} [CRITICAL] Setting up pet preset handlers");
    const presetsContainer = context.querySelector("#presets-list");
    if (presetsContainer) {
      console.log("\u{1F6A8} [CRITICAL] Found presets container, adding delegation");
      if (presetsContainer._mgaClickHandler) {
        presetsContainer.removeEventListener("click", presetsContainer._mgaClickHandler);
      }
      presetsContainer._mgaClickHandler = (e) => {
        const btn = e.target.closest("[data-action]");
        if (!btn) return;
        e.preventDefault();
        e.stopPropagation();
        const action = btn.dataset.action;
        const presetName = btn.dataset.preset;
        console.log(`\u{1F6A8} [CRITICAL] Delegated click: action=${action}, preset=${presetName}`);
        if (action === "move-up") {
          console.log(`\u{1F6A8} [CRITICAL] Moving ${presetName} UP`);
          movePreset2(
            presetName,
            "up",
            context,
            UnifiedState3,
            MGA_saveJSON2,
            refreshPresetsList2,
            refreshSeparateWindowPopouts2,
            () => {
            }
          );
        } else if (action === "move-down") {
          console.log(`\u{1F6A8} [CRITICAL] Moving ${presetName} DOWN`);
          movePreset2(
            presetName,
            "down",
            context,
            UnifiedState3,
            MGA_saveJSON2,
            refreshPresetsList2,
            refreshSeparateWindowPopouts2,
            () => {
            }
          );
        } else if (action === "save") {
          console.log(`\u{1F6A8} [CRITICAL] Saving preset ${presetName}`);
          UnifiedState3.data.petPresets[presetName] = (UnifiedState3.atoms.activePets || []).slice(0, 3);
          MGA_saveJSON2("MGA_petPresets", UnifiedState3.data.petPresets);
          refreshPresetsList2(context, UnifiedState3, MGA_saveJSON2);
        } else if (action === "place") {
          console.log(`\u{1F6A8} [CRITICAL] Placing preset ${presetName}`);
          debouncedPlacePetPreset(presetName);
        } else if (action === "remove") {
          console.log(`[CRITICAL] Removing preset ${presetName}`);
          delete UnifiedState3.data.petPresets[presetName];
          if (UnifiedState3.data.petPresetHotkeys[presetName]) {
            const deletedHotkey = UnifiedState3.data.petPresetHotkeys[presetName];
            delete UnifiedState3.data.petPresetHotkeys[presetName];
            MGA_saveJSON2("MGA_petPresetHotkeys", UnifiedState3.data.petPresetHotkeys);
            console.log(`[MGTOOLS] Cleared hotkey "${deletedHotkey}" for deleted preset: ${presetName}`);
          }
          MGA_saveJSON2("MGA_petPresets", UnifiedState3.data.petPresets);
          refreshPresetsList2(context, UnifiedState3, MGA_saveJSON2);
        }
      };
      presetsContainer.addEventListener("click", presetsContainer._mgaClickHandler);
      console.log("\u{1F6A8} [CRITICAL] Event delegation handler attached successfully");
      context.querySelectorAll(".mga-hotkey-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const presetName = btn.dataset.preset;
          showHotkeyRecordingModal(presetName, context);
        });
      });
    } else {
      console.log("\u{1F6A8} [CRITICAL] ERROR: presets container not found!");
    }
    const input = context.querySelector("#preset-name-input");
    if (input) {
      let handlingEvent = false;
      const createInputIsolation = function(inputElement) {
        const isolateKeyEvent = (e) => {
          if (document.activeElement === inputElement) {
            e.stopImmediatePropagation();
            e.stopPropagation();
            if (e.key === "Escape") {
              e.preventDefault();
              inputElement.blur();
              return;
            }
            if (e.key === "Enter") {
              e.preventDefault();
              const addBtn2 = context.querySelector("#add-preset-btn");
              if (addBtn2) addBtn2.click();
              return;
            }
          }
        };
        ["keydown", "keyup", "keypress"].forEach((eventType) => {
          inputElement.addEventListener(eventType, isolateKeyEvent, {
            capture: true,
            passive: false
          });
        });
        inputElement.addEventListener("focus", (e) => {
          if (UnifiedState3.data.settings.debugMode) {
            console.log("\u{1F512} Input focused - Game keys isolated");
          }
          e.stopPropagation();
        });
        inputElement.addEventListener("blur", (e) => {
          if (UnifiedState3.data.settings.debugMode) {
            console.log("\u{1F513} Input blurred - Game keys restored");
          }
          e.stopPropagation();
        });
      };
      createInputIsolation(input);
      input.addEventListener("mousedown", (e) => {
        if (handlingEvent) return;
        handlingEvent = true;
        e.stopPropagation();
        setTimeout(() => {
          handlingEvent = false;
        }, 50);
      });
      input.addEventListener("click", (e) => {
        if (handlingEvent) return;
        e.stopPropagation();
        if (input.value === "" || document.activeElement !== input) {
          setTimeout(() => {
            input.focus();
            input.select();
          }, 0);
        }
      });
    }
    const setCycleHotkeyBtn = context.querySelector("#set-cycle-hotkey-btn");
    if (setCycleHotkeyBtn && !setCycleHotkeyBtn.hasAttribute("data-handler-setup")) {
      setCycleHotkeyBtn.setAttribute("data-handler-setup", "true");
      setCycleHotkeyBtn.addEventListener("click", () => {
        startRecordingHotkeyMGTools2("cyclePresets", setCycleHotkeyBtn);
      });
    }
    const quickLoadBtn = context.querySelector("#quick-load-btn");
    if (quickLoadBtn && !quickLoadBtn.hasAttribute("data-handler-setup")) {
      quickLoadBtn.setAttribute("data-handler-setup", "true");
      quickLoadBtn.addEventListener("click", () => {
        const select = context.querySelector("#preset-quick-select");
        const presetName = select.value;
        if (!presetName) {
          console.warn("[PETS] No preset selected");
          return;
        }
        if (!UnifiedState3.data.petPresets[presetName]) {
          console.warn("[PETS] Preset not found:", presetName);
          return;
        }
        const preset = UnifiedState3.data.petPresets[presetName];
        if (!preset || !Array.isArray(preset) || preset.length === 0) {
          console.warn("[PETS] Preset is empty or invalid:", preset);
          return;
        }
        const maxSlots = 3;
        let delay = 0;
        for (let slotIndex = 0; slotIndex < maxSlots; slotIndex++) {
          const desiredPet = preset[slotIndex];
          ((currentDelay, slot) => {
            setTimeout(() => {
              const currentPets = UnifiedState3.atoms.activePets || window.activePets || [];
              const currentPet = currentPets[slot];
              if (currentPet && desiredPet) {
                if (currentPet.id === desiredPet.id) {
                  if (UnifiedState3.data.settings?.debugMode) {
                    console.log(`[PET-SWAP] Slot ${slot + 1}: Already equipped (${currentPet.id}), skipping`);
                  }
                  return;
                }
                if (UnifiedState3.data.settings?.debugMode) {
                  console.log(`[PET-SWAP] Slot ${slot + 1}: Swapping ${currentPet.id} \u2192 ${desiredPet.id}`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "SwapPet",
                  petSlotId: currentPet.id,
                  petInventoryId: desiredPet.id
                });
              } else if (!currentPet && desiredPet) {
                if (UnifiedState3.data.settings?.debugMode) {
                  console.log(`[PET-SWAP] Slot ${slot + 1}: Placing ${desiredPet.id} (empty slot)`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "PlacePet",
                  itemId: desiredPet.id,
                  position: { x: 17 + slot * 2, y: 13 },
                  localTileIndex: 64,
                  tileType: "Boardwalk"
                });
              } else if (currentPet && !desiredPet) {
                if (UnifiedState3.data.settings?.debugMode) {
                  console.log(`[PET-SWAP] Slot ${slot + 1}: Storing ${currentPet.id} (no preset pet)`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "StorePet",
                  itemId: currentPet.id
                });
              }
            }, currentDelay);
          })(delay, slotIndex);
          delay += 200;
        }
        setTimeout(() => {
          updateActivePetsFromRoomState2();
          updateActivePetsDisplayFn(context, UnifiedState3, calculateTimeUntilHungry2, formatHungerTimer2);
        }, delay + 200);
        setTimeout(() => {
          updateActivePetsFromRoomState2();
          updateActivePetsDisplayFn(context, UnifiedState3, calculateTimeUntilHungry2, formatHungerTimer2);
        }, delay + 600);
        setTimeout(() => {
          updateActivePetsFromRoomState2();
          updateActivePetsDisplayFn(context, UnifiedState3, calculateTimeUntilHungry2, formatHungerTimer2);
          refreshSeparateWindowPopouts2("pets");
          UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
            if (overlay && document.contains(overlay) && tabName === "pets") {
              if (overlay.className.includes("mga-overlay-content-only")) {
                updatePureOverlayContent2(overlay, tabName);
              }
            }
          });
        }, delay + 1e3);
      });
    }
    const addBtn = context.querySelector("#add-preset-btn");
    if (addBtn && !addBtn.hasAttribute("data-handler-setup")) {
      addBtn.setAttribute("data-handler-setup", "true");
      addBtn.addEventListener("click", () => {
        const input2 = context.querySelector("#preset-name-input");
        const name = input2.value.trim();
        if (name && UnifiedState3.atoms.activePets && UnifiedState3.atoms.activePets.length) {
          UnifiedState3.data.petPresets[name] = UnifiedState3.atoms.activePets.slice(0, 3);
          MGA_saveJSON2("MGA_petPresets", UnifiedState3.data.petPresets);
          input2.value = "";
          ensurePresetOrder(UnifiedState3);
          if (!UnifiedState3.data.petPresetsOrder.includes(name)) {
            UnifiedState3.data.petPresetsOrder.push(name);
            MGA_saveJSON2("MGA_petPresetsOrder", UnifiedState3.data.petPresetsOrder);
          }
          refreshPresetsList2(context, UnifiedState3, MGA_saveJSON2);
          updatePetPresetDropdown2(context, UnifiedState3, targetDocument2);
          refreshSeparateWindowPopouts2("pets");
          UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
            if (overlay && document.contains(overlay) && tabName === "pets") {
              if (overlay.className.includes("mga-overlay-content-only")) {
                updatePureOverlayContent2(overlay, tabName);
              }
            }
          });
          if (UnifiedState3.data.settings?.debugMode) {
            console.log(`[BUTTON_INTERACTIONS] Created new preset: ${name} without full DOM refresh`);
          }
        } else if (!name) {
          input2.focus();
        }
      });
    }
    const exportBtn = context.querySelector("#export-presets-btn");
    if (exportBtn && !exportBtn.hasAttribute("data-handler-setup")) {
      exportBtn.setAttribute("data-handler-setup", "true");
      exportBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        exportPetPresetsFn(UnifiedState3);
      });
    }
    const importBtn = context.querySelector("#import-presets-btn");
    if (importBtn && !importBtn.hasAttribute("data-handler-setup")) {
      importBtn.setAttribute("data-handler-setup", "true");
      importBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        importPetPresetsFn(UnifiedState3, MGA_saveJSON2);
      });
    }
    console.log("[PETS_UI] Event handlers setup complete");
  }
  function getPetsPopoutContent2(deps) {
    const { UnifiedState: UnifiedState3, calculateTimeUntilHungry: calculateTimeUntilHungry2, formatHungerTimer: formatHungerTimer2, ensurePresetOrder: ensurePresetOrder2 } = deps;
    const activePets = UnifiedState3.atoms.activePets || window.activePets || [];
    const petPresets = UnifiedState3.data.petPresets;
    if (Object.keys(petPresets).length === 0) {
      return `
            <div class="mga-section">
                <div class="mga-section-title mga-pet-section-title">Active Pets</div>
                <div class="mga-active-pets-display">
                    ${activePets.length > 0 ? `
                        <div style="color: #93c5fd; font-size: 12px; margin-bottom: 4px;">Currently Equipped:</div>
                        <div class="mga-active-pets-list">
                            ${activePets.map((p, index) => {
        const timeUntilHungry = calculateTimeUntilHungry2(p, UnifiedState3);
        const timerText = formatHungerTimer2(timeUntilHungry);
        const timerColor = timeUntilHungry === null ? "#999" : timeUntilHungry <= 0 ? "#8B0000" : timeUntilHungry < 5 * 60 * 1e3 ? "#ff4444" : timeUntilHungry < 15 * 60 * 1e3 ? "#ffa500" : "#4caf50";
        return `
                                    <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                        <span class="mga-pet-badge">${p.petSpecies}</span>
                                        <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                    </div>
                                `;
      }).join("")}
                        </div>
                    ` : `
                        <div class="mga-empty-state">
                            <div class="mga-empty-state-icon">\u2014</div>
                            <div class="mga-empty-state-description">No pets currently active</div>
                        </div>
                    `}
                </div>
            </div>
            <div class="mga-section">
                <div class="mga-empty-state" style="padding: 40px 20px;">
                    <div class="mga-empty-state-icon">\u{1F4CB}</div>
                    <div class="mga-empty-state-title">No Saved Presets</div>
                    <div class="mga-empty-state-description">
                        You haven't saved any pet loadout presets yet.<br>
                        Open the main HUD Pets tab to create presets from your current active pets.
                    </div>
                </div>
            </div>
        `;
    }
    let html = `
        <div class="mga-section">
            <div class="mga-section-title mga-pet-section-title">Active Pets</div>
            <div class="mga-active-pets-display">
                ${activePets.length > 0 ? `
                    <div class="mga-active-pets-header">Currently Equipped:</div>
                    <div class="mga-active-pets-list">
                        ${activePets.map((p, index) => {
      const timeUntilHungry = calculateTimeUntilHungry2(p, UnifiedState3);
      const timerText = formatHungerTimer2(timeUntilHungry);
      const timerColor = timeUntilHungry === null ? "#999" : timeUntilHungry <= 0 ? "#8B0000" : timeUntilHungry < 5 * 60 * 1e3 ? "#ff4444" : timeUntilHungry < 15 * 60 * 1e3 ? "#ffa500" : "#4caf50";
      return `
                                <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                    <span class="mga-pet-badge">${p.petSpecies}</span>
                                    <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                </div>
                            `;
    }).join("")}
                    </div>
                ` : `
                    <div class="mga-empty-state">
                        <div class="mga-empty-state-icon">\u2014</div>
                        <div class="mga-empty-state-description">No pets currently active</div>
                    </div>
                `}
            </div>
        </div>

        <div class="mga-section">
            <div class="mga-section-title">Load Pet Preset</div>
    `;
    ensurePresetOrder2(UnifiedState3);
    UnifiedState3.data.petPresetsOrder.forEach((name) => {
      if (petPresets[name]) {
        const pets = petPresets[name];
        const petList = pets.map((p) => p.petSpecies).join(", ");
        html += `
                <div class="mga-preset mga-preset-clickable" data-preset="${name}">
                    <div class="mga-preset-header">
                        <span class="mga-preset-name">${name}</span>
                    </div>
                    <div class="mga-preset-pets">${petList}</div>
                </div>
            `;
      }
    });
    html += `</div>`;
    return html;
  }
  function setupPetPopoutHandlers2(context, deps) {
    const {
      UnifiedState: UnifiedState3,
      safeSendMessage: safeSendMessage2,
      updateActivePetsFromRoomState: updateActivePetsFromRoomState2,
      refreshSeparateWindowPopouts: refreshSeparateWindowPopouts2,
      updatePureOverlayContent: updatePureOverlayContent2,
      updateTabContent,
      movePreset: movePresetFn,
      refreshPresetsList: refreshPresetsList2,
      MGA_saveJSON: MGA_saveJSON2,
      exportPetPresets: exportPetPresetsFn,
      importPetPresets: importPetPresetsFn,
      productionLog: productionLog3,
      productionWarn: productionWarn3
    } = deps;
    const cards = context.querySelectorAll(".mga-preset-clickable[data-preset]");
    cards.forEach((presetCard) => {
      const newCard = presetCard.cloneNode(true);
      presetCard.parentNode.replaceChild(newCard, presetCard);
      newCard.addEventListener("click", (e) => {
        const presetName = e.currentTarget.dataset.preset;
        if (!presetName || !UnifiedState3.data.petPresets[presetName]) {
          productionWarn3("\u26A0\uFE0F Preset not found!");
          return;
        }
        const preset = UnifiedState3.data.petPresets[presetName];
        const maxSlots = 3;
        let delay = 0;
        for (let slotIndex = 0; slotIndex < maxSlots; slotIndex++) {
          const desiredPet = preset[slotIndex];
          ((currentDelay, slot) => {
            setTimeout(() => {
              const currentPets = UnifiedState3.atoms.activePets || window.activePets || [];
              const currentPet = currentPets[slot];
              if (currentPet && desiredPet) {
                if (currentPet.id === desiredPet.id) {
                  if (UnifiedState3.data.settings?.debugMode) {
                    productionLog3(`[PET-SWAP] Slot ${slot + 1}: Already equipped (${currentPet.id}), skipping`);
                  }
                  return;
                }
                if (UnifiedState3.data.settings?.debugMode) {
                  productionLog3(`[PET-SWAP] Slot ${slot + 1}: Swapping ${currentPet.id} \u2192 ${desiredPet.id}`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "SwapPet",
                  petSlotId: currentPet.id,
                  petInventoryId: desiredPet.id
                });
              } else if (!currentPet && desiredPet) {
                if (UnifiedState3.data.settings?.debugMode) {
                  productionLog3(`[PET-SWAP] Slot ${slot + 1}: Placing ${desiredPet.id} (empty slot)`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "PlacePet",
                  itemId: desiredPet.id,
                  position: { x: 17 + slot * 2, y: 13 },
                  localTileIndex: 64,
                  tileType: "Boardwalk"
                });
              } else if (currentPet && !desiredPet) {
                if (UnifiedState3.data.settings?.debugMode) {
                  productionLog3(`[PET-SWAP] Slot ${slot + 1}: Storing ${currentPet.id} (no preset pet)`);
                }
                safeSendMessage2({
                  scopePath: ["Room", "Quinoa"],
                  type: "StorePet",
                  itemId: currentPet.id
                });
              }
            }, currentDelay);
          })(delay, slotIndex);
          delay += 200;
        }
        const refreshPetDisplays = () => {
          updateActivePetsFromRoomState2();
          const contextDoc = context.ownerDocument || context;
          const contextWindow = contextDoc.defaultView || window;
          const isSeparateWindow = contextWindow !== window && contextWindow.refreshPopoutContent;
          if (isSeparateWindow) {
            contextWindow.refreshPopoutContent("pets");
          } else {
            refreshSeparateWindowPopouts2("pets");
            UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === "pets") {
                if (overlay.className.includes("mga-overlay-content-only")) {
                  updatePureOverlayContent2(overlay, tabName);
                }
              }
            });
            if (UnifiedState3.activeTab === "pets") {
              updateTabContent();
            }
          }
        };
        setTimeout(() => {
          refreshPetDisplays();
          setTimeout(() => {
            const overlay = UnifiedState3.data.popouts.overlays.get("pets");
            if (overlay && document.contains(overlay)) {
              setupPetPopoutHandlers2(overlay, deps);
            }
          }, 500);
        }, delay + 500);
        e.currentTarget.style.pointerEvents = "none";
        const originalBackground = e.currentTarget.style.background;
        e.currentTarget.style.background = "rgba(16, 185, 129, 0.3)";
        setTimeout(() => {
          e.currentTarget.style.background = originalBackground;
          e.currentTarget.style.pointerEvents = "";
        }, 200);
      });
    });
    const presetsContainer = context.querySelector("#presets-list");
    if (presetsContainer) {
      if (presetsContainer._mgaClickHandler) {
        presetsContainer.removeEventListener("click", presetsContainer._mgaClickHandler);
      }
      presetsContainer._mgaClickHandler = (e) => {
        const btn = e.target.closest("[data-action]");
        if (!btn) return;
        e.preventDefault();
        e.stopPropagation();
        const action = btn.dataset.action;
        const presetName = btn.dataset.preset;
        if (action === "move-up") {
          movePresetFn(
            presetName,
            "up",
            context,
            UnifiedState3,
            MGA_saveJSON2,
            refreshPresetsList2,
            refreshSeparateWindowPopouts2,
            updateTabContent
          );
        } else if (action === "move-down") {
          movePresetFn(
            presetName,
            "down",
            context,
            UnifiedState3,
            MGA_saveJSON2,
            refreshPresetsList2,
            refreshSeparateWindowPopouts2,
            updateTabContent
          );
        } else if (action === "save") {
          UnifiedState3.data.petPresets[presetName] = (UnifiedState3.atoms.activePets || []).slice(0, 3);
          MGA_saveJSON2("MGA_petPresets", UnifiedState3.data.petPresets);
          refreshPresetsList2(context, UnifiedState3, MGA_saveJSON2);
          refreshSeparateWindowPopouts2("pets");
        } else if (action === "place") {
          window.debouncedPlacePetPreset(presetName);
        } else if (action === "remove") {
          delete UnifiedState3.data.petPresets[presetName];
          const saveSuccess = MGA_saveJSON2("MGA_petPresets", UnifiedState3.data.petPresets);
          if (UnifiedState3.data.petPresetHotkeys[presetName]) {
            const deletedHotkey = UnifiedState3.data.petPresetHotkeys[presetName];
            delete UnifiedState3.data.petPresetHotkeys[presetName];
            MGA_saveJSON2("MGA_petPresetHotkeys", UnifiedState3.data.petPresetHotkeys);
            console.log(`[MGTOOLS-FIX] \u2705 Cleared hotkey "${deletedHotkey}" for deleted preset: ${presetName}`);
          }
          if (!saveSuccess) {
            console.error("\u274C Failed to save after removing preset");
            alert("\u26A0\uFE0F Failed to save changes! The preset removal may not persist.");
          }
          refreshPresetsList2(context, UnifiedState3, MGA_saveJSON2);
          refreshSeparateWindowPopouts2("pets");
        }
      };
      presetsContainer.addEventListener("click", presetsContainer._mgaClickHandler);
    }
    const exportBtn = context.querySelector("#export-presets-btn");
    if (exportBtn && !exportBtn.hasAttribute("data-handler-setup")) {
      exportBtn.setAttribute("data-handler-setup", "true");
      exportBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        exportPetPresetsFn(UnifiedState3);
      });
    }
    const importBtn = context.querySelector("#import-presets-btn");
    if (importBtn && !importBtn.hasAttribute("data-handler-setup")) {
      importBtn.setAttribute("data-handler-setup", "true");
      importBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        importPetPresetsFn(UnifiedState3, MGA_saveJSON2);
      });
    }
  }
  function getPetsTabContent(deps) {
    const { UnifiedState: UnifiedState3, calculateTimeUntilHungry: calculateTimeUntilHungry2, formatHungerTimer: formatHungerTimer2, ensurePresetOrder: ensurePresetOrder2, productionLog: productionLog3 } = deps;
    const activePets = UnifiedState3.atoms.activePets || window.activePets || [];
    const petPresets = UnifiedState3.data.petPresets;
    productionLog3("\u{1F43E} [PETS-TAB-CONTENT] Generating HTML with pets:", {
      unifiedStateActivePets: UnifiedState3.atoms.activePets?.length || 0,
      windowActivePets: window.activePets?.length || 0,
      finalActivePets: activePets.length,
      activePetsData: activePets
    });
    const cycleHotkey = UnifiedState3.data.hotkeys?.mgToolsKeys?.cyclePresets?.custom;
    const totalPresets = Object.keys(petPresets).length;
    let html = `
        ${totalPresets > 0 ? `
            <div class="mga-section" style="padding: 8px 12px; background: rgba(139, 92, 246, 0.15); border-left: 3px solid #8b5cf6; margin-bottom: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                    <div style="flex: 1;">
                        <div style="font-size: 11px; color: #a78bfa; font-weight: 600; margin-bottom: 2px;">\u{1F504} CYCLE PRESETS</div>
                        <div style="font-size: 10px; color: rgba(255,255,255,0.7);">
                            ${cycleHotkey ? `Hotkey: <span style="background: rgba(139, 92, 246, 0.4); padding: 1px 6px; border-radius: 3px; font-weight: 600;">${cycleHotkey.toUpperCase()}</span>` : "No hotkey set"}
                        </div>
                    </div>
                    <button class="mga-btn" id="set-cycle-hotkey-btn" style="padding: 4px 12px; font-size: 11px; white-space: nowrap; background: rgba(139, 92, 246, 0.4); border: 1px solid #8b5cf6;">
                        ${cycleHotkey ? "Change" : "Set Key"}
                    </button>
                </div>
            </div>
        ` : ""}
        <div class="mga-section">
            <div class="mga-section-title mga-pet-section-title">Active Pets</div>
            <div class="mga-active-pets-display">
                ${activePets.length > 0 ? `
                    <div class="mga-active-pets-header">Currently Equipped:</div>
                    <div class="mga-active-pets-list">
                        ${activePets.map((p, index) => {
      const timeUntilHungry = calculateTimeUntilHungry2(p, UnifiedState3);
      const timerText = formatHungerTimer2(timeUntilHungry);
      const timerColor = timeUntilHungry === null ? "#999" : timeUntilHungry <= 0 ? "#8B0000" : timeUntilHungry < 5 * 60 * 1e3 ? "#ff4444" : timeUntilHungry < 15 * 60 * 1e3 ? "#ffa500" : "#4caf50";
      return `
                                <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                    <span class="mga-pet-badge">${p.petSpecies}</span>
                                    <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                </div>
                            `;
    }).join("")}
                    </div>
                ` : `
                    <div class="mga-empty-state">
                        <div class="mga-empty-state-icon">\u2014</div>
                        <div class="mga-empty-state-description">No pets currently active</div>
                    </div>
                `}
            </div>
        </div>

        <div class="mga-section">
            <div class="mga-section-title mga-pet-section-title">Quick Load Preset</div>
            <select class="mga-select" id="preset-quick-select" style="margin-bottom: 8px;">
                <option value="">-- Select Preset --</option>
                ${Object.keys(petPresets).map(
      (name) => `<option value="${name}">${name} (${petPresets[name].map((p) => p.petSpecies).join(", ")})</option>`
    ).join("")}
            </select>
            <button class="mga-btn" id="quick-load-btn" style="width: 100%;">Load</button>
        </div>

        <div class="mga-section">
            <div class="mga-section-title mga-pet-section-title">Create New Preset</div>
            <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px; margin-bottom: 8px;">
                <input type="text" class="mga-input" id="preset-name-input" placeholder="Preset name...">
                <button class="mga-btn" id="add-preset-btn" style="white-space: nowrap; padding: 6px 24px;">Save Current</button>
            </div>
        </div>

        <div class="mga-section">
            <div class="mga-section-title mga-pet-section-title">Manage Presets</div>

            <!-- Export/Import Buttons (v3.8.7) -->
            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                <button id="export-presets-btn" class="mga-btn mga-btn-sm" style="flex: 1; background: #10b981; border-color: #059669; padding: 6px 12px;">
                    \u{1F4E4} Export Backup
                </button>
                <button id="import-presets-btn" class="mga-btn mga-btn-sm" style="flex: 1; background: #3b82f6; border-color: #2563eb; padding: 6px 12px;">
                    \u{1F4E5} Import Backup
                </button>
            </div>

            <div id="presets-list" class="mga-scrollable mga-presets-container">
    `;
    ensurePresetOrder2(UnifiedState3);
    UnifiedState3.data.petPresetsOrder.forEach((name) => {
      if (petPresets[name]) {
        const pets = petPresets[name];
        const hotkey = UnifiedState3.data.petPresetHotkeys[name];
        html += `
                <div class="mga-preset">
                    <div class="mga-preset-header">
                        <span class="mga-preset-name">${name}</span>
                        <button class="mga-hotkey-btn" data-preset="${name}" style="margin-left: auto; padding: 2px 8px; font-size: 11px; background: rgba(100, 200, 255, 0.48); border: 1px solid #4a9eff; border-radius: 4px; color: white; cursor: pointer;">
                            ${hotkey || "Set Hotkey"}
                        </button>
                    </div>
                    <div class="mga-preset-pets">${pets.map((p) => p.petSpecies).join(", ")}</div>
                    <div class="mga-preset-actions">
                        <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                            <button class="mga-btn mga-btn-sm" data-action="move-up" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">\u2191</button>
                            <button class="mga-btn mga-btn-sm" data-action="move-down" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">\u2193</button>
                            <button class="mga-btn mga-btn-sm" data-action="save" data-preset="${name}">Save Current</button>
                        </div>
                        <div style="display: flex; gap: 4px;">
                            <button class="mga-btn mga-btn-sm" data-action="place" data-preset="${name}">Place</button>
                            <button class="mga-btn mga-btn-sm" data-action="remove" data-preset="${name}">Remove</button>
                        </div>
                    </div>
                </div>
            `;
      }
    });
    html += "</div></div>";
    return html;
  }
  function getTurtleExpectations(activePets, UnifiedState3, logDebug2) {
    if (UnifiedState3?.data?.settings?.debugMode && logDebug2) {
      logDebug2("TURTLE", "Checking active pets:", {
        petsCount: activePets?.length || 0,
        pets: (activePets || []).map((p) => ({
          species: p?.petSpecies,
          hunger: p?.hunger,
          abilities: p?.abilities
        }))
      });
    }
    const turtles = (activePets || []).filter(
      (p) => p && p.petSpecies === "Turtle" && p.hunger > 0 && p.abilities?.some(
        (a) => a === "Plant Growth Boost II" || a === "PlantGrowthBoostII" || a === "Plant Growth Boost 2" || typeof a === "string" && a.toLowerCase().includes("plant") && a.toLowerCase().includes("growth") && (a.includes("II") || a.includes("2"))
      )
    );
    if (UnifiedState3?.data?.settings?.debugMode && logDebug2) {
      logDebug2("TURTLE", "Filtered turtles:", {
        turtleCount: turtles.length,
        turtles: turtles.map((t) => ({
          species: t.petSpecies,
          hunger: t.hunger,
          abilities: t.abilities,
          xp: t.xp,
          targetScale: t.targetScale
        }))
      });
    }
    let expectedMinutesRemoved = 0;
    turtles.forEach((p) => {
      const xpComponent = Math.min(Math.floor((p.xp || 0) / (100 * 3600) * 30), 30);
      const scaleComponent = Math.floor(((p.targetScale || 1) - 1) / (2.5 - 1) * 20 + 80) - 30;
      const base = xpComponent + scaleComponent;
      const minutesRemoved = base / 100 * 5 * 60 * (1 - Math.pow(1 - 0.27 * base / 100, 1 / 60));
      if (UnifiedState3?.data?.settings?.debugMode && logDebug2) {
        logDebug2("TURTLE", "Turtle calculation:", {
          xp: p.xp,
          targetScale: p.targetScale,
          xpComponent,
          scaleComponent,
          base,
          minutesRemoved
        });
      }
      expectedMinutesRemoved += minutesRemoved;
    });
    if (UnifiedState3?.data?.settings?.debugMode && logDebug2) {
      logDebug2("TURTLE", "Total expected minutes removed:", expectedMinutesRemoved);
    }
    return {
      expectedMinutesRemoved
    };
  }
  function estimateUntilLatestCrop(currentCrop, activePets, slotIndex, UnifiedState3, logError2) {
    try {
      if (!currentCrop || currentCrop.length === 0) return null;
      if (!activePets || activePets.length === 0) return null;
      const turtleExpectations = getTurtleExpectations(activePets, UnifiedState3, null);
      if (!turtleExpectations || turtleExpectations.expectedMinutesRemoved === 0) {
        return null;
      }
      const now = Date.now();
      let targetEndTime;
      if (slotIndex !== null && slotIndex >= 0 && slotIndex < currentCrop.length) {
        targetEndTime = currentCrop[slotIndex]?.endTime || 0;
      } else {
        targetEndTime = Math.max(...currentCrop.map((c) => c.endTime || 0));
      }
      if (targetEndTime <= now) return null;
      const remainingRealMinutes = (targetEndTime - now) / (1e3 * 60);
      const { expectedMinutesRemoved } = turtleExpectations;
      const effectiveRate = expectedMinutesRemoved + 1;
      const expectedRealMinutes = remainingRealMinutes / effectiveRate;
      const hours = Math.floor(expectedRealMinutes / 60);
      const minutes = Math.floor(expectedRealMinutes % 60);
      return `${hours}h ${minutes}m`;
    } catch (error) {
      if (logError2) {
        logError2("TURTLE", "ERROR in estimateUntilLatestCrop:", error);
      }
      return null;
    }
  }
  function getAbilityExpectations(activePets, abilityName, minutesPerBase = 5, odds = 0.27) {
    const pets = (activePets || []).filter((p) => p && p.hunger > 0 && p.abilities?.some((a) => a === abilityName));
    let expectedMinutesRemoved = 0;
    pets.forEach((p) => {
      const base = Math.min(Math.floor((p.xp || 0) / (100 * 3600) * 30), 30) + Math.floor(((p.targetScale || 1) - 1) / (2.5 - 1) * 20 + 80) - 30;
      expectedMinutesRemoved += base / 100 * minutesPerBase * 60 * (1 - Math.pow(1 - odds * base / 100, 1 / 60));
    });
    return {
      expectedMinutesRemoved
    };
  }
  function getEggExpectations(activePets) {
    return getAbilityExpectations(activePets, "EggGrowthBoostII", 10, 0.24);
  }
  function getGrowthExpectations(activePets) {
    return getAbilityExpectations(activePets, "PlantGrowthBoostII", 5, 0.27);
  }
  function initAutoFavorite({ UnifiedState: UnifiedState3, targetWindow: targetWindow3, productionLog: productionLog3 }) {
    let lastInventoryCount = 0;
    setInterval(() => {
      if (!UnifiedState3.data.settings.autoFavorite.enabled) {
        return;
      }
      const watchedSpecies = UnifiedState3.data.settings.autoFavorite.species || [];
      const watchedMutations = UnifiedState3.data.settings.autoFavorite.mutations || [];
      if (watchedSpecies.length === 0 && watchedMutations.length === 0) {
        return;
      }
      if (!targetWindow3.myData?.inventory?.items) {
        return;
      }
      const currentCount = targetWindow3.myData.inventory.items.length;
      if (currentCount > lastInventoryCount) {
        checkAndFavoriteNewItems(targetWindow3.myData.inventory, { UnifiedState: UnifiedState3, targetWindow: targetWindow3, productionLog: productionLog3 });
      }
      lastInventoryCount = currentCount;
    }, 2e3);
    productionLog3("\u{1F31F} [AUTO-FAVORITE] System initialized - monitoring inventory changes");
  }
  function checkAndFavoriteNewItems(inventory, { UnifiedState: UnifiedState3, targetWindow: targetWindow3, productionLog: productionLog3 }) {
    if (!inventory?.items) return;
    if (!UnifiedState3.data.settings.autoFavorite.petAbilities) {
      UnifiedState3.data.settings.autoFavorite.petAbilities = [];
    }
    if (!UnifiedState3.data.settings.autoFavorite.species.length && !UnifiedState3.data.settings.autoFavorite.mutations.length && !UnifiedState3.data.settings.autoFavorite.petAbilities.length)
      return;
    const favoritedIds = new Set(inventory.favoritedItemIds || []);
    const targetSpecies = new Set(UnifiedState3.data.settings.autoFavorite.species);
    const targetMutations = new Set(UnifiedState3.data.settings.autoFavorite.mutations);
    const targetPetAbilities = new Set(UnifiedState3.data.settings.autoFavorite.petAbilities);
    let cropCount = 0;
    let petCount = 0;
    for (const item of inventory.items) {
      if (favoritedIds.has(item.id)) continue;
      if (item.itemType === "Pet") {
        const petMutations = item.mutations || [];
        const hasGoldMutation = petMutations.includes("Gold");
        const hasRainbowMutation = petMutations.includes("Rainbow");
        const petAbilities = item.abilities || [];
        const hasGoldGranterAbility = petAbilities.some((a) => {
          const abilityStr = typeof a === "string" ? a : a?.type || a?.abilityType || "";
          return abilityStr.toLowerCase().includes("gold") && abilityStr.toLowerCase().includes("grant");
        });
        const hasRainbowGranterAbility = petAbilities.some((a) => {
          const abilityStr = typeof a === "string" ? a : a?.type || a?.abilityType || "";
          return abilityStr.toLowerCase().includes("rainbow") && abilityStr.toLowerCase().includes("grant");
        });
        const shouldFavorite = targetPetAbilities.has("Gold Granter") && (hasGoldMutation || hasGoldGranterAbility) || targetPetAbilities.has("Rainbow Granter") && (hasRainbowMutation || hasRainbowGranterAbility);
        if (shouldFavorite) {
          if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
            targetWindow3.MagicCircle_RoomConnection.sendMessage({
              scopePath: ["Room", "Quinoa"],
              type: "ToggleFavoriteItem",
              itemId: item.id
            });
            petCount++;
          }
        }
        continue;
      }
      if (item.itemType !== "Produce") continue;
      if (item.itemType === "Egg" || item.itemType === "Tool") continue;
      if (item.category === "Egg" || item.category === "Tool") continue;
      if (item.species && (item.species.includes("Pet") || item.species.includes("Egg"))) continue;
      const matchesSpecies = targetSpecies.has(item.species);
      const itemMutations = item.mutations || [];
      const matchesMutation = itemMutations.some((mut) => targetMutations.has(mut));
      if (matchesSpecies || matchesMutation) {
        if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
          targetWindow3.MagicCircle_RoomConnection.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: "ToggleFavoriteItem",
            itemId: item.id
          });
          cropCount++;
        }
      }
    }
    if (cropCount > 0) {
      productionLog3(`\u{1F31F} [AUTO-FAVORITE] Auto-favorited ${cropCount} new crops`);
    }
    if (petCount > 0) {
      productionLog3(`\u{1F31F} [AUTO-FAVORITE] Auto-favorited ${petCount} new pets`);
    }
  }
  function favoriteSpecies(speciesName, { targetWindow: targetWindow3, productionLog: productionLog3 }) {
    if (!targetWindow3.myData?.inventory?.items) {
      productionLog3("\u{1F31F} [AUTO-FAVORITE] No myData available yet - waiting for game to load");
      return;
    }
    const items = targetWindow3.myData.inventory.items;
    const favoritedIds = new Set(targetWindow3.myData.inventory.favoritedItemIds || []);
    let count = 0;
    for (const item of items) {
      if (item.itemType !== "Produce") continue;
      if (item.itemType === "Pet" || item.itemType === "Egg" || item.itemType === "Tool") continue;
      if (item.category === "Pet" || item.category === "Egg" || item.category === "Tool") continue;
      if (item.species && (item.species.includes("Pet") || item.species.includes("Egg"))) continue;
      if (item.species === speciesName && !favoritedIds.has(item.id)) {
        if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
          targetWindow3.MagicCircle_RoomConnection.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: "ToggleFavoriteItem",
            itemId: item.id
          });
          count++;
        }
      }
    }
    if (count > 0) {
      productionLog3(`\u2705 [AUTO-FAVORITE] Favorited ${count} ${speciesName} crops`);
    } else {
      productionLog3(`\u2139\uFE0F [AUTO-FAVORITE] No ${speciesName} crops to favorite (already favorited or none in inventory)`);
    }
  }
  function unfavoriteSpecies(speciesName, { productionLog: productionLog3 }) {
    productionLog3(
      `\u{1F512} [AUTO-FAVORITE] Checkbox unchecked for ${speciesName} - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
    );
  }
  function favoriteMutation(mutationName, { targetWindow: targetWindow3, productionLog: productionLog3 }) {
    if (!targetWindow3.myData?.inventory?.items) {
      productionLog3("\u{1F31F} [AUTO-FAVORITE] No myData available yet - waiting for game to load");
      return;
    }
    const items = targetWindow3.myData.inventory.items;
    const favoritedIds = new Set(targetWindow3.myData.inventory.favoritedItemIds || []);
    let count = 0;
    for (const item of items) {
      if (item.itemType !== "Produce") continue;
      if (item.itemType === "Pet" || item.itemType === "Egg" || item.itemType === "Tool") continue;
      if (item.category === "Pet" || item.category === "Egg" || item.category === "Tool") continue;
      if (item.species && (item.species.includes("Pet") || item.species.includes("Egg"))) continue;
      const itemMutations = item.mutations || [];
      if (itemMutations.includes(mutationName) && !favoritedIds.has(item.id)) {
        if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
          targetWindow3.MagicCircle_RoomConnection.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: "ToggleFavoriteItem",
            itemId: item.id
          });
          count++;
        }
      }
    }
    if (count > 0) {
      productionLog3(`\u2705 [AUTO-FAVORITE] Favorited ${count} crops with ${mutationName} mutation`);
    } else {
      productionLog3(
        `\u2139\uFE0F [AUTO-FAVORITE] No crops with ${mutationName} mutation to favorite (already favorited or none in inventory)`
      );
    }
  }
  function unfavoriteMutation(mutationName, { productionLog: productionLog3 }) {
    productionLog3(
      `\u{1F512} [AUTO-FAVORITE] Checkbox unchecked for ${mutationName} mutation - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
    );
  }
  function favoritePetAbility(abilityName, { targetWindow: targetWindow3, productionLog: productionLog3 }) {
    if (!targetWindow3.myData?.inventory?.items) {
      productionLog3("\u{1F31F} [AUTO-FAVORITE-PET] No myData available yet - waiting for game to load");
      return;
    }
    productionLog3(`\u{1F50D} [AUTO-FAVORITE-PET] Searching for pets with ${abilityName}...`);
    const items = targetWindow3.myData.inventory.items;
    const favoritedIds = new Set(targetWindow3.myData.inventory.favoritedItemIds || []);
    let count = 0;
    let petsChecked = 0;
    const firstPet = items.find((i) => i.itemType === "Pet");
    if (firstPet) {
      productionLog3("\u{1F43E} [AUTO-FAVORITE-PET-DEBUG] Sample pet structure:", {
        species: firstPet.petSpecies,
        mutations: firstPet.mutations,
        abilities: firstPet.abilities,
        hasAbilitiesArray: Array.isArray(firstPet.abilities),
        hasMutationsArray: Array.isArray(firstPet.mutations)
      });
    }
    for (const item of items) {
      if (item.itemType !== "Pet") continue;
      petsChecked++;
      if (favoritedIds.has(item.id)) continue;
      const petMutations = item.mutations || [];
      const hasGoldMutation = petMutations.includes("Gold");
      const hasRainbowMutation = petMutations.includes("Rainbow");
      const petAbilities = item.abilities || [];
      const hasGoldGranterAbility = petAbilities.some((a) => {
        const abilityStr = typeof a === "string" ? a : a?.type || a?.abilityType || "";
        return abilityStr.toLowerCase().includes("gold") && abilityStr.toLowerCase().includes("grant");
      });
      const hasRainbowGranterAbility = petAbilities.some((a) => {
        const abilityStr = typeof a === "string" ? a : a?.type || a?.abilityType || "";
        return abilityStr.toLowerCase().includes("rainbow") && abilityStr.toLowerCase().includes("grant");
      });
      const shouldFavorite = abilityName === "Gold Granter" && (hasGoldMutation || hasGoldGranterAbility) || abilityName === "Rainbow Granter" && (hasRainbowMutation || hasRainbowGranterAbility);
      if (shouldFavorite) {
        productionLog3(
          `\u2728 [AUTO-FAVORITE-PET] Found matching pet: ${item.petSpecies} (${item.id}) - mutations: [${petMutations.join(", ")}], abilities: ${petAbilities.length}`
        );
        if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
          targetWindow3.MagicCircle_RoomConnection.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: "ToggleFavoriteItem",
            itemId: item.id
          });
          count++;
        }
      }
    }
    productionLog3(`\u2705 [AUTO-FAVORITE-PET] Scanned ${petsChecked} pets, favorited ${count} with ${abilityName}`);
  }
  function unfavoritePetAbility(abilityName, { productionLog: productionLog3 }) {
    productionLog3(
      `\u{1F512} [AUTO-FAVORITE-PET] Checkbox unchecked for ${abilityName} - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
    );
  }
  function playPetNotificationSound(volume, { playCustomOrDefaultSound: playCustomOrDefaultSound2, playGeneralNotificationSound: playGeneralNotificationSound2 }) {
    playCustomOrDefaultSound2("pet", playGeneralNotificationSound2, volume);
  }
  function placePetPreset(presetName, {
    UnifiedState: UnifiedState3,
    targetWindow: targetWindow3,
    productionLog: productionLog3,
    productionWarn: productionWarn3,
    safeSendMessage: safeSendMessage2,
    updateActivePetsFromRoomState: updateActivePetsFromRoomState2,
    updateTabContent,
    updatePureOverlayContent: updatePureOverlayContent2,
    refreshSeparateWindowPopouts: refreshSeparateWindowPopouts2
  }) {
    const preset = UnifiedState3.data.petPresets[presetName];
    if (!preset) {
      productionWarn3(`[PETS] Preset "${presetName}" not found`);
      return;
    }
    const maxSlots = 3;
    let delay = 0;
    for (let slotIndex = 0; slotIndex < maxSlots; slotIndex++) {
      const desiredPet = preset[slotIndex];
      ((currentDelay, slot) => {
        setTimeout(() => {
          const currentPets = UnifiedState3.atoms.activePets || targetWindow3.activePets || [];
          const currentPet = currentPets[slot];
          if (currentPet && desiredPet) {
            if (currentPet.id === desiredPet.id) {
              if (UnifiedState3.data.settings?.debugMode) {
                productionLog3(`[PET-SWAP] Slot ${slot + 1}: Already equipped (${currentPet.id}), skipping`);
              }
              return;
            }
            if (UnifiedState3.data.settings?.debugMode) {
              productionLog3(`[PET-SWAP] Slot ${slot + 1}: Swapping ${currentPet.id} \u2192 ${desiredPet.id}`);
            }
            safeSendMessage2({
              scopePath: ["Room", "Quinoa"],
              type: "SwapPet",
              petSlotId: currentPet.id,
              petInventoryId: desiredPet.id
            });
          } else if (!currentPet && desiredPet) {
            if (UnifiedState3.data.settings?.debugMode) {
              productionLog3(`[PET-SWAP] Slot ${slot + 1}: Placing ${desiredPet.id} (empty slot)`);
            }
            safeSendMessage2({
              scopePath: ["Room", "Quinoa"],
              type: "PlacePet",
              itemId: desiredPet.id,
              position: { x: 17 + slot * 2, y: 13 },
              localTileIndex: 64,
              tileType: "Boardwalk"
            });
          } else if (currentPet && !desiredPet) {
            if (UnifiedState3.data.settings?.debugMode) {
              productionLog3(`[PET-SWAP] Slot ${slot + 1}: Storing ${currentPet.id} (no preset pet)`);
            }
            safeSendMessage2({
              scopePath: ["Room", "Quinoa"],
              type: "StorePet",
              itemId: currentPet.id
            });
          }
        }, currentDelay);
      })(delay, slotIndex);
      delay += 200;
    }
    const refreshAllPetDisplays = () => {
      updateActivePetsFromRoomState2();
      if (UnifiedState3.activeTab === "pets") {
        updateTabContent();
      }
      UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
        if (overlay && document.contains(overlay) && tabName === "pets") {
          if (overlay.className.includes("mga-overlay-content-only")) {
            updatePureOverlayContent2(overlay, tabName);
          }
        }
      });
      refreshSeparateWindowPopouts2("pets");
    };
    setTimeout(
      () => {
        refreshAllPetDisplays();
      },
      maxSlots * 200 + 500
    );
    setTimeout(() => {
      refreshAllPetDisplays();
    }, 2e3);
  }
  function loadPetPreset(preset, { UnifiedState: UnifiedState3, targetWindow: targetWindow3, productionLog: productionLog3, productionWarn: productionWarn3, safeSendMessage: safeSendMessage2 }) {
    if (!preset || !Array.isArray(preset)) {
      productionWarn3("[PETS] Invalid preset data");
      return;
    }
    productionLog3("[PETS] Using SwapPet for atomic swapping");
    preset.forEach((presetPet, i) => {
      setTimeout(() => {
        const currentPets = UnifiedState3.atoms.activePets || targetWindow3.activePets || [];
        const currentPet = currentPets[i];
        if (currentPet) {
          if (currentPet.id === presetPet.id) {
            if (UnifiedState3.data.settings?.debugMode) {
              productionLog3(`[PET-SWAP] Slot ${i + 1}: Already equipped (${currentPet.id}), skipping`);
            }
            return;
          }
          if (UnifiedState3.data.settings?.debugMode) {
            productionLog3(`[PET-SWAP] Slot ${i + 1}: Swapping ${currentPet.id} \u2192 ${presetPet.id}`);
          }
          safeSendMessage2({
            scopePath: ["Room", "Quinoa"],
            type: "SwapPet",
            petSlotId: currentPet.id,
            petInventoryId: presetPet.id
          });
        } else {
          if (UnifiedState3.data.settings?.debugMode) {
            productionLog3(`[PET-SWAP] Slot ${i + 1}: Placing ${presetPet.id} (empty slot)`);
          }
          safeSendMessage2({
            scopePath: ["Room", "Quinoa"],
            type: "PlacePet",
            itemId: presetPet.id,
            position: { x: 17 + i * 2, y: 13 },
            localTileIndex: 64,
            tileType: "Boardwalk"
          });
        }
      }, i * 200);
    });
    productionLog3(`\u2705 [PETS] Loaded pet preset (${preset.length} pets)`);
  }
  function getAllUniquePets({ UnifiedState: UnifiedState3 }) {
    const pets = /* @__PURE__ */ new Set();
    UnifiedState3.data.petAbilityLogs.forEach((log) => {
      if (log.petName && log.petName !== "Test Pet") {
        pets.add(log.petName);
      }
    });
    return Array.from(pets).sort();
  }
  function populatePetSpeciesList({ UnifiedState: UnifiedState3, targetDocument: targetDocument2, MGA_saveJSON: MGA_saveJSON2, updateAllLogVisibility: updateAllLogVisibility3 }) {
    const container = targetDocument2.getElementById("pet-species-list");
    if (!container) return;
    const pets = getAllUniquePets({ UnifiedState: UnifiedState3 });
    container.innerHTML = "";
    if (pets.length === 0) {
      container.innerHTML = '<div style="color: #888; text-align: center;">No pet species found in logs</div>';
      return;
    }
    pets.forEach((pet) => {
      const label = targetDocument2.createElement("label");
      label.className = "mga-checkbox-group";
      label.style.display = "block";
      label.style.marginBottom = "4px";
      const checkbox = targetDocument2.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "mga-checkbox";
      checkbox.checked = UnifiedState3.data.petFilters.selectedPets[pet] || false;
      checkbox.addEventListener("change", (e) => {
        UnifiedState3.data.petFilters.selectedPets[pet] = e.target.checked;
        MGA_saveJSON2("MGA_petFilters", UnifiedState3.data.petFilters);
        updateAllLogVisibility3();
      });
      const span = targetDocument2.createElement("span");
      span.className = "mga-label";
      span.textContent = ` ${pet}`;
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }
  function shouldLogAbility(abilityType, petName, { UnifiedState: UnifiedState3, categorizeAbilityToFilterKey: categorizeAbilityToFilterKey3 }) {
    if (abilityType && (abilityType.includes("ProduceMutationBoost") || abilityType.includes("PetMutationBoost"))) {
      return false;
    }
    const mode = UnifiedState3.data.filterMode || "categories";
    if (mode === "custom") {
      return UnifiedState3.data.customMode.selectedAbilities[abilityType] || false;
    }
    if (mode === "byPet") {
      if (!petName) return false;
      return UnifiedState3.data.petFilters.selectedPets[petName] || false;
    }
    const category = categorizeAbilityToFilterKey3(abilityType, { UnifiedState: UnifiedState3 });
    return UnifiedState3.data.abilityFilters[category] || false;
  }
  function categorizeAbilityToFilterKey(abilityType, { MGA_AbilityCache: MGA_AbilityCache2 }) {
    if (MGA_AbilityCache2.categories.has(abilityType)) {
      return MGA_AbilityCache2.categories.get(abilityType);
    }
    const cleanType = (abilityType || "").toLowerCase();
    let category = "other";
    if (cleanType.includes("xp") && cleanType.includes("boost")) category = "xpBoost";
    else if (cleanType.includes("hatch") && cleanType.includes("xp")) category = "xpBoost";
    else if (cleanType.includes("crop") && (cleanType.includes("size") || cleanType.includes("scale")))
      category = "cropSizeBoost";
    else if (cleanType.includes("sell") && cleanType.includes("boost")) category = "selling";
    else if (cleanType.includes("refund")) category = "selling";
    else if (cleanType.includes("double") && cleanType.includes("harvest")) category = "harvesting";
    else if (cleanType.includes("growth") && cleanType.includes("boost")) category = "growthSpeed";
    else if (cleanType.includes("rainbow") || cleanType.includes("gold")) category = "specialMutations";
    MGA_AbilityCache2.categories.set(abilityType, category);
    return category;
  }
  function monitorPetAbilities({
    UnifiedState: UnifiedState3,
    targetWindow: targetWindow3,
    productionLog: productionLog3,
    MGA_debouncedSave,
    MGA_manageLogMemory: MGA_manageLogMemory2,
    formatTimestamp: formatTimestamp3,
    normalizeAbilityName: normalizeAbilityName4,
    getGardenCropIfUnique: getGardenCropIfUnique2,
    playAbilityNotificationSound: playAbilityNotificationSound2,
    showNotificationToast: showNotificationToast2,
    updateAllAbilityLogDisplays: updateAllAbilityLogDisplays3,
    updateTabContent,
    pendingAbilityUpdates
  }) {
    if (!UnifiedState3.atoms.petAbility || !UnifiedState3.atoms.activePets) return;
    let hasNewAbility = false;
    UnifiedState3.atoms.activePets.forEach((pet, index) => {
      if (!pet || !pet.id) return;
      const abilityData = UnifiedState3.atoms.petAbility[pet.id];
      if (!abilityData || !abilityData.lastAbilityTrigger) return;
      const trigger = abilityData.lastAbilityTrigger;
      const currentTimestamp = trigger.performedAt;
      if (!currentTimestamp || pet.hunger === 0) {
        productionLog3(`\u{1F6AB} [ABILITY-SKIP] Pet ${pet.petSpecies} unfed (hunger: ${pet.hunger}) - skipping ability log`);
        return;
      }
      if (!trigger.abilityId || trigger.abilityId === "Unknown" || trigger.abilityId === "") {
        productionLog3(`\u{1F6AB} [ABILITY-SKIP] Invalid ability ID for ${pet.petSpecies} - likely unfed pet notification`);
        return;
      }
      if (!UnifiedState3.data.lastAbilityTimestamps) {
        UnifiedState3.data.lastAbilityTimestamps = {};
      }
      const lastKnown = UnifiedState3.data.lastAbilityTimestamps[pet.id];
      if (lastKnown === currentTimestamp) {
        return;
      }
      if (lastKnown && Math.abs(currentTimestamp - lastKnown) < 3e3) {
        if (UnifiedState3.data.settings?.debugMode) {
          productionLog3(
            `\u{1F6AB} [ABILITY-SKIP] ${pet.petSpecies} - Timestamp too close to last (${Math.abs(currentTimestamp - lastKnown)}ms)`
          );
        }
        return;
      }
      const isDuplicate = UnifiedState3.data.petAbilityLogs.slice(0, 10).some((log) => log.timestamp === currentTimestamp && log.petName && log.petName.includes(pet.petSpecies));
      if (isDuplicate) {
        if (UnifiedState3.data.settings?.debugMode) {
          productionLog3(`\u{1F6AB} [ABILITY-SKIP] ${pet.petSpecies} - Already in recent logs (duplicate prevention)`);
        }
        return;
      }
      UnifiedState3.data.lastAbilityTimestamps[pet.id] = currentTimestamp;
      hasNewAbility = true;
      MGA_debouncedSave("MGA_lastAbilityTimestamps", UnifiedState3.data.lastAbilityTimestamps);
      const enrichedData = trigger.data ? { ...trigger.data } : {};
      const abilityId = trigger.abilityId || "";
      if (abilityId.includes("Granter") && !enrichedData.cropName) {
        const currentCrop = targetWindow3.currentCrop || UnifiedState3.atoms.currentCrop;
        if (currentCrop && currentCrop[0]?.species) {
          enrichedData.cropName = currentCrop[0].species;
        } else {
          const uniqueCrop = getGardenCropIfUnique2();
          if (uniqueCrop) {
            enrichedData.cropName = uniqueCrop;
          }
        }
      }
      let displayName = pet.petSpecies || `Pet ${index + 1}`;
      if (pet.name && pet.name !== pet.petSpecies) {
        displayName = `${pet.name} (${pet.petSpecies || "Pet"})`;
      }
      const rawAbilityType = trigger.abilityId || "Unknown Ability";
      const normalizedAbilityType = normalizeAbilityName4(rawAbilityType);
      const abilityLog = {
        petName: displayName,
        abilityType: normalizedAbilityType,
        timestamp: currentTimestamp,
        timeString: formatTimestamp3(currentTimestamp),
        data: Object.keys(enrichedData).length > 0 ? enrichedData : null
      };
      UnifiedState3.data.petAbilityLogs.unshift(abilityLog);
      UnifiedState3.data.petAbilityLogs = MGA_manageLogMemory2(UnifiedState3.data.petAbilityLogs);
      const clearSession = localStorage.getItem("MGA_logs_clear_session");
      if (!clearSession || Date.now() - parseInt(clearSession, 10) > 864e5) {
        MGA_debouncedSave("MGA_petAbilityLogs", UnifiedState3.data.petAbilityLogs);
      }
      if (UnifiedState3.data.settings.notifications.abilityNotificationsEnabled) {
        const abilityType = trigger.abilityId || "";
        if (abilityType && (abilityType.includes("ProduceMutationBoost") || abilityType.includes("PetMutationBoost"))) {
          return;
        }
        const watchedAbilities = UnifiedState3.data.settings.notifications.watchedAbilities || [];
        let shouldNotify = false;
        if (watchedAbilities.length === 0) {
          shouldNotify = true;
        } else if (watchedAbilities.includes("__NONE__")) {
          shouldNotify = false;
        } else {
          shouldNotify = watchedAbilities.includes(abilityType);
        }
        if (shouldNotify) {
          const displayAbilityName = normalizeAbilityName4(abilityType);
          productionLog3(`\u{1F3AF} [ABILITY-NOTIFY] ${abilityLog.petName} triggered ${displayAbilityName}`);
          const abilityVolume = UnifiedState3.data.settings.notifications.abilityNotificationVolume || 0.2;
          playAbilityNotificationSound2(abilityVolume);
          showNotificationToast2(`\u2728 ${abilityLog.petName}: ${displayAbilityName}`, "success");
        }
      }
    });
    if (hasNewAbility && document.visibilityState === "visible") {
      if (!pendingAbilityUpdates.value) {
        pendingAbilityUpdates.value = true;
        setTimeout(() => {
          requestAnimationFrame(() => {
            updateAllAbilityLogDisplays3();
            if (UnifiedState3.activeTab === "abilities") {
              updateTabContent();
            }
            pendingAbilityUpdates.value = false;
          });
        }, 500);
      }
    }
  }
  function getAllUniqueAbilities({ UnifiedState: UnifiedState3 }) {
    const abilities = /* @__PURE__ */ new Set();
    UnifiedState3.data.petAbilityLogs.forEach((log) => {
      if (log.abilityType) {
        abilities.add(log.abilityType);
      }
    });
    return Array.from(abilities).sort();
  }
  function populateIndividualAbilities({
    UnifiedState: UnifiedState3,
    targetDocument: targetDocument2,
    MGA_saveJSON: MGA_saveJSON2,
    normalizeAbilityName: normalizeAbilityName4,
    updateAllLogVisibility: updateAllLogVisibility3
  }) {
    const container = targetDocument2.getElementById("individual-abilities-list");
    if (!container) return;
    const abilities = getAllUniqueAbilities({ UnifiedState: UnifiedState3 });
    container.innerHTML = "";
    if (abilities.length === 0) {
      container.innerHTML = '<div style="color: #888; text-align: center;">No individual abilities found in logs</div>';
      return;
    }
    abilities.forEach((ability) => {
      const label = targetDocument2.createElement("label");
      label.className = "mga-checkbox-group";
      label.style.display = "block";
      label.style.marginBottom = "4px";
      const checkbox = targetDocument2.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "mga-checkbox";
      checkbox.checked = UnifiedState3.data.customMode.selectedAbilities[ability] || false;
      checkbox.addEventListener("change", (e) => {
        UnifiedState3.data.customMode.selectedAbilities[ability] = e.target.checked;
        MGA_saveJSON2("MGA_customMode", UnifiedState3.data.customMode);
        updateAllLogVisibility3();
      });
      const span = targetDocument2.createElement("span");
      span.className = "mga-label";
      span.textContent = ` ${normalizeAbilityName4(ability)}`;
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }
  function selectAllFilters(mode, { UnifiedState: UnifiedState3, targetDocument: targetDocument2, MGA_saveJSON: MGA_saveJSON2, getAllUniquePets: getAllUniquePets3, populatePetSpeciesList: populatePetSpeciesList3, updateAllLogVisibility: updateAllLogVisibility3 }) {
    if (mode === "categories") {
      Object.keys(UnifiedState3.data.abilityFilters).forEach((key) => {
        UnifiedState3.data.abilityFilters[key] = true;
        const checkbox = targetDocument2.querySelector(`[data-filter="${key}"]`);
        if (checkbox) checkbox.checked = true;
      });
      MGA_saveJSON2("MGA_abilityFilters", UnifiedState3.data.abilityFilters);
    } else if (mode === "byPet") {
      const pets = getAllUniquePets3({ UnifiedState: UnifiedState3 });
      pets.forEach((pet) => {
        UnifiedState3.data.petFilters.selectedPets[pet] = true;
      });
      MGA_saveJSON2("MGA_petFilters", UnifiedState3.data.petFilters);
      populatePetSpeciesList3({ UnifiedState: UnifiedState3, targetDocument: targetDocument2, MGA_saveJSON: MGA_saveJSON2, getAllUniquePets: getAllUniquePets3, updateAllLogVisibility: updateAllLogVisibility3 });
    } else if (mode === "custom") {
      const abilities = getAllUniqueAbilities({ UnifiedState: UnifiedState3 });
      abilities.forEach((ability) => {
        UnifiedState3.data.customMode.selectedAbilities[ability] = true;
      });
      MGA_saveJSON2("MGA_customMode", UnifiedState3.data.customMode);
      populateIndividualAbilities({ UnifiedState: UnifiedState3, targetDocument: targetDocument2, MGA_saveJSON: MGA_saveJSON2, updateAllLogVisibility: updateAllLogVisibility3 });
    }
    updateAllLogVisibility3();
  }
  function selectNoneFilters(mode, {
    UnifiedState: UnifiedState3,
    targetDocument: targetDocument2,
    MGA_saveJSON: MGA_saveJSON2,
    populatePetSpeciesList: populatePetSpeciesList3,
    populateIndividualAbilities: populateIndividualAbilities3,
    updateAllLogVisibility: updateAllLogVisibility3
  }) {
    if (mode === "categories") {
      Object.keys(UnifiedState3.data.abilityFilters).forEach((key) => {
        UnifiedState3.data.abilityFilters[key] = false;
        const checkbox = targetDocument2.querySelector(`[data-filter="${key}"]`);
        if (checkbox) checkbox.checked = false;
      });
      MGA_saveJSON2("MGA_abilityFilters", UnifiedState3.data.abilityFilters);
    } else if (mode === "byPet") {
      UnifiedState3.data.petFilters.selectedPets = {};
      MGA_saveJSON2("MGA_petFilters", UnifiedState3.data.petFilters);
      populatePetSpeciesList3({ UnifiedState: UnifiedState3, targetDocument: targetDocument2, MGA_saveJSON: MGA_saveJSON2, updateAllLogVisibility: updateAllLogVisibility3 });
    } else if (mode === "custom") {
      UnifiedState3.data.customMode.selectedAbilities = {};
      MGA_saveJSON2("MGA_customMode", UnifiedState3.data.customMode);
      populateIndividualAbilities3({ UnifiedState: UnifiedState3, targetDocument: targetDocument2, MGA_saveJSON: MGA_saveJSON2, updateAllLogVisibility: updateAllLogVisibility3 });
    }
    updateAllLogVisibility3();
  }
  function exportAbilityLogs({ MGA_getAllLogs: MGA_getAllLogs2, productionWarn: productionWarn3, normalizeAbilityName: normalizeAbilityName4, targetDocument: targetDocument2 }) {
    const allLogs = MGA_getAllLogs2();
    if (!allLogs.length) {
      productionWarn3("\u26A0\uFE0F No logs to export!");
      return;
    }
    const headers = "Date,Time,Pet Name,Ability Type,Details\r\n";
    const csvContent = allLogs.map((log) => {
      const date = new Date(log.timestamp);
      return [
        date.toLocaleDateString(),
        date.toLocaleTimeString(),
        log.petName,
        normalizeAbilityName4(log.abilityType),
        JSON.stringify(log.data || "")
      ].map((field) => `"${String(field).replace(/"/g, '""')}"`).join(",");
    }).join("\r\n");
    const blob = new Blob([headers + csvContent], { type: "text/csv;charset=utf-8;" });
    const link = targetDocument2.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `MagicGarden_AbilityLogs_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`;
    link.click();
  }
  function loadPresetByNumber(number, { UnifiedState: UnifiedState3, loadPetPreset: loadPetPreset2, productionLog: productionLog3 }) {
    const presets = Object.keys(UnifiedState3.data.petPresets);
    if (presets[number - 1]) {
      const presetName = presets[number - 1];
      const preset = UnifiedState3.data.petPresets[presetName];
      loadPetPreset2(preset, { UnifiedState: UnifiedState3, productionLog: productionLog3 });
      productionLog3(`\u{1F43E} Loaded preset ${number}: ${presetName}`);
    }
  }
  function normalizeAbilityName2(name, { UnifiedState: UnifiedState3, logDebug: logDebug2 } = {}) {
    if (!name || typeof name !== "string") return name;
    const normalized = name.replace(/([a-z])III$/i, "$1 III").replace(/([a-z])II$/i, "$1 II").replace(/([a-z])I$/i, "$1 I").replace(/produce\s*scale\s*boost/gi, "Crop Size Boost").trim();
    if (normalized !== name && UnifiedState3?.data?.settings?.debugMode && logDebug2) {
      logDebug2("ABILITY-LOGS", `\u{1F4DD} Normalized ability name: "${name}" \u2192 "${normalized}"`);
    }
    return normalized;
  }
  function formatTimestamp(timestamp, { UnifiedState: UnifiedState3, MGA_AbilityCache: MGA_AbilityCache2 }) {
    const cacheKey = `${timestamp}_${UnifiedState3.data.settings.detailedTimestamps}`;
    if (MGA_AbilityCache2.timestamps.has(cacheKey)) {
      return MGA_AbilityCache2.timestamps.get(cacheKey);
    }
    const date = new Date(timestamp);
    let formatted;
    if (UnifiedState3.data.settings.detailedTimestamps) {
      formatted = date.toLocaleTimeString(void 0, {
        hour12: false,
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    } else {
      formatted = date.toLocaleTimeString(void 0, {
        hour: "numeric",
        minute: "2-digit"
      });
    }
    MGA_AbilityCache2.timestamps.set(cacheKey, formatted);
    return formatted;
  }
  function getGardenCropIfUnique(targetWindow3) {
    const tileObjects = targetWindow3.gardenInfo?.garden?.tileObjects;
    if (!tileObjects) return null;
    const speciesSet = /* @__PURE__ */ new Set();
    const tiles = Object.values(tileObjects);
    tiles.forEach((tile) => {
      if (tile?.species && tile.objectType === "plant") {
        speciesSet.add(tile.species);
      }
    });
    if (speciesSet.size === 1) {
      return Array.from(speciesSet)[0];
    }
    return null;
  }
  var KNOWN_ABILITY_TYPES2 = [
    // XP Boosts
    "XP Boost I",
    "XP Boost II",
    "XP Boost III",
    "Hatch XP Boost I",
    "Hatch XP Boost II",
    // Crop Size Boosts
    "Crop Size Boost I",
    "Crop Size Boost II",
    // Selling
    "Sell Boost I",
    "Sell Boost II",
    "Sell Boost III",
    "Coin Finder I",
    "Coin Finder II",
    // Harvesting
    "Harvesting",
    "Auto Harvest",
    // Growth Speed
    "Plant Growth Boost I",
    "Plant Growth Boost II",
    "Plant Growth Boost III",
    "Egg Growth Boost I",
    "Egg Growth Boost II",
    // Seeds
    "Seed Finder I",
    "Seed Finder II",
    "Special Mutations",
    // Other
    "Hunger Boost I",
    "Hunger Boost II",
    "Max Strength Boost I",
    "Max Strength Boost II"
  ];
  function isKnownAbilityType2(abilityType) {
    if (!abilityType) return false;
    return KNOWN_ABILITY_TYPES2.includes(abilityType);
  }
  function initAbilityCache({ targetWindow: targetWindow3 }) {
    const cache = {
      categories: /* @__PURE__ */ new Map(),
      timestamps: /* @__PURE__ */ new Map(),
      normalizedNames: /* @__PURE__ */ new Map(),
      lastTimestampUpdate: 0
    };
    setInterval(() => {
      cache.timestamps.clear();
      cache.lastTimestampUpdate = Date.now();
    }, 6e4);
    return cache;
  }
  function MGA_manageLogMemory(logs, { MGA_MemoryConfig, MGA_loadJSON: MGA_loadJSON2, MGA_debouncedSave, productionLog: productionLog3 }) {
    if (!Array.isArray(logs) || logs.length <= MGA_MemoryConfig.maxLogsInMemory) {
      return logs;
    }
    productionLog3(
      `\u{1F9E0} [MEMORY] Managing log memory: ${logs.length} logs, keeping ${MGA_MemoryConfig.maxLogsInMemory} in memory`
    );
    const recentLogs = logs.slice(0, MGA_MemoryConfig.maxLogsInMemory);
    const archivedLogs = logs.slice(MGA_MemoryConfig.maxLogsInMemory);
    if (archivedLogs.length > 0) {
      const existingArchive = MGA_loadJSON2("MGA_petAbilityLogs_archive", []);
      const combinedArchive = [...archivedLogs, ...existingArchive].slice(0, MGA_MemoryConfig.maxLogsInStorage);
      MGA_debouncedSave("MGA_petAbilityLogs_archive", combinedArchive);
      productionLog3(`\u{1F4E6} [MEMORY] Archived ${archivedLogs.length} logs to storage`);
    }
    return recentLogs;
  }
  function MGA_getAllLogs({ UnifiedState: UnifiedState3, MGA_loadJSON: MGA_loadJSON2, productionLog: productionLog3 }) {
    const memoryLogs = UnifiedState3.data?.petAbilityLogs || [];
    const archivedLogs = MGA_loadJSON2("MGA_petAbilityLogs_archive", []);
    const allLogs = [...memoryLogs, ...archivedLogs];
    allLogs.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
    productionLog3(
      `\u{1F4DC} [MEMORY] Retrieved ${memoryLogs.length} memory logs + ${archivedLogs.length} archived logs = ${allLogs.length} total`
    );
    return allLogs;
  }
  function categorizeAbility(abilityType) {
    const cleanType = (abilityType || "").toLowerCase();
    if (cleanType.includes("xp") && cleanType.includes("boost")) return "xp-boost";
    if (cleanType.includes("hatch") && cleanType.includes("xp")) return "xp-boost";
    if (cleanType.includes("crop") && (cleanType.includes("size") || cleanType.includes("scale")))
      return "crop-size-boost";
    if (cleanType.includes("sell") && cleanType.includes("boost")) return "selling";
    if (cleanType.includes("refund")) return "selling";
    if (cleanType.includes("double") && cleanType.includes("harvest")) return "harvesting";
    if (cleanType.includes("growth") && cleanType.includes("boost")) return "growth-speed";
    if (cleanType.includes("plant") && cleanType.includes("growth")) return "growth-speed";
    if (cleanType.includes("egg") && cleanType.includes("growth")) return "growth-speed";
    if (cleanType.includes("rainbow") || cleanType.includes("gold")) return "special-mutations";
    return "other";
  }
  function formatLogData(data) {
    if (!data || typeof data !== "object") return "";
    const formatted = Object.entries(data).filter(([key, value]) => value !== null && value !== void 0).map(([key, value]) => `${key}: ${value}`).join(", ");
    return formatted.length > 60 ? formatted.substring(0, 60) + "..." : formatted;
  }
  function formatRelativeTime(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    if (diff < 6e4) {
      const seconds = Math.floor(diff / 1e3);
      return `${seconds}s ago`;
    }
    if (diff < 36e5) {
      const minutes = Math.floor(diff / 6e4);
      return `${minutes}m ago`;
    }
    if (diff < 864e5) {
      const hours = Math.floor(diff / 36e5);
      return `${hours}h ago`;
    }
    return new Date(timestamp).toLocaleDateString();
  }
  function updateAbilityLogDisplay(context, {
    MGA_getAllLogs: MGA_getAllLogs2,
    shouldLogAbility: shouldLogAbility3,
    categorizeAbilityToFilterKey: categorizeAbilityToFilterKey3,
    formatTimestamp: formatTimestamp3,
    normalizeAbilityName: normalizeAbilityName4,
    formatLogData: formatLogData3,
    UnifiedState: UnifiedState3,
    targetDocument: targetDocument2,
    debugLog: debugLog3,
    CONFIG: CONFIG2
  }) {
    const abilityLogs = context.querySelector("#ability-logs");
    if (!abilityLogs) {
      debugLog3("ABILITY_LOGS", "No ability logs element found in context", {
        isDocument: context === document,
        className: context.className || "unknown"
      });
      return;
    }
    const isOverlay = context.classList?.contains("mga-overlay-content-only");
    const isDragInProgress = context.getAttribute?.("data-dragging") === "true";
    if (isOverlay && isDragInProgress) {
      debugLog3("ABILITY_LOGS", "Skipping content update during drag operation", {
        overlayId: context.id
      });
      return;
    }
    const logs = MGA_getAllLogs2({ UnifiedState: UnifiedState3, MGA_loadJSON: window.MGA_loadJSON, productionLog: window.productionLog });
    const filteredLogs = logs.filter(
      (log) => shouldLogAbility3(log.abilityType, log.petName, { UnifiedState: UnifiedState3, categorizeAbilityToFilterKey: categorizeAbilityToFilterKey3 })
    );
    debugLog3("ABILITY_LOGS", "Updating ability log display", {
      totalLogs: logs.length,
      filteredLogs: filteredLogs.length,
      filterMode: UnifiedState3.data.filterMode
    });
    if (CONFIG2?.DEBUG?.FLAGS?.FIX_VALIDATION) {
      console.log("[FIX_ABILITY_LOGS] Update called:", {
        totalLogs: logs.length,
        filteredLogs: filteredLogs.length,
        filterMode: UnifiedState3.data.filterMode,
        elementFound: !!abilityLogs,
        contextType: context === document ? "document" : "overlay"
      });
    }
    const htmlParts = [];
    const categoryData = {
      xpBoost: { icon: "\u{1F4AB}", color: "#4a9eff", label: "XP Boost" },
      cropSizeBoost: { icon: "\u{1F4C8}", color: "#10b981", label: "Crop Size" },
      selling: { icon: "\u{1F4B0}", color: "#f59e0b", label: "Selling" },
      harvesting: { icon: "\u{1F33E}", color: "#84cc16", label: "Harvesting" },
      growthSpeed: { icon: "\u{1F422}", color: "#06b6d4", label: "Growth Speed" },
      specialMutations: { icon: "\u{1F308}\u2728", color: "#8b5cf6", label: "Special" },
      other: { icon: "\u{1F527}", color: "#6b7280", label: "Other" }
    };
    filteredLogs.forEach((log) => {
      const category = categorizeAbilityToFilterKey3(log.abilityType, { MGA_AbilityCache: window.MGA_AbilityCache });
      const catData = categoryData[category] || categoryData.other;
      const formattedTime = formatTimestamp3(log.timestamp, { UnifiedState: UnifiedState3, MGA_AbilityCache: window.MGA_AbilityCache });
      const isRecent = Date.now() - log.timestamp < 1e4;
      const displayAbilityName = normalizeAbilityName4(log.abilityType, { UnifiedState: UnifiedState3 });
      htmlParts.push(`
      <div class="mga-log-item ${isRecent ? "mga-log-recent" : ""}" data-category="${category}" data-ability-type="${log.abilityType}" data-pet-name="${log.petName}" style="--category-color: ${catData.color}">
        <div class="mga-log-header">
          <span class="mga-log-icon">${catData.icon}</span>
          <span class="mga-log-meta">
            <span class="mga-log-pet" style="color: ${catData.color}; font-weight: 600;">${log.petName}</span>
            <span class="mga-log-time">${formattedTime}</span>
          </span>
        </div>
        <div class="mga-log-ability">${displayAbilityName}</div>
        ${log.data && Object.keys(log.data).length > 0 ? `<div class="mga-log-details">${formatLogData3(log.data)}</div>` : ""}
      </div>
    `);
    });
    const fragment = targetDocument2.createDocumentFragment();
    const tempContainer = targetDocument2.createElement("div");
    if (htmlParts.length === 0) {
      const mode = UnifiedState3.data.filterMode || "categories";
      const modeText = mode === "categories" ? "category filters" : mode === "byPet" ? "pet filters" : "custom filters";
      tempContainer.innerHTML = `<div class="mga-log-empty">
      <div style="color: #888; text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 8px;">\u{1F4CB}</div>
        <div>No abilities match the current ${modeText}</div>
        <div style="font-size: 11px; margin-top: 4px; opacity: 0.7;">Try adjusting your filter settings</div>
      </div>
    </div>`;
    } else {
      tempContainer.innerHTML = htmlParts.join("");
      setTimeout(() => {
        if (abilityLogs.scrollHeight > abilityLogs.clientHeight) {
          abilityLogs.scrollTop = 0;
        }
      }, 100);
    }
    while (tempContainer.firstChild) {
      fragment.appendChild(tempContainer.firstChild);
    }
    abilityLogs.innerHTML = "";
    abilityLogs.appendChild(fragment);
    if (!context.querySelector("#mga-log-styles")) {
      const logStyles = targetDocument2.createElement("style");
      logStyles.id = "mga-log-styles";
      logStyles.textContent = `
      .mga-log-item { margin: 4px 0; padding: 8px; border-radius: 4px; background: rgba(255, 255, 255, 0.02);
        border-left: 2px solid var(--category-color, #6b7280); transition: all 0.2s ease; font-size: 11px; line-height: 1.3; }
      .mga-log-item:hover { background: rgba(255, 255, 255, 0.05); transform: translateX(2px); }
      .mga-log-recent { background: rgba(74, 158, 255, 0.30); border-color: #4a9eff;
        box-shadow: 0 0 8px rgba(74, 158, 255, 0.3); animation: mgaLogPulse 2s ease-out; }
      @keyframes mgaLogPulse { 0% { box-shadow: 0 0 8px rgba(74, 158, 255, 0.6); }
        100% { box-shadow: 0 0 8px rgba(74, 158, 255, 0.3); } }
      .mga-log-header { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
      .mga-log-icon { font-size: 12px; }
      .mga-log-meta { display: flex; align-items: center; gap: 8px; flex: 1; }
      .mga-log-pet { font-weight: 600; font-size: 11px; }
      .mga-log-time { font-size: 9px; color: rgba(255, 255, 255, 0.6); margin-left: auto; }
      .mga-log-ability { color: rgba(255, 255, 255, 0.9); font-size: 10px; margin: 2px 0 0 18px; }
      .mga-log-details { font-size: 9px; color: rgba(255, 255, 255, 0.5); margin: 2px 0 0 18px; font-style: italic; }
      .mga-log-empty { text-align: center; padding: 20px; color: #888; }
    `;
      (context.head || context.querySelector("head") || targetDocument2.head).appendChild(logStyles);
    }
  }
  function updateLogVisibility(context, { UnifiedState: UnifiedState3, debugLog: debugLog3 }) {
    const abilityLogs = context.querySelector("#ability-logs");
    if (!abilityLogs) return;
    const filterMode = UnifiedState3.data.filterMode || "categories";
    const logItems = abilityLogs.querySelectorAll(".mga-log-item");
    debugLog3("ABILITY_LOGS", "Updating log visibility via CSS", {
      filterMode,
      totalItems: logItems.length
    });
    logItems.forEach((item) => {
      let shouldShow = false;
      if (filterMode === "categories") {
        const category = item.dataset.category;
        shouldShow = UnifiedState3.data.abilityFilters[category] || false;
      } else if (filterMode === "byPet") {
        const petName = item.dataset.petName;
        shouldShow = UnifiedState3.data.petFilters.selectedPets[petName] || false;
      } else if (filterMode === "custom") {
        const abilityType = item.dataset.abilityType;
        shouldShow = UnifiedState3.data.customAbilityFilters[abilityType] || false;
      }
      item.style.display = shouldShow ? "" : "none";
    });
  }
  function updateAllLogVisibility({ UnifiedState: UnifiedState3, targetDocument: targetDocument2, debugLog: debugLog3, updateLogVisibility: updateLogVisibility3 }) {
    debugLog3("ABILITY_LOGS", "Updating log visibility across all contexts");
    updateLogVisibility3(document, { UnifiedState: UnifiedState3, debugLog: debugLog3 });
    const allOverlays = targetDocument2.querySelectorAll(".mga-overlay-content-only, .mga-overlay");
    allOverlays.forEach((overlay) => {
      if (overlay.offsetParent === null) return;
      if (overlay.querySelector("#ability-logs")) {
        updateLogVisibility3(overlay, { UnifiedState: UnifiedState3, debugLog: debugLog3 });
      }
    });
  }
  function updateAllAbilityLogDisplays(force, dependencies) {
    const { UnifiedState: UnifiedState3, targetDocument: targetDocument2, debugLog: debugLog3, CONFIG: CONFIG2, updateAbilityLogDisplay: updateAbilityLogDisplay3, lastLogCount } = dependencies;
    const currentLogCount = UnifiedState3.data.petAbilityLogs?.length || 0;
    if (CONFIG2?.DEBUG?.FLAGS?.FIX_VALIDATION) {
      console.log("[FIX_ABILITY_LOGS] Update called:", {
        force,
        currentLogCount,
        lastLogCount: lastLogCount.value,
        willUpdate: force || currentLogCount !== lastLogCount.value,
        petAbilityLogsExists: !!UnifiedState3.data.petAbilityLogs
      });
    }
    if (!force && currentLogCount === lastLogCount.value) {
      debugLog3("ABILITY_LOGS", "Skipping update - no new logs");
      return;
    }
    lastLogCount.value = currentLogCount;
    debugLog3("ABILITY_LOGS", "Updating ability logs across all contexts");
    updateAbilityLogDisplay3(document, dependencies);
    const allOverlays = targetDocument2.querySelectorAll(".mga-overlay-content-only, .mga-overlay, .mgh-popout");
    allOverlays.forEach((overlay) => {
      if (overlay.offsetParent === null) return;
      if (overlay.querySelector("#ability-logs")) {
        updateAbilityLogDisplay3(overlay, dependencies);
        debugLog3("ABILITY_LOGS", "Updated overlay/widget ability logs", {
          overlayId: overlay.id || overlay.className
        });
      }
    });
    UnifiedState3.data.popouts.windows.forEach((windowRef, tabName) => {
      if (windowRef && !windowRef.closed && tabName === "abilities") {
        try {
          const popoutContent = windowRef.document?.getElementById("popout-content");
          if (popoutContent) {
            const freshContent = dependencies.getAbilitiesTabContent();
            popoutContent.innerHTML = freshContent;
            if (typeof dependencies.setupAbilitiesTabHandlers === "function") {
              dependencies.setupAbilitiesTabHandlers.call(window, windowRef.document);
            }
            debugLog3("ABILITY_LOGS", "Updated pop-out via direct DOM manipulation");
          } else if (windowRef.refreshPopoutContent && typeof windowRef.refreshPopoutContent === "function") {
            windowRef.refreshPopoutContent("abilities");
            debugLog3("ABILITY_LOGS", "Updated pop-out via refresh function");
          }
        } catch (e) {
          debugLog3("ABILITY_LOGS", "Error updating separate window:", e.message);
          try {
            windowRef.location.reload();
            debugLog3("ABILITY_LOGS", "Forced pop-out refresh via reload");
          } catch (e2) {
            debugLog3("ABILITY_LOGS", "Window is dead, removing reference");
            UnifiedState3.data.popouts.windows.delete(tabName);
          }
        }
      }
    });
  }
  function createInstantFeedButton(petIndex, { targetDocument: targetDocument2, UnifiedState: UnifiedState3, handleInstantFeed: handleInstantFeed2 }) {
    const btn = targetDocument2.createElement("button");
    btn.className = "mgtools-instant-feed-btn";
    btn.textContent = "Feed";
    btn.setAttribute("data-pet-index", petIndex);
    btn.setAttribute("data-cooldown", "false");
    const shouldHide = UnifiedState3.data.settings.hideFeedButtons;
    btn.style.cssText = `
    position: absolute !important;
    right: -50px !important;
    top: 50% !important;
    transform: translateY(-50%) !important;
    width: 48px !important;
    height: 24px !important;
    border: 2px solid #FFC83D !important;
    background: rgba(0, 0, 0, 0.75) !important;
    color: rgb(205, 200, 193) !important;
    border-radius: 6px !important;
    font-size: 11px !important;
    font-weight: bold !important;
    cursor: pointer !important;
    z-index: 9999 !important;
    transition: all 0.2s ease !important;
    pointer-events: auto !important;
    display: ${shouldHide ? "none" : "block"} !important;
    visibility: visible !important;
    opacity: 1 !important;
  `;
    btn.addEventListener("mouseenter", () => {
      btn.style.setProperty("box-shadow", "0 0 8px rgba(255, 200, 61, 0.6)", "important");
      btn.style.setProperty("transform", "translateY(-50%) scale(1.05)", "important");
    });
    btn.addEventListener("mouseleave", () => {
      btn.style.setProperty("box-shadow", "none", "important");
      btn.style.setProperty("transform", "translateY(-50%) scale(1)", "important");
    });
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      handleInstantFeed2(petIndex, btn);
    });
    return btn;
  }
  function flashButton(btn, type) {
    const color = type === "success" ? "#4CAF50" : "#F44336";
    const originalBorder = btn.style.borderColor;
    const originalShadow = btn.style.boxShadow;
    btn.style.borderColor = color;
    btn.style.boxShadow = `0 0 10px ${color}`;
    setTimeout(() => {
      btn.style.borderColor = originalBorder || "#FFC83D";
      btn.style.boxShadow = originalShadow || "none";
    }, 300);
  }
  async function handleInstantFeed(petIndex, buttonEl, {
    targetWindow: targetWindow3,
    UnifiedState: UnifiedState3,
    getAtomValue,
    readAtom: readAtom3,
    readMyPetSlots,
    PET_FEED_CATALOG,
    sendFeedPet: sendFeedPet2,
    feedPetEnsureSync: feedPetEnsureSync2,
    flashButton: flashButton2,
    usedCropIds
  }) {
    if (buttonEl.disabled) return;
    buttonEl.disabled = true;
    buttonEl.textContent = "...";
    buttonEl.style.opacity = "0.6";
    try {
      let pet = null;
      if (targetWindow3.jotaiAtomCache) {
        try {
          const freshPetSlots = await getAtomValue("myPetSlotInfosAtom");
          if (freshPetSlots?.[petIndex]) {
            pet = freshPetSlots[petIndex];
            console.log("[MGTOOLS-FIX-A] Using fresh pet data from Jotai atom cache (Tier 1)");
          }
        } catch (e) {
          console.warn("[MGTOOLS-FIX-A] Tier 1 (atom cache) failed:", e.message);
        }
      }
      if (!pet && UnifiedState3.atoms.activePets?.[petIndex]) {
        pet = UnifiedState3.atoms.activePets[petIndex];
        console.log("[MGTOOLS-FIX-A] Using UnifiedState atoms (Tier 2)");
      }
      if (!pet && targetWindow3.myData?.petSlots?.[petIndex]) {
        pet = targetWindow3.myData.petSlots[petIndex];
        console.log("[MGTOOLS-FIX-A] Using window.myData (Tier 3)");
      }
      if (!pet) {
        console.error("[MGTOOLS-FIX-A] \u274C No pet data available from any source");
        alert("Pet data not ready. Please wait a moment and try again.");
        flashButton2(buttonEl, "error");
        buttonEl.disabled = false;
        buttonEl.textContent = "Feed";
        buttonEl.style.opacity = "1";
        return;
      }
      const species = pet.petSpecies;
      const petItemId = pet.id;
      console.log("[Feed-Flow-1] \u{1F43E} Active Pet:", {
        species,
        petItemId: petItemId.substring(0, 8) + "...",
        hunger: pet.hunger,
        hungerPercentage: pet.hunger ? `${pet.hunger}%` : "N/A"
      });
      const compatibleCrops = PET_FEED_CATALOG[species];
      console.log(`[Feed-Flow-2] \u{1F33E} Compatible crops for ${species}:`, compatibleCrops || []);
      if (!compatibleCrops || compatibleCrops.length === 0) {
        console.error("[MGTools Feed] No compatible crops for", species);
        flashButton2(buttonEl, "error");
        buttonEl.disabled = false;
        buttonEl.textContent = "Feed";
        buttonEl.style.opacity = "1";
        return;
      }
      if (typeof unsafeWindow !== "undefined" && unsafeWindow.__mga_cachedInventory) {
        delete unsafeWindow.__mga_cachedInventory;
      }
      let inventoryItems = null;
      if (targetWindow3.jotaiAtomCache) {
        try {
          const freshInventory = await getAtomValue("myCropInventoryAtom");
          if (freshInventory?.items) {
            inventoryItems = freshInventory.items;
            console.log("[MGTOOLS-FIX-A] Using fresh inventory from Jotai atom cache (Tier 1)");
          }
        } catch (e) {
          console.warn("[MGTOOLS-FIX-A] Inventory Tier 1 (atom cache) failed:", e.message);
        }
      }
      if (!inventoryItems) {
        try {
          inventoryItems = readAtom3("myCropItemsAtom") || [];
          if (inventoryItems.length > 0) {
            console.log("[MGTOOLS-FIX-A] Using myCropItemsAtom (Tier 1.5)");
          }
        } catch (e) {
          console.warn("[MGTOOLS-FIX-A] myCropItemsAtom failed:", e.message);
        }
      }
      if (!inventoryItems || inventoryItems.length === 0) {
        if (UnifiedState3.atoms.inventory?.items) {
          inventoryItems = UnifiedState3.atoms.inventory.items.filter(
            (i) => i.itemType === "Produce" || i.itemType === "Crop"
          );
          console.log("[MGTOOLS-FIX-A] Using UnifiedState inventory (Tier 2)");
        }
      }
      if (!inventoryItems || inventoryItems.length === 0) {
        if (targetWindow3.myData?.inventory?.items) {
          inventoryItems = targetWindow3.myData.inventory.items;
          console.log("[MGTOOLS-FIX-A] Using window.myData inventory (Tier 3)");
        }
      }
      console.log("[Feed-Inventory] Fresh read:", inventoryItems?.length || 0, "items");
      if (!inventoryItems || inventoryItems.length === 0) {
        console.error("[MGTOOLS-FIX-A] \u274C No inventory data available from any source");
        alert("Inventory not ready. Please wait a moment.");
        flashButton2(buttonEl, "error");
        buttonEl.disabled = false;
        buttonEl.textContent = "Feed";
        buttonEl.style.opacity = "1";
        return;
      }
      console.log("[Feed-Flow-3] \u{1F4E6} Full inventory:", {
        count: inventoryItems.length,
        species: inventoryItems.map((item) => item.species),
        items: inventoryItems
      });
      const favoritedSpecies = UnifiedState3.data?.autoFavorite?.selectedSpecies || [];
      console.log("[Feed-Flow-4] \u{1F6AB} Favorited species:", favoritedSpecies);
      const nonFavoritedCompatibleCrops = inventoryItems.filter((item) => {
        if (!item || !item.species || !item.id) return false;
        const isCompatible = compatibleCrops.includes(item.species);
        const isFavorited = favoritedSpecies.includes(item.species);
        const notUsed = !usedCropIds.has(item.id);
        return isCompatible && !isFavorited && notUsed;
      });
      console.log("[Feed-Flow-5] \u2705 Non-favorited compatible crops available:", {
        count: nonFavoritedCompatibleCrops.length,
        species: nonFavoritedCompatibleCrops.map((item) => item.species),
        items: nonFavoritedCompatibleCrops
      });
      const cropToFeed = nonFavoritedCompatibleCrops[0];
      console.log(`[Feed-Flow-6] \u2753 Compatible crop exists: ${!!cropToFeed}`);
      if (!cropToFeed) {
        console.error("[MGTools Feed] No feedable crops (compatible, non-favorited, unused)");
        console.log("[MGTools Feed] Compatible species:", compatibleCrops);
        console.log("[MGTools Feed] Favorited species:", favoritedSpecies);
        console.log("[MGTools Feed] Used crop IDs:", Array.from(usedCropIds));
        usedCropIds.clear();
        flashButton2(buttonEl, "error");
        buttonEl.disabled = false;
        buttonEl.textContent = "Feed";
        buttonEl.style.opacity = "1";
        return;
      }
      usedCropIds.add(cropToFeed.id);
      const cropItemId = cropToFeed?.id || cropToFeed?.inventoryItemId || cropToFeed?.itemId;
      console.log("[Feed-Flow-7a] \u{1F9EA} Selected crop:", {
        species: cropToFeed?.species,
        fullItem: cropToFeed,
        resolvedId: cropItemId
      });
      if (!cropItemId) {
        console.error("[Feed] No valid ID found in crop item:", cropToFeed);
        flashButton2(buttonEl, "error");
        buttonEl.disabled = false;
        buttonEl.textContent = "Feed";
        buttonEl.style.opacity = "1";
        return;
      }
      const currentInventory = inventoryItems || [];
      const cropStillExists = currentInventory.some(
        (item) => item.id === cropItemId || item.inventoryItemId === cropItemId || item.itemId === cropItemId
      );
      if (!cropStillExists) {
        console.error("[Feed] Crop no longer in inventory! ID:", cropItemId);
        console.log(
          "[Feed] Current inventory IDs:",
          currentInventory.map((i) => i.id || i.inventoryItemId || i.itemId)
        );
        usedCropIds.delete(cropItemId);
        flashButton2(buttonEl, "error");
        buttonEl.disabled = false;
        buttonEl.textContent = "Feed";
        buttonEl.style.opacity = "1";
        return;
      }
      const slotsNow = readMyPetSlots() || [];
      const reboundPetItemId = slotsNow?.[petIndex]?.id || petItemId;
      if (reboundPetItemId !== petItemId) {
        console.warn("[Feed-Guard] Rebound petItemId from slots", {
          old: petItemId,
          new: reboundPetItemId,
          petIndex
        });
      }
      console.log("[Feed-Debug] \u{1F680} Sending FeedPet message with inventoryItemId");
      try {
        await sendFeedPet2(reboundPetItemId, cropItemId);
        console.log(`[MGTools Feed] \u{1F680} Sent feed: ${species} with ${cropToFeed.species}`);
        flashButton2(buttonEl, "success");
        setTimeout(() => {
          buttonEl.disabled = false;
          buttonEl.textContent = "Feed";
          buttonEl.style.opacity = "1";
        }, 200);
        feedPetEnsureSync2(reboundPetItemId, cropItemId, petIndex, false).then((result) => {
          if (!result?.verified) {
            console.warn("[MGTools Feed] \u26A0\uFE0F Background verification failed (feed may have worked anyway)");
          } else {
            console.log("[MGTools Feed] \u2705 Background verification succeeded");
          }
        }).catch((err) => console.warn("[MGTools Feed] Background verification error:", err));
      } catch (err) {
        console.warn("[MGTools Feed] \u26A0\uFE0F Feed failed:", err.message);
        flashButton2(buttonEl, "error");
        usedCropIds.delete(cropToFeed.id);
        buttonEl.disabled = false;
        buttonEl.textContent = "Feed";
        buttonEl.style.opacity = "1";
      }
    } catch (error) {
      console.error("[MGTools Feed] Error:", error);
      flashButton2(buttonEl, "error");
      buttonEl.disabled = false;
      buttonEl.textContent = "Feed";
      buttonEl.style.opacity = "1";
    }
  }
  function injectInstantFeedButtons({ targetDocument: targetDocument2, targetWindow: targetWindow3, createInstantFeedButton: createInstantFeedButton2, productionLog: productionLog3 }) {
    let isInjecting = false;
    return function inject() {
      if (isInjecting) {
        return;
      }
      try {
        isInjecting = true;
        console.log("[MGTools Feed] \u{1F50D} Starting container-based injection...");
        const existingButtons = targetDocument2.querySelectorAll(".mgtools-instant-feed-btn");
        const existingIndices = /* @__PURE__ */ new Set();
        existingButtons.forEach((btn) => {
          const index = btn.getAttribute("data-pet-index");
          if (index !== null) {
            existingIndices.add(parseInt(index, 10));
          }
        });
        if (existingIndices.size === 3) {
          isInjecting = false;
          return;
        }
        const missingIndices = [0, 1, 2].filter((i) => !existingIndices.has(i));
        const allCanvases = Array.from(targetDocument2.querySelectorAll("canvas"));
        const viewportWidth = targetWindow3.innerWidth;
        const viewportHeight = targetWindow3.innerHeight;
        const leftThreshold = viewportWidth * 0.15;
        const minTop = 80;
        const maxTop = viewportHeight - 100;
        const petAvatarCanvases = allCanvases.filter((canvas) => {
          const rect = canvas.getBoundingClientRect();
          const isOnScreen = rect.left >= 0 && rect.left < leftThreshold;
          const hasReasonableSize = rect.width > 20 && rect.width < 200 && rect.height > 20 && rect.height < 200;
          const isInValidVerticalRange = rect.top > minTop && rect.top < maxTop;
          if (isOnScreen && hasReasonableSize && isInValidVerticalRange) {
          }
          return isOnScreen && hasReasonableSize && isInValidVerticalRange;
        }).sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top).slice(0, 3);
        if (petAvatarCanvases.length === 0) {
          console.warn("[MGTools Feed] \u26A0\uFE0F No pet avatar canvases found!");
          isInjecting = false;
          return;
        }
        petAvatarCanvases.forEach((canvas, index) => {
          try {
            if (existingIndices.has(index)) {
              return;
            }
            let container = canvas.parentElement;
            let levelsUp = 0;
            const maxLevels = 10;
            const candidates = [];
            while (container && levelsUp < maxLevels && container !== targetDocument2.body) {
              const hasStats = /STR\s+\d+|INT\s+\d+/.test(container.textContent);
              const rect = container.getBoundingClientRect();
              if (hasStats && rect.width < 200 && rect.height < 200) {
                candidates.push({
                  element: container,
                  area: rect.width * rect.height,
                  width: rect.width,
                  height: rect.height
                });
              }
              container = container.parentElement;
              levelsUp++;
            }
            if (candidates.length === 0) {
              console.warn(`[MGTools Feed] \u26A0\uFE0F No valid container found for pet ${index + 1}`);
              return;
            }
            candidates.sort((a, b) => a.area - b.area);
            const targetContainer = candidates[0].element;
            console.log(`[MGTools Feed] \u{1F4D0} Selected container:`, {
              width: candidates[0].width.toFixed(1),
              height: candidates[0].height.toFixed(1),
              tagName: targetContainer.tagName
            });
            if (targetContainer.querySelector(".mgtools-instant-feed-btn")) {
              return;
            }
            const currentPosition = targetWindow3.getComputedStyle(targetContainer).position;
            if (currentPosition === "static") {
              targetContainer.style.position = "relative";
            }
            const btn = createInstantFeedButton2(index);
            targetContainer.appendChild(btn);
            productionLog3(`[MGTools Feed] Injected feed button ${index + 1}`);
          } catch (err) {
            console.error(`[MGTools Feed] Error processing canvas ${index + 1}:`, err);
          }
        });
        isInjecting = false;
      } catch (error) {
        console.error("[MGTools Feed] Error in injectInstantFeedButtons:", error);
        isInjecting = false;
      }
    };
  }
  function initializeInstantFeedButtons({ targetDocument: targetDocument2, targetWindow: targetWindow3, createInstantFeedButton: createInstantFeedButton2, captureJotaiStore, productionLog: productionLog3 }, options = {}) {
    const { pollInterval = 2e3 } = options;
    console.log("[MGTools Feed] \u{1F680} Initializing instant feed buttons with polling interval...");
    let jotaiStore = null;
    if (!jotaiStore) {
      jotaiStore = captureJotaiStore();
      if (jotaiStore) {
        console.log("[MGTools Feed] \u2705 Jotai store captured at initialization");
      } else {
        console.log("[MGTools Feed] \u23F3 Jotai store not ready yet - will use fallback data");
      }
    }
    function findVisiblePetContainers() {
      const allCanvases = Array.from(targetDocument2.querySelectorAll("canvas"));
      const viewportWidth = targetWindow3.innerWidth;
      const viewportHeight = targetWindow3.innerHeight;
      const leftThreshold = viewportWidth * 0.15;
      const minTop = 80;
      const maxTop = viewportHeight - 100;
      const petAvatarCanvases = allCanvases.filter((canvas) => {
        const rect = canvas.getBoundingClientRect();
        const computedStyle = targetWindow3.getComputedStyle(canvas);
        const isVisible = computedStyle.display !== "none" && computedStyle.visibility !== "hidden" && rect.width > 0 && rect.height > 0;
        if (!isVisible) return false;
        const isOnScreen = rect.left >= 0 && rect.left < leftThreshold;
        const hasReasonableSize = rect.width > 20 && rect.width < 200 && rect.height > 20 && rect.height < 200;
        const isInValidVerticalRange = rect.top > minTop && rect.top < maxTop;
        return isOnScreen && hasReasonableSize && isInValidVerticalRange;
      }).sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top).slice(0, 3);
      const containers = [];
      petAvatarCanvases.forEach((canvas) => {
        let container = canvas.parentElement;
        let levelsUp = 0;
        const maxLevels = 10;
        const candidates = [];
        while (container && levelsUp < maxLevels && container !== targetDocument2.body) {
          const hasStats = /STR\s+\d+|INT\s+\d+/.test(container.textContent);
          const rect = container.getBoundingClientRect();
          if (hasStats && rect.width < 200 && rect.height < 200 && rect.width > 0) {
            candidates.push({
              element: container,
              area: rect.width * rect.height
            });
          }
          container = container.parentElement;
          levelsUp++;
        }
        if (candidates.length > 0) {
          candidates.sort((a, b) => a.area - b.area);
          containers.push(candidates[0].element);
        }
      });
      return containers;
    }
    function injectButton(container, index) {
      if (container.querySelector(".mgtools-instant-feed-btn")) {
        return false;
      }
      try {
        const currentPosition = targetWindow3.getComputedStyle(container).position;
        if (currentPosition === "static") {
          container.style.position = "relative";
        }
        const btn = createInstantFeedButton2(index);
        container.appendChild(btn);
        return true;
      } catch (err) {
        console.error(`[MGTools Feed] Error injecting button ${index + 1}:`, err);
        return false;
      }
    }
    function checkAndInjectButtons() {
      const containers = findVisiblePetContainers();
      if (containers.length === 0) {
        return;
      }
      let injectedCount = 0;
      containers.forEach((container, index) => {
        const injected = injectButton(container, index);
        if (injected) injectedCount++;
      });
      if (injectedCount > 0) {
      }
    }
    checkAndInjectButtons();
    const interval = setInterval(() => {
      try {
        const petContainers = findVisiblePetContainers();
        if (petContainers.length > 0) {
          checkAndInjectButtons();
        }
      } catch (err) {
        console.error("[MGTools Feed] Error in polling:", err);
      }
    }, pollInterval);
    if (!targetWindow3.MGToolsIntervals) {
      targetWindow3.MGToolsIntervals = [];
    }
    targetWindow3.MGToolsIntervals.push(interval);
    console.log(
      `[MGTools Feed] \u2705 Polling active (${pollInterval}ms) - buttons will auto-reappear when containers become visible`
    );
    productionLog3("\u2705 [MGTools] Instant feed buttons initialized with polling detection");
  }
  function presetHasCropEater(preset, dependencies = {}) {
    const { productionLog: productionLog3 = console.log } = dependencies;
    if (!preset || !Array.isArray(preset)) {
      return false;
    }
    const wormsWithCropEater = preset.filter(
      (p) => p && p.petSpecies === "Worm" && p.abilities?.some(
        (a) => a === "Crop Eater" || a === "CropEater" || typeof a === "string" && a.toLowerCase().includes("crop") && a.toLowerCase().includes("eater")
      )
    );
    if (wormsWithCropEater.length > 0) {
      productionLog3(`[Crop Eater Check] Preset contains ${wormsWithCropEater.length} Worm(s) with Crop Eater - skipping`);
    }
    return wormsWithCropEater.length > 0;
  }
  function cycleToNextPreset(dependencies) {
    const { UnifiedState: UnifiedState3, ensurePresetOrder: ensurePresetOrder2, placePetPreset: placePetPreset2, presetHasCropEater: presetHasCropEater2, productionLog: productionLog3 } = dependencies;
    ensurePresetOrder2();
    if (UnifiedState3.data.petPresetsOrder.length === 0) {
      productionLog3("[Cycle Presets] No presets available");
      return;
    }
    const startIndex = UnifiedState3.data.currentPresetIndex;
    let attempts = 0;
    const maxAttempts = UnifiedState3.data.petPresetsOrder.length;
    do {
      UnifiedState3.data.currentPresetIndex++;
      if (UnifiedState3.data.currentPresetIndex >= UnifiedState3.data.petPresetsOrder.length) {
        UnifiedState3.data.currentPresetIndex = 0;
      }
      const presetName = UnifiedState3.data.petPresetsOrder[UnifiedState3.data.currentPresetIndex];
      const preset = UnifiedState3.data.petPresets[presetName];
      attempts++;
      if (preset && !presetHasCropEater2(preset, { productionLog: productionLog3 })) {
        productionLog3(
          `[Cycle Presets] Loading: ${presetName} (${UnifiedState3.data.currentPresetIndex + 1}/${UnifiedState3.data.petPresetsOrder.length})`
        );
        placePetPreset2(presetName);
        return;
      } else if (preset && presetHasCropEater2(preset, { productionLog: productionLog3 })) {
        productionLog3(`[Cycle Presets] Skipping ${presetName} - contains Crop Eater`);
      }
    } while (attempts < maxAttempts);
    productionLog3("[Cycle Presets] All presets contain Crop Eater - cannot cycle");
  }
  function playAbilityNotificationSound(volume, dependencies = {}) {
    const {
      GM_getValue: GM_getValue2 = typeof window !== "undefined" && window.GM_getValue,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      playSingleBeepNotification: playSingleBeepNotification2,
      playDoubleBeepNotification: playDoubleBeepNotification2,
      playTripleBeepNotification: playTripleBeepNotification2,
      playChimeNotification: playChimeNotification2,
      playAlertNotification: playAlertNotification2,
      playBuzzNotification: playBuzzNotification2,
      playDingNotification: playDingNotification2,
      playChirpNotification: playChirpNotification2,
      playEpicNotification: playEpicNotification2,
      productionLog: productionLog3 = console.log
    } = dependencies;
    const customSound = GM_getValue2?.("mgtools_custom_sound_ability", null);
    if (customSound) {
      try {
        const audio = new Audio(customSound);
        audio.volume = volume || 0.2;
        audio.play();
        productionLog3("\u{1F3B5} [CUSTOM-SOUND] Playing custom ability sound");
        return;
      } catch (err) {
        console.error("Failed to play custom ability sound:", err);
      }
    }
    if (!customSound) {
      const abilitySound = UnifiedState3?.data?.settings?.notifications?.abilityNotificationSound || "single";
      switch (abilitySound) {
        case "single":
          playSingleBeepNotification2?.(volume);
          break;
        case "double":
          playDoubleBeepNotification2?.(volume);
          break;
        case "triple":
          playTripleBeepNotification2?.(volume);
          break;
        case "chime":
          playChimeNotification2?.(volume);
          break;
        case "alert":
          playAlertNotification2?.(volume);
          break;
        case "buzz":
          playBuzzNotification2?.(volume);
          break;
        case "ding":
          playDingNotification2?.(volume);
          break;
        case "chirp":
          playChirpNotification2?.(volume);
          break;
        case "epic":
          playEpicNotification2?.(volume);
          break;
        default:
          playSingleBeepNotification2?.(volume);
      }
    }
  }
  function setupAbilitiesTabHandlers(context = document, dependencies, options = {}) {
    const {
      debugLog: debugLog3,
      switchFilterMode: switchFilterMode2,
      selectAllFilters: selectAllFilters3,
      selectNoneFilters: selectNoneFilters3,
      updateAllLogVisibility: updateAllLogVisibility3,
      UnifiedState: UnifiedState3,
      MGA_saveJSON: MGA_saveJSON2,
      logDebug: logDebug2,
      GM_getValue: GM_getValue2,
      logWarn: logWarn3,
      MGA_loadJSON: MGA_loadJSON2,
      productionWarn: productionWarn3,
      productionLog: productionLog3,
      updateTabContent,
      updateAllAbilityLogDisplays: updateAllAbilityLogDisplays3,
      exportAbilityLogs: exportAbilityLogs2,
      MGA_diagnoseAbilityLogStorage: MGA_diagnoseAbilityLogStorage2,
      showNotificationToast: showNotificationToast2,
      updateAbilityLogDisplay: updateAbilityLogDisplay3,
      populateFilterModeContent: populateFilterModeContent2,
      MGA_AbilityCache: MGA_AbilityCache2
    } = dependencies;
    let { lastLogCount } = options;
    debugLog3("ABILITY_LOGS", "Setting up abilities tab handlers with context", {
      isDocument: context === document,
      className: context.className || "document"
    });
    const categoriesBtn = context.querySelector("#filter-mode-categories");
    const byPetBtn = context.querySelector("#filter-mode-bypet");
    const customBtn = context.querySelector("#filter-mode-custom");
    if (categoriesBtn && !categoriesBtn.hasAttribute("data-handler-setup")) {
      categoriesBtn.setAttribute("data-handler-setup", "true");
      categoriesBtn.addEventListener("click", () => switchFilterMode2("categories"));
    }
    if (byPetBtn && !byPetBtn.hasAttribute("data-handler-setup")) {
      byPetBtn.setAttribute("data-handler-setup", "true");
      byPetBtn.addEventListener("click", () => switchFilterMode2("byPet"));
    }
    if (customBtn && !customBtn.hasAttribute("data-handler-setup")) {
      customBtn.setAttribute("data-handler-setup", "true");
      customBtn.addEventListener("click", () => switchFilterMode2("custom"));
    }
    const selectAllBtn = context.querySelector("#select-all-filters");
    const selectNoneBtn = context.querySelector("#select-none-filters");
    if (selectAllBtn && !selectAllBtn.hasAttribute("data-handler-setup")) {
      selectAllBtn.setAttribute("data-handler-setup", "true");
      selectAllBtn.addEventListener("click", () => {
        const mode = UnifiedState3.data.filterMode || "categories";
        selectAllFilters3(mode);
      });
    }
    if (selectNoneBtn && !selectNoneBtn.hasAttribute("data-handler-setup")) {
      selectNoneBtn.setAttribute("data-handler-setup", "true");
      selectNoneBtn.addEventListener("click", () => {
        const mode = UnifiedState3.data.filterMode || "categories";
        selectNoneFilters3(mode);
      });
    }
    context.querySelectorAll("#category-filters .mga-checkbox[data-filter]").forEach((checkbox) => {
      if (!checkbox.hasAttribute("data-handler-setup")) {
        checkbox.setAttribute("data-handler-setup", "true");
        checkbox.addEventListener("change", (e) => {
          const filterKey = e.target.dataset.filter;
          UnifiedState3.data.abilityFilters[filterKey] = e.target.checked;
          MGA_saveJSON2("MGA_abilityFilters", UnifiedState3.data.abilityFilters);
          updateAllLogVisibility3();
          debugLog3("ABILITY_LOGS", `Filter ${filterKey} changed to ${e.target.checked}, updated visibility via CSS`);
        });
      }
    });
    const clearLogsBtn = context.querySelector("#clear-logs-btn");
    if (clearLogsBtn && !clearLogsBtn.hasAttribute("data-handler-setup")) {
      clearLogsBtn.setAttribute("data-handler-setup", "true");
      clearLogsBtn.addEventListener("click", () => {
        logDebug2("ABILITY-LOGS", "Starting comprehensive ability log clear...");
        const beforeClear = {
          memory: UnifiedState3.data.petAbilityLogs?.length || 0,
          gmMain: (() => {
            try {
              const v = GM_getValue2("MGA_petAbilityLogs", null);
              return v ? JSON.parse(v).length : 0;
            } catch (e) {
              return 0;
            }
          })(),
          gmArchive: (() => {
            try {
              const v = GM_getValue2("MGA_petAbilityLogs_archive", null);
              return v ? JSON.parse(v).length : 0;
            } catch (e) {
              return 0;
            }
          })(),
          lsMain: (() => {
            try {
              const v = window.localStorage?.getItem("MGA_petAbilityLogs");
              return v ? JSON.parse(v).length : 0;
            } catch (e) {
              return 0;
            }
          })(),
          lsArchive: (() => {
            try {
              const v = window.localStorage?.getItem("MGA_petAbilityLogs_archive");
              return v ? JSON.parse(v).length : 0;
            } catch (e) {
              return 0;
            }
          })()
        };
        logDebug2("ABILITY-LOGS", "\u{1F4CA} BEFORE CLEAR - Log counts:", beforeClear);
        if (UnifiedState3.data.petAbilityLogs?.length > 0) {
          logDebug2("ABILITY-LOGS", "\u{1F4CB} Current logs in memory:");
          UnifiedState3.data.petAbilityLogs.forEach((log, i) => {
            logDebug2(
              "ABILITY-LOGS",
              `  ${i + 1}. ${log.abilityType} - ${log.petName} - ${new Date(log.timestamp).toLocaleString()}`
            );
          });
        }
        UnifiedState3.data.petAbilityLogs = [];
        logDebug2("ABILITY-LOGS", "  \u2713 Cleared UnifiedState memory");
        MGA_saveJSON2("MGA_petAbilityLogs", []);
        MGA_saveJSON2("MGA_petAbilityLogs_archive", []);
        logDebug2("ABILITY-LOGS", "  \u2713 Cleared GM storage (main + archive)");
        try {
          window.localStorage?.removeItem("MGA_petAbilityLogs");
          window.localStorage?.removeItem("MGA_petAbilityLogs_archive");
          logDebug2("ABILITY-LOGS", "  \u2713 Cleared window.localStorage");
        } catch (e) {
          logWarn3("ABILITY-LOGS", "  \u26A0\uFE0F Could not clear window.localStorage:", e.message);
        }
        try {
          if (typeof targetWindow !== "undefined" && targetWindow && targetWindow !== window) {
            targetWindow.localStorage?.removeItem("MGA_petAbilityLogs");
            targetWindow.localStorage?.removeItem("MGA_petAbilityLogs_archive");
            logDebug2("ABILITY-LOGS", "  \u2713 Cleared targetWindow.localStorage");
          }
        } catch (e) {
          logWarn3("ABILITY-LOGS", "  \u26A0\uFE0F Could not clear targetWindow.localStorage:", e.message);
        }
        try {
          if (typeof window.petAbilityLogs !== "undefined") {
            window.petAbilityLogs = [];
            logDebug2("ABILITY-LOGS", "  \u2713 Cleared window.petAbilityLogs compatibility array");
          }
        } catch (e) {
          logWarn3("ABILITY-LOGS", "  \u26A0\uFE0F Could not clear compatibility array:", e.message);
        }
        const clearTimestamp = Date.now();
        localStorage.setItem("MGA_logs_manually_cleared", clearTimestamp.toString());
        localStorage.setItem("MGA_logs_clear_session", clearTimestamp.toString());
        try {
          GM_setValue("MGA_logs_manually_cleared", clearTimestamp.toString());
        } catch (e) {
          logWarn3("ABILITY-LOGS", "  \u26A0\uFE0F Could not set GM clear flag:", e.message);
        }
        logDebug2("ABILITY-LOGS", "  \u2713 Set manual clear flags (session + GM + timestamp)");
        const verifyMain = MGA_loadJSON2("MGA_petAbilityLogs", null);
        const verifyArchive = MGA_loadJSON2("MGA_petAbilityLogs_archive", null);
        const verifyLS = window.localStorage?.getItem("MGA_petAbilityLogs");
        const verifyCompat = typeof window.petAbilityLogs !== "undefined" ? window.petAbilityLogs?.length : "N/A";
        const afterClear = {
          memory: UnifiedState3.data.petAbilityLogs?.length || 0,
          gmMain: verifyMain?.length || 0,
          gmArchive: verifyArchive?.length || 0,
          lsMain: verifyLS ? (() => {
            try {
              return JSON.parse(verifyLS).length;
            } catch (e) {
              return "parse-error";
            }
          })() : 0,
          lsArchive: (() => {
            try {
              const v = window.localStorage?.getItem("MGA_petAbilityLogs_archive");
              return v ? JSON.parse(v).length : 0;
            } catch (e) {
              return 0;
            }
          })(),
          compatArray: verifyCompat
        };
        logDebug2("ABILITY-LOGS", "\u{1F4CA} AFTER CLEAR - Log counts:", afterClear);
        logDebug2("ABILITY-LOGS", "\u{1F4CA} COMPARISON:", {
          before: beforeClear,
          after: afterClear,
          clearedFlag: localStorage.getItem("MGA_logs_manually_cleared")
        });
        const totalRemaining = Object.values(afterClear).reduce(
          (sum, val) => sum + (typeof val === "number" ? val : 0),
          0
        );
        if (totalRemaining > 0) {
          productionWarn3(`\u26A0\uFE0F [ABILITIES] ${totalRemaining} log(s) persist after clear!`);
          logDebug2("ABILITY-LOGS", "\u{1F50D} Logs that persisted - check these sources:", afterClear);
          if (verifyMain && verifyMain.length > 0) {
            logDebug2("ABILITY-LOGS", "\u274C PERSISTENT LOGS IN GM STORAGE:");
            verifyMain.forEach((log, i) => {
              logDebug2(
                "ABILITY-LOGS",
                `  ${i + 1}. ${log.abilityType} - ${log.petName} - ${new Date(log.timestamp).toLocaleString()}`
              );
            });
          }
        } else {
          productionLog3("\u2705 [ABILITIES] Successfully cleared all ability logs from all storage locations");
        }
        lastLogCount = 0;
        updateTabContent();
        updateAllAbilityLogDisplays3();
      });
    }
    const exportLogsBtn = context.querySelector("#export-logs-btn");
    if (exportLogsBtn && !exportLogsBtn.hasAttribute("data-handler-setup")) {
      exportLogsBtn.setAttribute("data-handler-setup", "true");
      exportLogsBtn.addEventListener("click", () => {
        exportAbilityLogs2();
      });
    }
    const diagnoseLogsBtn = context.querySelector("#diagnose-logs-btn");
    if (diagnoseLogsBtn && !diagnoseLogsBtn.hasAttribute("data-handler-setup")) {
      diagnoseLogsBtn.setAttribute("data-handler-setup", "true");
      diagnoseLogsBtn.addEventListener("click", () => {
        console.log("\u{1F50D} Running ability logs storage diagnostic...");
        const report = MGA_diagnoseAbilityLogStorage2();
        const totalWithLogs = report.summary.totalLocationsWithLogs;
        if (totalWithLogs === 0) {
          showNotificationToast2("\u2705 No ability logs found in any storage location", "success");
        } else {
          showNotificationToast2(
            `\u{1F4CA} Found logs in ${totalWithLogs} storage location(s). Check console for details.`,
            "info"
          );
        }
      });
    }
    const detailedTimestampsCheckbox = context.querySelector("#detailed-timestamps-checkbox");
    if (detailedTimestampsCheckbox && !detailedTimestampsCheckbox.hasAttribute("data-handler-setup")) {
      detailedTimestampsCheckbox.setAttribute("data-handler-setup", "true");
      detailedTimestampsCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.detailedTimestamps = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        MGA_AbilityCache2.timestamps.clear();
        UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
          if (tabName === "abilities" && overlay && overlay.offsetParent !== null) {
            updateAbilityLogDisplay3(overlay);
            debugLog3("ABILITY_LOGS", "Updated overlay with new timestamp format");
          }
        });
        updateAllAbilityLogDisplays3(true);
        productionLog3(`\u{1F550} [ABILITIES] Detailed timestamps: ${e.target.checked ? "enabled" : "disabled"}`);
      });
    }
    const currentMode = UnifiedState3.data.filterMode || "categories";
    setTimeout(() => populateFilterModeContent2(currentMode), 100);
  }
  var pets_default = {
    // Constants
    SPECIES_MAX_HUNGER,
    SPECIES_HUNGER_DEPLETION_TIME,
    HUNGER_BOOST_VALUES,
    // Presets
    exportPetPresets: exportPetPresets2,
    importPetPresets: importPetPresets2,
    // Hunger Monitoring
    checkPetHunger,
    scanAndAlertHungryPets,
    calculateTimeUntilHungry,
    formatHungerTimer,
    // Pet Detection
    getActivePetsFromRoomState,
    updateActivePetsFromRoomState,
    // Pet Feeding
    sendFeedPet,
    feedPetEnsureSync,
    // UI Helpers (Phase 3)
    updatePetPresetDropdown,
    updateActivePetsDisplay,
    ensurePresetOrder,
    movePreset,
    getDragAfterElement,
    refreshPresetsList,
    addPresetToList,
    setupPetsTabHandlers,
    // Tab Content Generators (Phase 3 - continued)
    getPetsPopoutContent: getPetsPopoutContent2,
    setupPetPopoutHandlers: setupPetPopoutHandlers2,
    getPetsTabContent,
    // Ability Calculation Helpers (Game-specific)
    getTurtleExpectations,
    estimateUntilLatestCrop,
    getAbilityExpectations,
    getEggExpectations,
    getGrowthExpectations,
    // Auto-Favorite System (Phase 4)
    initAutoFavorite,
    favoriteSpecies,
    unfavoriteSpecies,
    favoriteMutation,
    unfavoriteMutation,
    favoritePetAbility,
    unfavoritePetAbility,
    // Additional Pet Functions (Phase 5)
    playPetNotificationSound,
    placePetPreset,
    loadPetPreset,
    getAllUniquePets,
    populatePetSpeciesList,
    shouldLogAbility,
    categorizeAbilityToFilterKey,
    monitorPetAbilities,
    // Ability Log Utilities (Phase 6)
    getAllUniqueAbilities,
    populateIndividualAbilities,
    selectAllFilters,
    selectNoneFilters,
    exportAbilityLogs,
    loadPresetByNumber,
    // Supporting Utilities (Phase 6)
    normalizeAbilityName: normalizeAbilityName2,
    formatTimestamp,
    getGardenCropIfUnique,
    // Ability Log Management (Phase 7)
    KNOWN_ABILITY_TYPES: KNOWN_ABILITY_TYPES2,
    isKnownAbilityType: isKnownAbilityType2,
    initAbilityCache,
    MGA_manageLogMemory,
    MGA_getAllLogs,
    categorizeAbility,
    formatLogData,
    formatRelativeTime,
    // Display Update Functions (Phase 8)
    updateAbilityLogDisplay,
    updateLogVisibility,
    updateAllLogVisibility,
    updateAllAbilityLogDisplays,
    // Instant Feed Core Functions (Phase 9)
    createInstantFeedButton,
    flashButton,
    handleInstantFeed,
    // Instant Feed Initialization & Polling (Phase 10)
    injectInstantFeedButtons,
    initializeInstantFeedButtons,
    // Additional Pet Management Functions (Phase 11)
    presetHasCropEater,
    cycleToNextPreset,
    playAbilityNotificationSound,
    setupAbilitiesTabHandlers
  };

  // src/features/abilities/abilities-ui.js
  var abilities_ui_exports = {};
  __export(abilities_ui_exports, {
    getAbilitiesTabContent: () => getAbilitiesTabContent
  });
  function getAbilitiesTabContent(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const logs = (UnifiedState3?.data?.petAbilityLogs || []).slice(0, 30);
    const filterMode = UnifiedState3?.data?.filterMode || "categories";
    const abilityFilters = UnifiedState3?.data?.abilityFilters || {};
    const debugMode = UnifiedState3?.data?.settings?.debugMode || false;
    const detailedTimestamps = UnifiedState3?.data?.settings?.detailedTimestamps || false;
    const html = `
          <div class="mga-section">
              <div class="mga-section-title">Filter Mode</div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 8px;">
                  <div style="display: flex; gap: 6px;">
                      <button class="mga-btn mga-btn-sm ${filterMode === "categories" ? "active" : ""}" id="filter-mode-categories" style="padding: 6px 12px; font-size: 12px;">Categories</button>
                      <button class="mga-btn mga-btn-sm ${filterMode === "byPet" ? "active" : ""}" id="filter-mode-bypet" style="padding: 6px 12px; font-size: 12px;">By Pet</button>
                      <button class="mga-btn mga-btn-sm ${filterMode === "custom" ? "active" : ""}" id="filter-mode-custom" style="padding: 6px 12px; font-size: 12px;">Custom</button>
                  </div>
                  <div style="display: flex; gap: 6px;">
                      <button class="mga-btn mga-btn-sm" id="select-all-filters" style="padding: 6px 10px; font-size: 11px;">All</button>
                      <button class="mga-btn mga-btn-sm" id="select-none-filters" style="padding: 6px 10px; font-size: 11px;">None</button>
                  </div>
              </div>
              <div id="filter-mode-description" style="font-size: 11px; color: #aaa; margin-bottom: 12px; padding: 6px 10px; background: rgba(255,255,255,0.03); border-radius: 4px;">
                  ${filterMode === "categories" ? "\u{1F4C2} Filter by ability categories" : filterMode === "byPet" ? "\u{1F43E} Filter by pet species" : "\u2699\uFE0F Filter by individual abilities"}
              </div>

              <!-- Categories Mode -->
              <div id="category-filters" style="display: ${filterMode === "categories" ? "grid" : "none"}; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                  <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                      <input type="checkbox" class="mga-checkbox" ${abilityFilters.xpBoost ? "checked" : ""} data-filter="xpBoost" style="accent-color: #4a9eff;">
                      <span class="mga-label" style="font-size: 12px;">\u{1F4AB} XP Boost</span>
                  </label>
                  <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                      <input type="checkbox" class="mga-checkbox" ${abilityFilters.cropSizeBoost ? "checked" : ""} data-filter="cropSizeBoost" style="accent-color: #4a9eff;">
                      <span class="mga-label" style="font-size: 12px;">\u{1F4C8} Crop Size Boost</span>
                  </label>
                  <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                      <input type="checkbox" class="mga-checkbox" ${abilityFilters.selling ? "checked" : ""} data-filter="selling" style="accent-color: #4a9eff;">
                      <span class="mga-label" style="font-size: 12px;">\u{1F4B0} Selling</span>
                  </label>
                  <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                      <input type="checkbox" class="mga-checkbox" ${abilityFilters.harvesting ? "checked" : ""} data-filter="harvesting" style="accent-color: #4a9eff;">
                      <span class="mga-label" style="font-size: 12px;">\u{1F33E} Harvesting</span>
                  </label>
                  <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                      <input type="checkbox" class="mga-checkbox" ${abilityFilters.growthSpeed ? "checked" : ""} data-filter="growthSpeed" style="accent-color: #4a9eff;">
                      <span class="mga-label" style="font-size: 12px;">\u{1F422} Growth Speed</span>
                  </label>
                  <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                      <input type="checkbox" class="mga-checkbox" ${abilityFilters.specialMutations ? "checked" : ""} data-filter="specialMutations" style="accent-color: #4a9eff;">
                      <span class="mga-label" style="font-size: 12px;">\u{1F308}\u2728 Special Mutations</span>
                  </label>
                  <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                      <input type="checkbox" class="mga-checkbox" ${abilityFilters.other ? "checked" : ""} data-filter="other" style="accent-color: #4a9eff;">
                      <span class="mga-label" style="font-size: 12px;">\u{1F527} Other</span>
                  </label>
              </div>

              <!-- By Pet Mode -->
              <div id="pet-filters" style="display: ${filterMode === "byPet" ? "block" : "none"}; margin-bottom: 8px;">
                  <div id="pet-species-list" class="mga-scrollable" style="max-height: 150px; border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; padding: 8px;">
                      <div style="color: #888; text-align: center;">Loading pet species...</div>
                  </div>
              </div>

              <!-- Custom Mode -->
              <div id="custom-filters" style="display: ${filterMode === "custom" ? "block" : "none"}; margin-bottom: 8px;">
                  <div id="individual-abilities-list" class="mga-scrollable" style="max-height: 150px; border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; padding: 8px;">
                      <div style="color: #888; text-align: center;">Loading individual abilities...</div>
                  </div>
              </div>

              <div style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
                  <button class="mga-btn mga-btn-sm" id="clear-logs-btn">Clear Logs</button>
                  <button class="mga-btn mga-btn-sm" id="export-logs-btn">Export CSV</button>
                  ${debugMode ? '<button class="mga-btn mga-btn-sm" id="diagnose-logs-btn" style="background: #ff6b35;">\u{1F50D} Diagnose Storage</button>' : ""}
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">Recent Ability Triggers</div>
              <div style="margin-bottom: 8px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="detailed-timestamps-checkbox" class="mga-checkbox"
                             ${detailedTimestamps ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F550} Show detailed timestamps (HH:MM:SS)</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      When enabled, shows detailed 24-hour format timestamps instead of 12-hour format.
                  </p>
              </div>
              <div id="ability-logs" class="mga-scrollable" style="max-height: 400px; overflow-y: auto;">
                  ${logs.length === 0 ? '<div style="color: #888; text-align: center; padding: 20px;">No ability logs yet. Ability logs will appear here when your pets trigger abilities in-game.</div>' : ""}
              </div>
          </div>
      `;
    return html;
  }

  // src/features/settings-ui.js
  var settings_ui_exports = {};
  __export(settings_ui_exports, {
    getSettingsTabContent: () => getSettingsTabContent,
    setupSettingsTabHandlers: () => setupSettingsTabHandlers
  });
  function getSettingsTabContent(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      CompatibilityMode: CompatibilityMode2 = typeof window !== "undefined" && window.CompatibilityMode
    } = dependencies;
    const settings = UnifiedState3.data.settings;
    return `
          <div class="mga-section">
              <div class="mga-section-title">Appearance</div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Main HUD Opacity: ${settings.opacity}%
                  </label>
                  <input type="range" class="mga-slider" id="opacity-slider"
                         min="0" max="100" value="${settings.opacity}"
                         style="width: 100%; accent-color: #4a9eff;">
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Pop-out Opacity: ${settings.popoutOpacity}%
                  </label>
                  <input type="range" class="mga-slider" id="popout-opacity-slider"
                         min="0" max="100" value="${settings.popoutOpacity}"
                         style="width: 100%; accent-color: #4a9eff;">
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Gradient Style
                  </label>
                  <select class="mga-select" id="gradient-select" style="margin-bottom: 8px;">
                      <optgroup label="\u26AB Black Accent Themes">
                          <option value="black-void" ${settings.gradientStyle === "black-void" ? "selected" : ""}>\u26AB\u2B1B Pure Void</option>
                          <option value="black-crimson" ${settings.gradientStyle === "black-crimson" ? "selected" : ""}>\u26AB\u{1F534} Midnight Crimson</option>
                          <option value="black-emerald" ${settings.gradientStyle === "black-emerald" ? "selected" : ""}>\u26AB\u{1F49A} Shadow Emerald</option>
                          <option value="black-royal" ${settings.gradientStyle === "black-royal" ? "selected" : ""}>\u26AB\u{1F49C} Void Royal</option>
                          <option value="black-gold" ${settings.gradientStyle === "black-gold" ? "selected" : ""}>\u26AB\u{1F49B} Obsidian Gold</option>
                          <option value="black-ice" ${settings.gradientStyle === "black-ice" ? "selected" : ""}>\u26AB\u{1F499} Carbon Ice</option>
                          <option value="black-flame" ${settings.gradientStyle === "black-flame" ? "selected" : ""}>\u26AB\u{1F9E1} Inferno Black</option>
                          <option value="black-toxic" ${settings.gradientStyle === "black-toxic" ? "selected" : ""}>\u26AB\u2622\uFE0F Toxic Shadow</option>
                          <option value="black-pink" ${settings.gradientStyle === "black-pink" ? "selected" : ""}>\u26AB\u{1F497} Noir Pink</option>
                          <option value="black-matrix" ${settings.gradientStyle === "black-matrix" ? "selected" : ""}>\u26AB\u{1F7E2} Matrix Black</option>
                          <option value="black-sunset" ${settings.gradientStyle === "black-sunset" ? "selected" : ""}>\u26AB\u{1F305} Eclipse Sunset</option>
                          <option value="black-blood" ${settings.gradientStyle === "black-blood" ? "selected" : ""}>\u26AB\u{1FA78} Midnight Blood</option>
                          <option value="black-neon" ${settings.gradientStyle === "black-neon" ? "selected" : ""}>\u26AB\u26A1 Shadow Neon</option>
                          <option value="black-storm" ${settings.gradientStyle === "black-storm" ? "selected" : ""}>\u26AB\u26C8\uFE0F Obsidian Storm</option>
                          <option value="black-sapphire" ${settings.gradientStyle === "black-sapphire" ? "selected" : ""}>\u26AB\u{1F4A0} Void Sapphire</option>
                          <option value="black-aqua" ${settings.gradientStyle === "black-aqua" ? "selected" : ""}>\u26AB\u{1F30A} Dark Aqua</option>
                          <option value="black-phantom" ${settings.gradientStyle === "black-phantom" ? "selected" : ""}>\u26AB\u{1FA99} Phantom Silver</option>
                          <option value="black-violet" ${settings.gradientStyle === "black-violet" ? "selected" : ""}>\u26AB\u{1F49C} Deep Violet</option>
                          <option value="black-amber" ${settings.gradientStyle === "black-amber" ? "selected" : ""}>\u26AB\u{1F7E0} Shadow Amber</option>
                          <option value="black-jade" ${settings.gradientStyle === "black-jade" ? "selected" : ""}>\u26AB\u{1F7E2} Mystic Jade</option>
                          <option value="black-coral" ${settings.gradientStyle === "black-coral" ? "selected" : ""}>\u26AB\u{1FAB8} Dark Coral</option>
                          <option value="black-steel" ${settings.gradientStyle === "black-steel" ? "selected" : ""}>\u26AB\u{1F535} Carbon Steel</option>
                          <option value="black-lavender" ${settings.gradientStyle === "black-lavender" ? "selected" : ""}>\u26AB\u{1F49C} Void Lavender</option>
                          <option value="black-mint" ${settings.gradientStyle === "black-mint" ? "selected" : ""}>\u26AB\u{1F33F} Shadow Mint</option>
                          <option value="black-ruby" ${settings.gradientStyle === "black-ruby" ? "selected" : ""}>\u26AB\u{1F48E} Obsidian Ruby</option>
                          <option value="black-cobalt" ${settings.gradientStyle === "black-cobalt" ? "selected" : ""}>\u26AB\u{1F537} Deep Cobalt</option>
                          <option value="black-bronze" ${settings.gradientStyle === "black-bronze" ? "selected" : ""}>\u26AB\u{1F7E4} Dark Bronze</option>
                          <option value="black-teal" ${settings.gradientStyle === "black-teal" ? "selected" : ""}>\u26AB\u{1FA75} Shadow Teal</option>
                          <option value="black-magenta" ${settings.gradientStyle === "black-magenta" ? "selected" : ""}>\u26AB\u{1FA77} Void Magenta</option>
                          <option value="black-lime" ${settings.gradientStyle === "black-lime" ? "selected" : ""}>\u26AB\u{1F7E2} Electric Lime</option>
                          <option value="black-indigo" ${settings.gradientStyle === "black-indigo" ? "selected" : ""}>\u26AB\u{1F499} Midnight Indigo</option>
                      </optgroup>
                      <optgroup label="\u{1F308} Classic Themes">
                          <option value="blue-purple" ${settings.gradientStyle === "blue-purple" ? "selected" : ""}>\u{1F30C} Blue-Purple</option>
                          <option value="green-blue" ${settings.gradientStyle === "green-blue" ? "selected" : ""}>\u{1F30A} Green-Blue</option>
                          <option value="red-orange" ${settings.gradientStyle === "red-orange" ? "selected" : ""}>\u{1F525} Red-Orange</option>
                          <option value="purple-pink" ${settings.gradientStyle === "purple-pink" ? "selected" : ""}>\u{1F49C} Purple-Pink</option>
                          <option value="gold-yellow" ${settings.gradientStyle === "gold-yellow" ? "selected" : ""}>\u{1F451} Gold-Yellow</option>
                      </optgroup>
                      <optgroup label="\u2728 Vibrant Themes">
                          <option value="electric-neon" ${settings.gradientStyle === "electric-neon" ? "selected" : ""}>\u26A1 Electric Neon</option>
                          <option value="sunset-fire" ${settings.gradientStyle === "sunset-fire" ? "selected" : ""}>\u{1F305} Sunset Fire</option>
                          <option value="emerald-cyan" ${settings.gradientStyle === "emerald-cyan" ? "selected" : ""}>\u{1F48E} Emerald Cyan</option>
                          <option value="royal-gold" ${settings.gradientStyle === "royal-gold" ? "selected" : ""}>\u{1F3C6} Royal Gold</option>
                          <option value="crimson-blaze" ${settings.gradientStyle === "crimson-blaze" ? "selected" : ""}>\u{1F525} Crimson Blaze</option>
                          <option value="ocean-deep" ${settings.gradientStyle === "ocean-deep" ? "selected" : ""}>\u{1F30A} Ocean Deep</option>
                          <option value="forest-mystique" ${settings.gradientStyle === "forest-mystique" ? "selected" : ""}>\u{1F332} Forest Mystique</option>
                          <option value="cosmic-purple" ${settings.gradientStyle === "cosmic-purple" ? "selected" : ""}>\u{1F30C} Cosmic Purple</option>
                          <option value="rainbow-burst" ${settings.gradientStyle === "rainbow-burst" ? "selected" : ""}>\u{1F308} Rainbow Burst</option>
                      </optgroup>
                      <optgroup label="\u{1F6E1}\uFE0F Metallic Themes">
                          <option value="steel-blue" ${settings.gradientStyle === "steel-blue" ? "selected" : ""}>\u{1F6E1}\uFE0F Steel Blue</option>
                          <option value="chrome-silver" ${settings.gradientStyle === "chrome-silver" ? "selected" : ""}>\u26AA Chrome Silver</option>
                          <option value="titanium-gray" ${settings.gradientStyle === "titanium-gray" ? "selected" : ""}>\u{1F32B}\uFE0F Titanium Gray</option>
                          <option value="platinum-white" ${settings.gradientStyle === "platinum-white" ? "selected" : ""}>\u{1F48D} Platinum White</option>
                      </optgroup>
                  </select>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Effect Style
                  </label>
                  <select class="mga-select" id="effect-select">
                      <option value="none" ${settings.effectStyle === "none" ? "selected" : ""}>\u2728 None</option>
                      <option value="metallic" ${settings.effectStyle === "metallic" ? "selected" : ""}>\u26A1 Metallic</option>
                      <option value="glass" ${settings.effectStyle === "glass" ? "selected" : ""}>\u{1F48E} Glass</option>
                      <option value="neon" ${settings.effectStyle === "neon" ? "selected" : ""}>\u{1F31F} Neon Glow</option>
                      <option value="plasma" ${settings.effectStyle === "plasma" ? "selected" : ""}>\u{1F525} Plasma</option>
                      <option value="aurora" ${settings.effectStyle === "aurora" ? "selected" : ""}>\u{1F30C} Aurora</option>
                      <option value="crystal" ${settings.effectStyle === "crystal" ? "selected" : ""}>\u{1F4A0} Crystal</option>
                      <option value="steel" ${settings.effectStyle === "steel" ? "selected" : ""}>\u{1F6E1}\uFE0F Steel</option>
                      <option value="chrome" ${settings.effectStyle === "chrome" ? "selected" : ""}>\u26AA Chrome</option>
                      <option value="titanium" ${settings.effectStyle === "titanium" ? "selected" : ""}>\u{1F32B}\uFE0F Titanium</option>
                  </select>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Texture Overlay
                  </label>
                  <select class="mga-select" id="texture-select">
                      <option value="none" ${settings.textureStyle === "none" || !settings.textureStyle ? "selected" : ""}>\u{1F6AB} None</option>

                      <optgroup label="\u{1F31F} Modern Glass">
                          <option value="frosted-glass" ${settings.textureStyle === "frosted-glass" ? "selected" : ""}>\u2744\uFE0F Frosted Glass</option>
                          <option value="crystal-prism" ${settings.textureStyle === "crystal-prism" ? "selected" : ""}>\u{1F48E} Crystal Prism</option>
                          <option value="ice-frost" ${settings.textureStyle === "ice-frost" ? "selected" : ""}>\u{1F9CA} Ice Frost</option>
                          <option value="smoke-flow" ${settings.textureStyle === "smoke-flow" ? "selected" : ""}>\u{1F4A8} Smoke Flow</option>
                          <option value="water-ripple" ${settings.textureStyle === "water-ripple" ? "selected" : ""}>\u{1F30A} Water Ripple</option>
                      </optgroup>

                      <optgroup label="\u2699\uFE0F Premium Materials">
                          <option value="carbon-fiber-pro" ${settings.textureStyle === "carbon-fiber-pro" ? "selected" : ""}>\u{1F3C1} Carbon Fiber Pro</option>
                          <option value="brushed-aluminum" ${settings.textureStyle === "brushed-aluminum" ? "selected" : ""}>\u26AA Brushed Aluminum</option>
                          <option value="brushed-titanium" ${settings.textureStyle === "brushed-titanium" ? "selected" : ""}>\u26AB Brushed Titanium</option>
                          <option value="leather-grain" ${settings.textureStyle === "leather-grain" ? "selected" : ""}>\u{1F9F3} Leather Grain</option>
                          <option value="fabric-weave" ${settings.textureStyle === "fabric-weave" ? "selected" : ""}>\u{1F9F5} Fabric Weave</option>
                          <option value="wood-grain" ${settings.textureStyle === "wood-grain" ? "selected" : ""}>\u{1FAB5} Wood Grain</option>
                      </optgroup>

                      <optgroup label="\u26A1 Tech/Futuristic">
                          <option value="circuit-board" ${settings.textureStyle === "circuit-board" ? "selected" : ""}>\u{1F50C} Circuit Board</option>
                          <option value="hexagon-grid-pro" ${settings.textureStyle === "hexagon-grid-pro" ? "selected" : ""}>\u2B21 Hexagon Grid Pro</option>
                          <option value="hologram-scan" ${settings.textureStyle === "hologram-scan" ? "selected" : ""}>\u{1F4E1} Hologram Scan</option>
                          <option value="matrix-rain" ${settings.textureStyle === "matrix-rain" ? "selected" : ""}>\u{1F49A} Matrix Rain</option>
                          <option value="energy-waves" ${settings.textureStyle === "energy-waves" ? "selected" : ""}>\u26A1 Energy Waves</option>
                          <option value="cyberpunk-grid" ${settings.textureStyle === "cyberpunk-grid" ? "selected" : ""}>\u{1F537} Cyberpunk Grid</option>
                      </optgroup>

                      <optgroup label="\u{1F4D0} Geometric Clean">
                          <option value="dots-pro" ${settings.textureStyle === "dots-pro" ? "selected" : ""}>\u26AB Dots Professional</option>
                          <option value="grid-pro" ${settings.textureStyle === "grid-pro" ? "selected" : ""}>\u2B1C Grid Professional</option>
                          <option value="diagonal-pro" ${settings.textureStyle === "diagonal-pro" ? "selected" : ""}>\u{1F4D0} Diagonal Pro</option>
                          <option value="waves" ${settings.textureStyle === "waves" ? "selected" : ""}>\u3030\uFE0F Waves</option>
                          <option value="triangles" ${settings.textureStyle === "triangles" ? "selected" : ""}>\u{1F53A} Triangles</option>
                          <option value="crosshatch" ${settings.textureStyle === "crosshatch" ? "selected" : ""}>\u2716\uFE0F Crosshatch</option>
                      </optgroup>

                      <optgroup label="\u{1F3AA} Special Effects">
                          <option value="perlin-noise" ${settings.textureStyle === "perlin-noise" ? "selected" : ""}>\u{1F4FA} Perlin Noise</option>
                          <option value="gradient-mesh" ${settings.textureStyle === "gradient-mesh" ? "selected" : ""}>\u{1F308} Gradient Mesh</option>
                      </optgroup>
                  </select>
              </div>

              <!-- Texture Intensity Slider -->
              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                      <span>Texture Intensity</span>
                      <span id="texture-intensity-value" style="color: #4a9eff; font-weight: 600;">${settings.textureIntensity !== void 0 ? settings.textureIntensity : 75}%</span>
                  </label>
                  <input type="range" id="texture-intensity-slider" min="0" max="100" value="${settings.textureIntensity !== void 0 ? settings.textureIntensity : 75}"
                         style="width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(90deg, rgba(74, 158, 255, 0.48) 0%, rgba(74,158,255,0.8) 100%); outline: none; cursor: pointer;">
              </div>

              <!-- Texture Scale Control -->
              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Texture Scale
                  </label>
                  <div style="display: flex; gap: 8px;">
                      <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="small" style="flex: 1; ${settings.textureScale === "small" ? "background: #4a9eff; color: white;" : ""}">Small</button>
                      <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="medium" style="flex: 1; ${settings.textureScale === "medium" || !settings.textureScale ? "background: #4a9eff; color: white;" : ""}">Medium</button>
                      <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="large" style="flex: 1; ${settings.textureScale === "large" ? "background: #4a9eff; color: white;" : ""}">Large</button>
                  </div>
              </div>

              <!-- Blend Mode Selector -->
              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Blend Mode
                  </label>
                  <select class="mga-select" id="texture-blend-mode">
                      <option value="overlay" ${settings.textureBlendMode === "overlay" || !settings.textureBlendMode ? "selected" : ""}>Overlay (Balanced)</option>
                      <option value="multiply" ${settings.textureBlendMode === "multiply" ? "selected" : ""}>Multiply (Darken)</option>
                      <option value="screen" ${settings.textureBlendMode === "screen" ? "selected" : ""}>Screen (Lighten)</option>
                      <option value="soft-light" ${settings.textureBlendMode === "soft-light" ? "selected" : ""}>Soft Light (Subtle)</option>
                  </select>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">Quick Presets</div>
              <div class="mga-grid">
                  <button class="mga-btn mga-btn-sm" data-preset="gaming">\u{1F3AE} Gaming</button>
                  <button class="mga-btn mga-btn-sm" data-preset="minimal">\u26AA Minimal</button>
                  <button class="mga-btn mga-btn-sm" data-preset="vibrant">\u{1F308} Vibrant</button>
                  <button class="mga-btn mga-btn-sm" data-preset="dark">\u26AB Dark</button>
                  <button class="mga-btn mga-btn-sm" data-preset="luxury">\u2728 Luxury</button>
                  <button class="mga-btn mga-btn-sm" data-preset="steel">\u{1F6E1}\uFE0F Steel</button>
                  <button class="mga-btn mga-btn-sm" data-preset="chrome">\u26AA Chrome</button>
                  <button class="mga-btn mga-btn-sm" data-preset="titanium">\u{1F32B}\uFE0F Titanium</button>
                  <button class="mga-btn mga-btn-sm" data-preset="reset">\u{1F504} Reset</button>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">UI Mode</div>
              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="ultra-compact-checkbox" class="mga-checkbox"
                             ${settings.ultraCompactMode ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F4F1} Ultra-compact mode</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      Maximum space efficiency with condensed layouts and smaller text.
                  </p>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">Pet Interface</div>
              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="hide-feed-buttons-checkbox" class="mga-checkbox"
                             ${settings.hideFeedButtons ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F343} Hide instant feed buttons</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      Hide the 3 quick-feed buttons next to active pet avatars. Applies immediately without page reload.
                  </p>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">Pop-out Behavior</div>
              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="use-overlays-checkbox" class="mga-checkbox"
                             ${settings.useInGameOverlays ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F3AE} Use in-game overlays instead of separate windows</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      When enabled, tabs will open as draggable overlays within the game window instead of separate browser windows.
                  </p>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F6E1}\uFE0F Compatibility Mode</div>
              <div style="margin-bottom: 16px;">
                  <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px;
                              background: ${typeof CompatibilityMode2 !== "undefined" && CompatibilityMode2.flags.enabled ? "rgba(34, 197, 94, 0.30)" : "rgba(255, 255, 255, 0.05)"};
                              border: 1px solid ${typeof CompatibilityMode2 !== "undefined" && CompatibilityMode2.flags.enabled ? "rgba(34, 197, 94, 0.3)" : "rgba(255, 255, 255, 0.57)"};
                              border-radius: 8px; margin-bottom: 12px;">
                      <div>
                          <div style="font-weight: 600; margin-bottom: 4px;">
                              ${typeof CompatibilityMode2 !== "undefined" && CompatibilityMode2.flags.enabled ? "\u2705 Enabled" : "\u26AA Disabled"}
                          </div>
                          <div style="font-size: 11px; color: #aaa;">
                              ${typeof CompatibilityMode2 !== "undefined" && CompatibilityMode2.flags.enabled ? "Reason: " + (CompatibilityMode2.detectionReason || "manual") : "Auto-detects CSP restrictions"}
                          </div>
                      </div>
                      <button id="compat-toggle-btn" class="mga-btn mga-btn-sm"
                              style="padding: 8px 16px; font-size: 12px; min-width: 100px;">
                          ${typeof CompatibilityMode2 !== "undefined" && CompatibilityMode2.flags.enabled ? "Disable" : "Force Enable"}
                      </button>
                  </div>
                  <p style="font-size: 11px; color: #aaa; line-height: 1.6;">
                      <strong>What it does:</strong><br>
                      \u2022 Bypasses CSP restrictions for Discord/managed devices<br>
                      \u2022 Uses system fonts instead of Google Fonts<br>
                      \u2022 Forces WebSocket reconnection even when tab is hidden<br>
                      \u2022 Uses GM_xmlhttpRequest for external network requests<br>
                      <br>
                      <strong>When to use:</strong><br>
                      \u2022 Playing in Discord Activities<br>
                      \u2022 Work/school computers with strict security policies<br>
                      \u2022 Browser extensions or embeds<br>
                      <br>
                      <em style="opacity: 0.7;">Note: Changes require page refresh</em>
                  </p>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">Developer Options</div>
              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="debug-mode-checkbox" class="mga-checkbox"
                             ${settings.debugMode ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F41B} Enable Debug Mode</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      Shows detailed console logs for troubleshooting pet hunger, notifications, and more.
                  </p>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="room-debug-mode-checkbox" class="mga-checkbox"
                             ${settings.roomDebugMode ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F310} Enable Room Debug Mode</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      Shows detailed console logs for room API requests and player count fetching.
                  </p>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="hide-weather-checkbox" class="mga-checkbox"
                             ${settings.hideWeather ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F327}\uFE0F Hide Weather Effects</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      Hide visual weather effects like snow, rain, and other weather animations for better performance.
                  </p>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">Data Management</div>
              <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                  <button class="mga-btn mga-btn-sm" id="export-settings-btn">Export Settings</button>
                  <button class="mga-btn mga-btn-sm" id="import-settings-btn">Import Settings</button>
                  <button class="mga-btn mga-btn-sm" id="reset-loadouts-btn" style="background: #dc2626;">Reset Pet Loadouts</button>
                  <button class="mga-btn mga-btn-sm" id="clear-hotkeys-btn" style="background: #ea580c;">Clear All Hotkeys</button>
              </div>
              <p style="font-size: 11px; color: #aaa; margin-top: 4px;">
                  Reset button clears all saved pet loadouts. Clear hotkeys button removes all preset hotkey assignments.
              </p>
          </div>
      `;
  }
  function setupSettingsTabHandlers(dependencies = {}) {
    const {
      context = typeof document !== "undefined" ? document : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      CompatibilityMode: CompatibilityMode2 = typeof window !== "undefined" && window.CompatibilityMode,
      applyTheme = typeof window !== "undefined" && window.applyTheme,
      syncThemeToAllWindows = typeof window !== "undefined" && window.syncThemeToAllWindows,
      applyPreset = typeof window !== "undefined" && window.applyPreset,
      applyUltraCompactMode: applyUltraCompactMode2 = typeof window !== "undefined" && window.applyUltraCompactMode,
      applyWeatherSetting = typeof window !== "undefined" && window.applyWeatherSetting,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog ? window.productionLog : () => {
      },
      logInfo: logInfo3 = typeof window !== "undefined" && window.logInfo ? window.logInfo : () => {
      },
      targetDocument: targetDocument2 = typeof window !== "undefined" && typeof document !== "undefined" ? document : null,
      updateTabContent = typeof window !== "undefined" && window.updateTabContent,
      showNotificationToast: showNotificationToast2 = typeof window !== "undefined" && window.showNotificationToast,
      localStorage: storage = typeof window !== "undefined" && window.localStorage ? window.localStorage : null,
      window: win = typeof window !== "undefined" ? window : null,
      alert: alertFn = typeof window !== "undefined" && window.alert ? window.alert : () => {
      },
      confirm: confirmFn = typeof window !== "undefined" && window.confirm ? window.confirm : () => false,
      URL: URLClass = typeof window !== "undefined" && window.URL ? window.URL : null,
      Blob: BlobClass = typeof window !== "undefined" && window.Blob ? window.Blob : null,
      FileReader: FileReaderClass = typeof window !== "undefined" && window.FileReader ? window.FileReader : null,
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      }, error: () => {
      } }
    } = dependencies;
    consoleFn.log("\u{1F6A8} [CRITICAL-DEBUG] setupSettingsTabHandlers ENTERED");
    productionLog3("\u2699\uFE0F [SETTINGS] setupSettingsTabHandlers called", {
      context: context === (typeof document !== "undefined" ? document : null) ? "document" : "custom"
    });
    consoleFn.log(
      "\u{1F6A8} [CRITICAL-DEBUG] Context type:",
      context === (typeof document !== "undefined" ? document : null) ? "DOCUMENT" : "ELEMENT",
      context
    );
    const compatToggleBtn = context.querySelector("#compat-toggle-btn");
    if (compatToggleBtn && typeof CompatibilityMode2 !== "undefined") {
      compatToggleBtn.addEventListener("click", () => {
        if (CompatibilityMode2.flags.enabled) {
          CompatibilityMode2.disableCompat();
          logInfo3("COMPAT", "User disabled compatibility mode - reload required");
          alertFn("Compatibility Mode disabled. Please refresh the page for changes to take effect.");
        } else {
          try {
            storage.setItem("mgtools_compat_forced", "true");
            storage.removeItem("mgtools_compat_disabled");
            logInfo3("COMPAT", "User enabled compatibility mode - reload required");
            alertFn("Compatibility Mode enabled. Please refresh the page for changes to take effect.");
          } catch (e) {
            alertFn("Unable to save compatibility mode setting. Your browser may have storage restrictions.");
          }
        }
        if (confirmFn("Would you like to reload the page now?")) {
          win.location.reload();
        }
      });
    }
    const opacitySlider = context.querySelector("#opacity-slider");
    if (opacitySlider) {
      opacitySlider.addEventListener("input", (e) => {
        const opacity = parseInt(e.target.value);
        UnifiedState3.data.settings.opacity = opacity;
        applyTheme();
        const label = opacitySlider.previousElementSibling;
        label.textContent = `Main HUD Opacity: ${opacity}%`;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const popoutOpacitySlider = context.querySelector("#popout-opacity-slider");
    if (popoutOpacitySlider) {
      popoutOpacitySlider.addEventListener("input", (e) => {
        const popoutOpacity = parseInt(e.target.value);
        UnifiedState3.data.settings.popoutOpacity = popoutOpacity;
        syncThemeToAllWindows();
        const label = popoutOpacitySlider.previousElementSibling;
        label.textContent = `Pop-out Opacity: ${popoutOpacity}%`;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const gradientSelect = context.querySelector("#gradient-select");
    if (gradientSelect) {
      gradientSelect.addEventListener("change", (e) => {
        UnifiedState3.data.settings.gradientStyle = e.target.value;
        applyTheme();
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const effectSelect = context.querySelector("#effect-select");
    if (effectSelect) {
      effectSelect.addEventListener("change", (e) => {
        UnifiedState3.data.settings.effectStyle = e.target.value;
        applyTheme();
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const themePresetButtons = context.querySelectorAll("[data-preset]");
    themePresetButtons.forEach((btn) => {
      if (!btn.hasAttribute("data-handler-setup")) {
        btn.setAttribute("data-handler-setup", "true");
        btn.addEventListener("click", (e) => {
          const presetName = e.target.dataset.preset;
          applyPreset(presetName);
          applyTheme();
          MGA_saveJSON2("MGA_data", UnifiedState3.data);
          const opacitySlider2 = context.querySelector("#opacity-slider");
          if (opacitySlider2) {
            opacitySlider2.value = UnifiedState3.data.settings.opacity;
            const label = opacitySlider2.previousElementSibling;
            if (label) {
              label.textContent = `Main HUD Opacity: ${UnifiedState3.data.settings.opacity}%`;
            }
          }
          const gradientSelect2 = context.querySelector("#gradient-select");
          if (gradientSelect2) {
            gradientSelect2.value = UnifiedState3.data.settings.gradientStyle;
          }
          const effectSelect2 = context.querySelector("#effect-select");
          if (effectSelect2) {
            effectSelect2.value = UnifiedState3.data.settings.effectStyle;
          }
          productionLog3(`\u{1F3A8} Applied theme preset: ${presetName}`);
        });
      }
    });
    const textureSelect = context.querySelector("#texture-select");
    if (textureSelect) {
      textureSelect.addEventListener("change", (e) => {
        UnifiedState3.data.settings.textureStyle = e.target.value;
        applyTheme();
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const intensitySlider = context.querySelector("#texture-intensity-slider");
    const intensityValue = context.querySelector("#texture-intensity-value");
    if (intensitySlider && intensityValue) {
      intensitySlider.addEventListener("input", (e) => {
        const value = e.target.value;
        intensityValue.textContent = value + "%";
        UnifiedState3.data.settings.textureIntensity = parseInt(value);
        applyTheme();
      });
      intensitySlider.addEventListener("change", (e) => {
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const scaleButtons = context.querySelectorAll(".texture-scale-btn");
    if (scaleButtons.length > 0) {
      scaleButtons.forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const scale = e.target.dataset.scale;
          UnifiedState3.data.settings.textureScale = scale;
          scaleButtons.forEach((b) => {
            b.style.background = "";
            b.style.color = "";
          });
          e.target.style.background = "#4a9eff";
          e.target.style.color = "white";
          applyTheme();
          MGA_saveJSON2("MGA_data", UnifiedState3.data);
        });
      });
    }
    const blendModeSelect = context.querySelector("#texture-blend-mode");
    if (blendModeSelect) {
      blendModeSelect.addEventListener("change", (e) => {
        UnifiedState3.data.settings.textureBlendMode = e.target.value;
        applyTheme();
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const ultraCompactCheckbox = context.querySelector("#ultra-compact-checkbox");
    if (ultraCompactCheckbox) {
      const newCheckbox = ultraCompactCheckbox.cloneNode(true);
      ultraCompactCheckbox.parentNode.replaceChild(newCheckbox, ultraCompactCheckbox);
      newCheckbox.addEventListener("change", (e) => {
        e.stopPropagation();
        UnifiedState3.data.settings.ultraCompactMode = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        applyUltraCompactMode2(e.target.checked);
        productionLog3(`\u{1F4F1} Ultra-compact mode ${e.target.checked ? "enabled" : "disabled"}`);
      });
    }
    const hideFeedButtonsCheckbox = context.querySelector("#hide-feed-buttons-checkbox");
    if (hideFeedButtonsCheckbox) {
      hideFeedButtonsCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.hideFeedButtons = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        const allFeedButtons = targetDocument2.querySelectorAll(".mgtools-instant-feed-btn");
        allFeedButtons.forEach((btn) => {
          btn.style.setProperty("display", e.target.checked ? "none" : "block", "important");
        });
        consoleFn.log(`[MGTOOLS-FIX-B] Feed buttons ${e.target.checked ? "hidden" : "shown"}`);
        productionLog3(`\u{1F343} Instant feed buttons ${e.target.checked ? "hidden" : "shown"}`);
      });
    }
    const overlayCheckbox = context.querySelector("#use-overlays-checkbox");
    if (overlayCheckbox) {
      overlayCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.useInGameOverlays = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u{1F3AE} Overlay mode ${e.target.checked ? "enabled" : "disabled"}`);
      });
    }
    const debugModeCheckbox = context.querySelector("#debug-mode-checkbox");
    if (debugModeCheckbox) {
      debugModeCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.debugMode = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u{1F41B} Debug mode ${e.target.checked ? "enabled" : "disabled"}`);
      });
    }
    const roomDebugModeCheckbox = context.querySelector("#room-debug-mode-checkbox");
    if (roomDebugModeCheckbox) {
      roomDebugModeCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.roomDebugMode = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        consoleFn.log(`[MGTools] Room debug mode ${e.target.checked ? "enabled" : "disabled"}`);
      });
    }
    context.querySelectorAll("[data-preset]").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const preset = e.target.dataset.preset;
        applyPreset(preset);
      });
    });
    const exportBtn = context.querySelector("#export-settings-btn");
    if (exportBtn) {
      exportBtn.addEventListener("click", () => {
        const data = JSON.stringify(UnifiedState3.data, null, 2);
        const blob = new BlobClass([data], { type: "application/json" });
        const link = targetDocument2.createElement("a");
        link.href = URLClass.createObjectURL(blob);
        link.download = "MGA_Settings.json";
        link.click();
      });
    }
    const importBtn = context.querySelector("#import-settings-btn");
    if (importBtn) {
      importBtn.addEventListener("click", () => {
        const fileInput = targetDocument2.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".json";
        fileInput.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReaderClass();
          reader.onload = (event) => {
            try {
              const importedData = JSON.parse(event.target.result);
              if (typeof importedData !== "object" || importedData === null) {
                throw new Error("Invalid data format");
              }
              UnifiedState3.data = { ...UnifiedState3.data, ...importedData };
              MGA_saveJSON2("MGA_data", UnifiedState3.data);
              applyTheme();
              if (UnifiedState3.data.settings.ultraCompactMode) {
                applyUltraCompactMode2(true);
              }
              productionLog3("\u2705 Settings imported successfully!");
              showNotificationToast2("\u2705 Settings imported and applied!", "success");
              if (UnifiedState3.activeTab === "settings") {
                updateTabContent();
              }
            } catch (error) {
              consoleFn.error("Failed to import settings:", error);
              showNotificationToast2("\u274C Failed to import settings. Invalid file format.", "error");
            }
          };
          reader.readAsText(file);
        });
        fileInput.click();
      });
    }
    const resetLoadoutsBtn = context.querySelector("#reset-loadouts-btn");
    if (resetLoadoutsBtn) {
      resetLoadoutsBtn.addEventListener("click", () => {
        if (confirmFn("Are you sure you want to reset all pet loadouts? This cannot be undone.")) {
          UnifiedState3.data.petPresets = {};
          UnifiedState3.data.petPresetHotkeys = {};
          UnifiedState3.data.petPresetsOrder = [];
          MGA_saveJSON2("MGA_petPresets", UnifiedState3.data.petPresets);
          MGA_saveJSON2("MGA_petPresetHotkeys", UnifiedState3.data.petPresetHotkeys);
          MGA_saveJSON2("MGA_petPresetsOrder", UnifiedState3.data.petPresetsOrder);
          productionLog3("[SETTINGS] Pet loadouts and hotkeys have been reset");
          if (UnifiedState3.activeTab === "pets") {
            updateTabContent();
          }
          productionLog3("[SETTINGS] Pet loadouts have been reset successfully");
        }
      });
    }
    const clearHotkeysBtn = context.querySelector("#clear-hotkeys-btn");
    if (clearHotkeysBtn) {
      clearHotkeysBtn.addEventListener("click", () => {
        if (confirmFn("Clear all pet preset hotkeys? This will not delete your presets, only the hotkey assignments.")) {
          UnifiedState3.data.petPresetHotkeys = {};
          MGA_saveJSON2("MGA_petPresetHotkeys", UnifiedState3.data.petPresetHotkeys);
          productionLog3("[SETTINGS] All pet preset hotkeys cleared");
          if (UnifiedState3.activeTab === "pets") {
            updateTabContent();
          }
          alertFn("All pet preset hotkeys have been cleared. You can now assign new hotkeys without conflicts.");
        }
      });
    }
    const weatherCheckbox = context.querySelector("#hide-weather-checkbox");
    if (weatherCheckbox && !weatherCheckbox.hasAttribute("data-handler-setup")) {
      weatherCheckbox.setAttribute("data-handler-setup", "true");
      try {
        weatherCheckbox.checked = !!(UnifiedState3 && UnifiedState3.data && UnifiedState3.data.settings && UnifiedState3.data.settings.hideWeather);
      } catch (_) {
      }
      const cloned = weatherCheckbox.cloneNode(true);
      weatherCheckbox.parentNode.replaceChild(cloned, weatherCheckbox);
      cloned.addEventListener("change", (e) => {
        if (!UnifiedState3 || !UnifiedState3.data || !UnifiedState3.data.settings) return;
        UnifiedState3.data.settings.hideWeather = !!e.target.checked;
        try {
          MGA_saveJSON2("MGA_data", UnifiedState3.data);
        } catch (err) {
          consoleFn.error("Weather save failed:", err);
        }
        try {
          applyWeatherSetting();
        } catch (err) {
          consoleFn.error("applyWeatherSetting failed:", err);
        }
        productionLog3(`\u{1F327}\uFE0F [WEATHER] Toggle set to ${e.target.checked ? "HIDE" : "SHOW"}`);
      });
    }
  }

  // src/features/notifications.js
  var notifications_exports = {};
  __export(notifications_exports, {
    default: () => notifications_default,
    dismissAllNotifications: () => dismissAllNotifications,
    generateNotificationListHTML: () => generateNotificationListHTML,
    getNotificationsTabContent: () => getNotificationsTabContent,
    getTimeSinceLastSeen: () => getTimeSinceLastSeen,
    isWatchedItem: () => isWatchedItem,
    normalizeSpeciesName: () => normalizeSpeciesName,
    playAlarmNotification: () => playAlarmNotification,
    playAlertNotification: () => playAlertNotification,
    playBuzzNotification: () => playBuzzNotification,
    playChimeNotification: () => playChimeNotification,
    playChirpNotification: () => playChirpNotification,
    playCustomOrDefaultSound: () => playCustomOrDefaultSound,
    playDingNotification: () => playDingNotification,
    playDoubleBeepNotification: () => playDoubleBeepNotification,
    playEpicNotification: () => playEpicNotification,
    playGeneralNotificationSound: () => playGeneralNotificationSound,
    playNotificationSound: () => playNotificationSound,
    playSelectedNotification: () => playSelectedNotification,
    playShopNotificationSound: () => playShopNotificationSound,
    playSingleBeepNotification: () => playSingleBeepNotification,
    playTripleBeepNotification: () => playTripleBeepNotification,
    playWeatherNotificationSound: () => playWeatherNotificationSound,
    queueNotification: () => queueNotification,
    setupNotificationsTabHandlers: () => setupNotificationsTabHandlers,
    showBatchedNotificationModal: () => showBatchedNotificationModal,
    showNotificationToast: () => showNotificationToast,
    showVisualNotification: () => showVisualNotification,
    startContinuousAlarm: () => startContinuousAlarm,
    stopContinuousAlarm: () => stopContinuousAlarm,
    updateLastSeen: () => updateLastSeen,
    updateNotificationModal: () => updateNotificationModal
  });
  function playNotificationSound(frequency = 800, duration = 200, volume = 0.3, dependencies = {}) {
    const {
      getAudioContext = () => new (window.AudioContext || window.webkitAudioContext)(),
      productionLog: productionLog3 = console.log
    } = dependencies;
    try {
      const audioContext = getAudioContext();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.value = frequency;
      oscillator.type = "sine";
      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1e3);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration / 1e3);
      productionLog3(`\u{1F50A} [NOTIFICATIONS] Sound played for rare item!`);
    } catch (error) {
      console.error("\u274C [NOTIFICATIONS] Failed to play notification sound:", error);
    }
  }
  function playTripleBeepNotification(volume = 0.3, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    playSoundFn(1e3, 250, volume, dependencies);
    setTimeout(() => playSoundFn(1e3, 200, volume * 0.8, dependencies), 300);
    setTimeout(() => playSoundFn(1200, 150, volume * 0.6, dependencies), 600);
  }
  function playDoubleBeepNotification(volume = 0.3, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    playSoundFn(600, 200, volume, dependencies);
    setTimeout(() => playSoundFn(600, 200, volume * 0.9, dependencies), 250);
  }
  function playSingleBeepNotification(volume = 0.2, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    playSoundFn(500, 150, volume, dependencies);
  }
  function playChimeNotification(volume = 0.2, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    playSoundFn(500, 100, volume, dependencies);
    setTimeout(() => playSoundFn(800, 100, volume * 0.9, dependencies), 120);
    setTimeout(() => playSoundFn(1e3, 120, volume * 0.8, dependencies), 240);
  }
  function playAlertNotification(volume = 0.2, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    playSoundFn(1200, 150, volume, dependencies);
    setTimeout(() => playSoundFn(900, 150, volume * 0.9, dependencies), 160);
  }
  function playBuzzNotification(volume = 0.2, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    for (let i = 0; i < 8; i++) {
      setTimeout(() => playSoundFn(300, 40, volume * (i % 2 === 0 ? 1 : 0.6), dependencies), i * 50);
    }
  }
  function playDingNotification(volume = 0.2, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    playSoundFn(2e3, 180, volume, dependencies);
  }
  function playChirpNotification(volume = 0.2, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    playSoundFn(400, 80, volume, dependencies);
    setTimeout(() => playSoundFn(800, 60, volume * 0.8, dependencies), 85);
    setTimeout(() => playSoundFn(1200, 40, volume * 0.6, dependencies), 150);
  }
  function playAlarmNotification(volume = 0.5, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    let count = 0;
    const interval = setInterval(() => {
      playSoundFn(count % 2 === 0 ? 1500 : 800, 400, volume, dependencies);
      count++;
      if (count >= 6) clearInterval(interval);
    }, 450);
  }
  var continuousAlarmInterval = null;
  function startContinuousAlarm(volume = 0.4, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound, productionLog: productionLog3 = console.log } = dependencies;
    if (continuousAlarmInterval) return;
    let tone = 800;
    continuousAlarmInterval = setInterval(() => {
      tone = tone === 800 ? 1200 : 800;
      playSoundFn(tone, 300, volume, dependencies);
    }, 350);
    productionLog3("\u{1F6A8} [NOTIFICATIONS] Continuous alarm started - requires acknowledgment!");
  }
  function stopContinuousAlarm(dependencies = {}) {
    const { productionLog: productionLog3 = console.log } = dependencies;
    if (continuousAlarmInterval) {
      clearInterval(continuousAlarmInterval);
      continuousAlarmInterval = null;
      productionLog3("\u2705 [NOTIFICATIONS] Continuous alarm stopped");
    }
  }
  function playEpicNotification(volume = 0.4, dependencies = {}) {
    const { playNotificationSound: playSoundFn = playNotificationSound } = dependencies;
    const sequence = [
      [400, 100],
      [500, 100],
      [600, 100],
      [800, 150],
      [1e3, 200],
      [1200, 150],
      [1e3, 150],
      [1200, 200],
      [1500, 300],
      [1200, 100],
      [1500, 400]
    ];
    let delay = 0;
    sequence.forEach(([freq, dur]) => {
      setTimeout(() => playSoundFn(freq, dur, volume, dependencies), delay);
      delay += dur + 50;
    });
  }
  function playSelectedNotification(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      productionLog: productionLog3 = console.log,
      playNotificationSound: playSoundFn = playNotificationSound,
      playTripleBeepNotification: playTripleFn = playTripleBeepNotification,
      playAlarmNotification: playAlarmFn = playAlarmNotification,
      playEpicNotification: playEpicFn = playEpicNotification,
      startContinuousAlarm: startContinuousFn = startContinuousAlarm
    } = dependencies;
    const notifications = UnifiedState3.data.settings.notifications;
    const volume = notifications.volume || 0.3;
    const type = notifications.notificationType || "triple";
    productionLog3(`\u{1F50A} [NOTIFICATIONS] Playing ${type} notification at ${Math.round(volume * 100)}% volume`);
    switch (type) {
      case "simple":
        playSoundFn(1e3, 300, volume, dependencies);
        break;
      case "triple":
        playTripleFn(volume, dependencies);
        break;
      case "alarm":
        playAlarmFn(volume, dependencies);
        break;
      case "epic":
        playEpicFn(volume, dependencies);
        break;
      case "continuous":
        startContinuousFn(volume, dependencies);
        break;
      default:
        playTripleFn(volume, dependencies);
    }
  }
  function playCustomOrDefaultSound(soundType, defaultPlayFunc, volume, dependencies = {}) {
    const {
      GM_getValue: GM_getValue2 = typeof window !== "undefined" && window.GM_getValue,
      startContinuousAlarm: startContinuousFn = startContinuousAlarm,
      productionLog: productionLog3 = console.log,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState
    } = dependencies;
    const customSound = GM_getValue2(`mgtools_custom_sound_${soundType}`, null);
    if (customSound) {
      const notificationType = UnifiedState3.data.settings.notifications.notificationType;
      if (notificationType === "continuous") {
        productionLog3(`\u{1F3B5} [CUSTOM-SOUND] Continuous mode active - using alarm instead of custom ${soundType} sound`);
        startContinuousFn(volume, dependencies);
        return;
      }
      try {
        const audio = new Audio(customSound);
        audio.volume = volume || 0.3;
        audio.play();
        productionLog3(`\u{1F3B5} [CUSTOM-SOUND] Playing custom ${soundType} sound`);
      } catch (err) {
        console.error(`Failed to play custom ${soundType} sound:`, err);
        defaultPlayFunc(volume);
      }
    } else {
      defaultPlayFunc(volume);
    }
  }
  function playGeneralNotificationSound(volume, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      playNotificationSound: playSoundFn = playNotificationSound,
      playTripleBeepNotification: playTripleFn = playTripleBeepNotification,
      playAlarmNotification: playAlarmFn = playAlarmNotification,
      playEpicNotification: playEpicFn = playEpicNotification,
      startContinuousAlarm: startContinuousFn = startContinuousAlarm
    } = dependencies;
    const type = UnifiedState3.data.settings.notifications.notificationType || "epic";
    switch (type) {
      case "simple":
        playSoundFn(1e3, 300, volume, dependencies);
        break;
      case "triple":
        playTripleFn(volume, dependencies);
        break;
      case "alarm":
        playAlarmFn(volume, dependencies);
        break;
      case "epic":
        playEpicFn(volume, dependencies);
        break;
      case "continuous":
        startContinuousFn(volume, dependencies);
        break;
      default:
        playEpicFn(volume, dependencies);
    }
  }
  function playShopNotificationSound(volume, dependencies = {}) {
    const {
      playCustomOrDefaultSound: playCustomFn = playCustomOrDefaultSound,
      playGeneralNotificationSound: playGeneralFn = playGeneralNotificationSound
    } = dependencies;
    playCustomFn("shop", playGeneralFn, volume, dependencies);
  }
  function playWeatherNotificationSound(volume, dependencies = {}) {
    const {
      playCustomOrDefaultSound: playCustomFn = playCustomOrDefaultSound,
      playGeneralNotificationSound: playGeneralFn = playGeneralNotificationSound
    } = dependencies;
    playCustomFn("weather", playGeneralFn, volume, dependencies);
  }
  var notificationQueue = [];
  var currentNotificationModal = null;
  var notificationQueueTimer = null;
  var NOTIFICATION_BATCH_DELAY = 2e3;
  function queueNotification(message, requiresAcknowledgment = false, dependencies = {}) {
    const {
      updateNotificationModal: updateModalFn = updateNotificationModal,
      showBatchedNotificationModal: showBatchedFn = showBatchedNotificationModal
    } = dependencies;
    notificationQueue.push({ message, requiresAcknowledgment, timestamp: Date.now() });
    if (notificationQueueTimer) {
      clearTimeout(notificationQueueTimer);
    }
    if (currentNotificationModal) {
      updateModalFn(dependencies);
      return;
    }
    notificationQueueTimer = setTimeout(() => {
      showBatchedFn(dependencies);
    }, NOTIFICATION_BATCH_DELAY);
  }
  function updateNotificationModal(dependencies = {}) {
    const { generateNotificationListHTML: generateListFn = generateNotificationListHTML } = dependencies;
    if (!currentNotificationModal) return;
    const messageContainer = currentNotificationModal.querySelector(".notification-messages");
    if (messageContainer) {
      messageContainer.innerHTML = generateListFn();
    }
    const countDisplay = currentNotificationModal.querySelector(".notification-count");
    if (countDisplay) {
      countDisplay.textContent = `${notificationQueue.length} Notification${notificationQueue.length > 1 ? "s" : ""}`;
    }
  }
  function generateNotificationListHTML() {
    return notificationQueue.map(
      (notif) => `
      <div style="margin-bottom: 10px; padding: 10px; background: rgba(255, 255, 255, 0.57); border-radius: 5px; border-left: 3px solid #fff;">
          <div style="font-size: 14px; margin-bottom: 5px;">${notif.message}</div>
          <div style="font-size: 10px; opacity: 0.8;">${new Date(notif.timestamp).toLocaleTimeString()}</div>
      </div>
  `
    ).join("");
  }
  function showBatchedNotificationModal(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      showVisualNotification: showVisualFn = showVisualNotification,
      generateNotificationListHTML: generateListFn = generateNotificationListHTML,
      dismissAllNotifications: dismissAllFn = dismissAllNotifications
    } = dependencies;
    if (notificationQueue.length === 0) return;
    if (currentNotificationModal) {
      dismissAllFn(dependencies);
      setTimeout(() => showBatchedNotificationModal(dependencies), 350);
      return;
    }
    const hasAcknowledgmentRequired = notificationQueue.some((n) => n.requiresAcknowledgment);
    if (notificationQueue.length === 1 && !hasAcknowledgmentRequired) {
      const notif = notificationQueue[0];
      showVisualFn(notif.message, notif.requiresAcknowledgment, dependencies);
      notificationQueue = [];
      return;
    }
    if (!hasAcknowledgmentRequired) {
      notificationQueue.forEach((notif) => {
        showVisualFn(notif.message, false, dependencies);
      });
      notificationQueue = [];
      return;
    }
    const notification = targetDocument2.createElement("div");
    notification.className = "mga-batched-notification";
    notification.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #ff6b6b 0%, #ff0000 100%);
      color: white;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 20px 60px rgba(255,0,0,0.4), 0 0 100px rgba(255, 0, 0, 0.48);
      z-index: 9999999;
      font-weight: bold;
      animation: mga-modal-entrance 0.5s ease-out;
      border: 3px solid #ffffff;
      text-align: center;
      max-width: 500px;
      max-height: 400px;
      overflow-y: auto;
  `;
    notification.innerHTML = `
      <div class="notification-count" style="font-size: 20px; margin-bottom: 15px;">
          ${notificationQueue.length} Notification${notificationQueue.length > 1 ? "s" : ""}
      </div>
      <div class="notification-messages" style="text-align: left; margin-bottom: 20px; max-height: 200px; overflow-y: auto;">
          ${generateListFn()}
      </div>
      <button class="acknowledge-all-btn" style="
          background: white;
          color: #ff0000;
          border: none;
          padding: 12px 24px;
          border-radius: 5px;
          font-weight: bold;
          font-size: 16px;
          cursor: pointer;
          box-shadow: 0 4px 10px rgba(0,0,0,0.3);
          transition: all 0.2s;
      ">
          ACKNOWLEDGE ALL (${notificationQueue.length})
      </button>
  `;
    const ackButton = notification.querySelector(".acknowledge-all-btn");
    ackButton.onmouseover = () => {
      ackButton.style.transform = "scale(1.05)";
      ackButton.style.boxShadow = "0 6px 15px rgba(0,0,0,0.4)";
    };
    ackButton.onmouseout = () => {
      ackButton.style.transform = "scale(1)";
      ackButton.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
    };
    ackButton.onclick = () => {
      dismissAllFn(dependencies);
    };
    const backdrop = targetDocument2.createElement("div");
    backdrop.className = "mga-notification-backdrop";
    backdrop.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999998;
      animation: fadeIn 0.3s ease-in;
  `;
    backdrop.onclick = () => {
      backdrop.style.animation = "flash 0.3s ease-in-out";
    };
    targetDocument2.body.appendChild(backdrop);
    targetDocument2.body.appendChild(notification);
    currentNotificationModal = notification;
  }
  function dismissAllNotifications(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      stopContinuousAlarm: stopAlarmFn = stopContinuousAlarm
    } = dependencies;
    stopAlarmFn(dependencies);
    if (currentNotificationModal) {
      const backdrop = targetDocument2.querySelector(".mga-notification-backdrop");
      currentNotificationModal.style.animation = "fadeOut 0.3s ease-out";
      if (backdrop) backdrop.style.animation = "fadeOut 0.3s ease-out";
      setTimeout(() => {
        if (currentNotificationModal) currentNotificationModal.remove();
        if (backdrop) backdrop.remove();
        currentNotificationModal = null;
      }, 300);
    }
    notificationQueue = [];
    if (notificationQueueTimer) {
      clearTimeout(notificationQueueTimer);
      notificationQueueTimer = null;
    }
  }
  function showVisualNotification(message, requiresAcknowledgment = false, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      stopContinuousAlarm: stopAlarmFn = stopContinuousAlarm,
      dismissAllNotifications: dismissAllFn = dismissAllNotifications
    } = dependencies;
    if (requiresAcknowledgment && currentNotificationModal) {
      dismissAllFn(dependencies);
      setTimeout(() => showVisualNotification(message, requiresAcknowledgment, dependencies), 350);
      return;
    }
    const notification = targetDocument2.createElement("div");
    if (requiresAcknowledgment) {
      notification.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: linear-gradient(135deg, #ff6b6b 0%, #ff0000 100%);
          color: white;
          padding: 30px;
          border-radius: 15px;
          box-shadow: 0 20px 60px rgba(255,0,0,0.4), 0 0 100px rgba(255, 0, 0, 0.48);
          z-index: 9999999;
          font-weight: bold;
          font-size: 20px;
          animation: mga-modal-entrance 0.5s ease-out;
          border: 3px solid #ffffff;
          text-align: center;
          min-width: 400px;
      `;
      const messageDiv = targetDocument2.createElement("div");
      messageDiv.textContent = message;
      messageDiv.style.marginBottom = "20px";
      notification.appendChild(messageDiv);
      const ackButton = targetDocument2.createElement("button");
      ackButton.textContent = "ACKNOWLEDGE (Stop Alarm)";
      ackButton.style.cssText = `
          background: white;
          color: #ff0000;
          border: none;
          padding: 10px 20px;
          border-radius: 5px;
          font-weight: bold;
          font-size: 16px;
          cursor: pointer;
          box-shadow: 0 4px 10px rgba(0,0,0,0.3);
          transition: all 0.2s;
      `;
      ackButton.onmouseover = () => {
        ackButton.style.transform = "scale(1.05)";
        ackButton.style.boxShadow = "0 6px 15px rgba(0,0,0,0.4)";
      };
      ackButton.onmouseout = () => {
        ackButton.style.transform = "scale(1)";
        ackButton.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
      };
      ackButton.onclick = () => {
        stopAlarmFn(dependencies);
        notification.style.animation = "fadeOut 0.3s ease-out";
        setTimeout(() => notification.remove(), 300);
      };
      notification.appendChild(ackButton);
      const backdrop = targetDocument2.createElement("div");
      backdrop.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.7);
          z-index: 9999998;
          animation: fadeIn 0.3s ease-in;
      `;
      backdrop.onclick = () => {
        backdrop.style.animation = "flash 0.3s ease-in-out";
      };
      targetDocument2.body.appendChild(backdrop);
      targetDocument2.body.appendChild(notification);
      currentNotificationModal = notification;
      ackButton.onclick = () => {
        stopAlarmFn(dependencies);
        notification.style.animation = "fadeOut 0.3s ease-out";
        backdrop.style.animation = "fadeOut 0.3s ease-out";
        setTimeout(() => {
          notification.remove();
          backdrop.remove();
          currentNotificationModal = null;
        }, 300);
      };
    } else {
      notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          padding: 15px 20px;
          border-radius: 10px;
          box-shadow: 0 10px 30px rgba(0,0,0,0.3);
          z-index: 999999;
          font-weight: bold;
          font-size: 16px;
          animation: slideInRight 0.5s ease-out;
          border: 2px solid rgba(255,255,255,0.3);
      `;
      notification.textContent = message;
      setTimeout(() => {
        notification.style.animation = "slideOutRight 0.5s ease-out";
        setTimeout(() => notification.remove(), 500);
      }, 5e3);
    }
    if (!targetDocument2.getElementById("mga-notification-animations")) {
      const style = targetDocument2.createElement("style");
      style.id = "mga-notification-animations";
      style.textContent = `
          @keyframes slideInRight {
              from { transform: translateX(100%); opacity: 0; }
              to { transform: translateX(0); opacity: 1; }
          }
          @keyframes slideOutRight {
              from { transform: translateX(0); opacity: 1; }
              to { transform: translateX(100%); opacity: 0; }
          }
          @keyframes mga-notification-pulse {
              from { transform: translate(-50%, -50%) scale(1); }
              to { transform: translate(-50%, -50%) scale(1.05); }
          }
          @keyframes mga-modal-entrance {
              from {
                  opacity: 0;
                  transform: translate(-50%, -50%) scale(0.8);
              }
              to {
                  opacity: 1;
                  transform: translate(-50%, -50%) scale(1);
              }
          }
          @keyframes fadeIn {
              from { opacity: 0; }
              to { opacity: 1; }
          }
          @keyframes fadeOut {
              from { opacity: 1; }
              to { opacity: 0; }
          }
          @keyframes flash {
              0%, 100% { background: rgba(0, 0, 0, 0.7); }
              50% { background: rgba(255, 0, 0, 0.3); }
          }
      `;
      targetDocument2.head.appendChild(style);
    }
    targetDocument2.body.appendChild(notification);
  }
  function normalizeSpeciesName(name) {
    if (!name || typeof name !== "string") return "";
    return name.trim().toLowerCase();
  }
  function isWatchedItem(itemId, type = "seed", dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      normalizeSpeciesName: normalizeFn = normalizeSpeciesName
    } = dependencies;
    const notifications = UnifiedState3.data.settings.notifications;
    if (type === "seed") {
      const nameMap = {
        DawnCelestial: "Dawnbinder",
        MoonCelestial: "Moonbinder"
      };
      const checkId = nameMap[itemId] || itemId;
      const normalizedItemId = normalizeFn(checkId);
      return notifications.watchedSeeds.some((watched) => normalizeFn(watched) === normalizedItemId);
    } else if (type === "egg") {
      return notifications.watchedEggs.includes(itemId);
    }
    return false;
  }
  function updateLastSeen(itemId, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      productionLog: productionLog3 = console.log
    } = dependencies;
    const notifications = UnifiedState3.data.settings.notifications;
    notifications.lastSeenTimestamps[itemId] = Date.now();
    MGA_saveJSON2("MGA_data", UnifiedState3.data);
    productionLog3(`\u{1F4C5} [NOTIFICATIONS] Updated last seen for ${itemId}`);
  }
  function getTimeSinceLastSeen(itemId, dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const notifications = UnifiedState3.data.settings.notifications;
    const reverseNameMap = {
      Moonbinder: "MoonCelestial",
      Dawnbinder: "DawnCelestial"
    };
    const lookupId = reverseNameMap[itemId] || itemId;
    const timestamp = notifications.lastSeenTimestamps[lookupId];
    if (!timestamp) return "Never seen";
    const diff = Date.now() - timestamp;
    const hours = Math.floor(diff / (1e3 * 60 * 60));
    const days = Math.floor(hours / 24);
    if (days > 0) return `${days} day${days > 1 ? "s" : ""} ago`;
    if (hours > 0) return `${hours} hour${hours > 1 ? "s" : ""} ago`;
    const minutes = Math.floor(diff / (1e3 * 60));
    return `${minutes} minute${minutes > 1 ? "s" : ""} ago`;
  }
  function showNotificationToast(message, type = "info", dependencies = {}) {
    const { targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null } = dependencies;
    try {
      const toast2 = targetDocument2.createElement("div");
      toast2.textContent = message;
      toast2.style.cssText = `
          position: fixed;
          top: 80px;
          right: 20px;
          padding: 12px 20px;
          background: ${type === "warning" ? "rgba(255, 165, 0, 0.9)" : type === "success" ? "rgba(76, 175, 80, 0.9)" : "rgba(33, 150, 243, 0.9)"};
          color: white;
          border-radius: 8px;
          font-size: 14px;
          font-weight: bold;
          z-index: 2147483647;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          max-width: 300px;
          word-wrap: break-word;
          transition: opacity 0.3s ease;
      `;
      targetDocument2.body.appendChild(toast2);
      setTimeout(() => {
        toast2.style.opacity = "0";
        setTimeout(() => toast2.remove(), 300);
      }, 5e3);
    } catch (error) {
      console.error("\u274C [TOAST] Error showing notification toast:", error);
    }
  }
  function getNotificationsTabContent(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      DECOR_ITEMS = typeof window !== "undefined" && window.DECOR_ITEMS ? window.DECOR_ITEMS : []
    } = dependencies;
    const settings = UnifiedState3.data.settings;
    if (!settings.notifications.petHungerEnabled && settings.notifications.petHungerEnabled !== false) {
      settings.notifications.petHungerEnabled = false;
    }
    if (!settings.notifications.petHungerThreshold) {
      settings.notifications.petHungerThreshold = 20;
    }
    if (!settings.notifications.abilityNotificationsEnabled && settings.notifications.abilityNotificationsEnabled !== false) {
      settings.notifications.abilityNotificationsEnabled = false;
    }
    if (!settings.notifications.watchedAbilities) {
      settings.notifications.watchedAbilities = [];
    }
    if (!settings.notifications.watchedAbilityCategories) {
      settings.notifications.watchedAbilityCategories = {
        xpBoost: true,
        cropSizeBoost: true,
        selling: true,
        harvesting: true,
        growthSpeed: true,
        specialMutations: true,
        other: true
      };
    }
    if (!settings.notifications.weatherNotificationsEnabled && settings.notifications.weatherNotificationsEnabled !== false) {
      settings.notifications.weatherNotificationsEnabled = false;
    }
    if (!settings.notifications.watchedDecor) {
      settings.notifications.watchedDecor = [];
    }
    if (!settings.notifications.watchedWeatherEvents) {
      settings.notifications.watchedWeatherEvents = ["Snow", "Rain", "AmberMoon", "Dawn"];
    }
    if (!settings.notifications.abilityNotificationSound) {
      settings.notifications.abilityNotificationSound = "single";
    }
    if (settings.notifications.abilityNotificationVolume === void 0) {
      settings.notifications.abilityNotificationVolume = 0.2;
    }
    if (settings.notifications.continuousEnabled === void 0 || settings.notifications.continuousEnabled === null) {
      settings.notifications.continuousEnabled = false;
    }
    if (settings.debugMode === void 0) {
      settings.debugMode = false;
    }
    return `
          <div class="mga-section">
              <div class="mga-section-title">\u{1F514} Shop Alert Notifications</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Get audio and visual alerts when rare seeds or eggs appear in the shop.
              </p>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="notifications-enabled-checkbox" class="mga-checkbox"
                             ${settings.notifications.enabled ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F50A} Enable Notifications</span>
                  </label>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Volume: ${Math.round(settings.notifications.volume * 100)}%
                  </label>
                  <input type="range" class="mga-slider" id="notification-volume-slider"
                         min="0" max="100" value="${settings.notifications.volume * 100}"
                         style="width: 100%; accent-color: #4a9eff;">
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="notification-continuous-checkbox" class="mga-checkbox"
                             ${settings.notifications.continuousEnabled ? "checked" : ""}
                             style="accent-color: #ff9900;">
                      <span>\u26A0\uFE0F Enable Continuous Mode</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      Allows selection of continuous notification type that plays until acknowledged.
                  </p>
              </div>
              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Notification Sound Type
                  </label>
                  <select class="mga-select" id="notification-type-select">
                      <option value="simple" ${settings.notifications.notificationType === "simple" ? "selected" : ""}>\u{1F50A} Simple Beep</option>
                      <option value="triple" ${settings.notifications.notificationType === "triple" ? "selected" : ""}>\u{1F514} Triple Beep</option>
                      <option value="alarm" ${settings.notifications.notificationType === "alarm" ? "selected" : ""}>\u{1F6A8} Alarm Siren</option>
                      <option value="epic" ${settings.notifications.notificationType === "epic" ? "selected" : ""}>\u{1F3B5} Epic Fanfare</option>
                      <option value="continuous" ${settings.notifications.notificationType === "continuous" ? "selected" : ""} ${!settings.notifications.continuousEnabled ? "disabled" : ""}>\u26A0\uFE0F Continuous (Until Acknowledged)</option>
                  </select>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="notification-acknowledgment-checkbox" class="mga-checkbox"
                             ${settings.notifications.requiresAcknowledgment ? "checked" : ""}
                             style="accent-color: #ff4444;">
                      <span>\u{1F6A8} Require acknowledgment (persistent alert)</span>
                  </label>
                  <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                      When enabled, notifications will show a modal that must be clicked to dismiss.
                  </p>
              </div>

              <div style="margin-bottom: 12px;">
                  <button class="mga-btn mga-btn-sm" id="test-notification-btn" style="background: #4a5568;">
                      \u{1F514} Test Notification
                  </button>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F3B5} Custom Notification Sounds</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Upload your own .mp3/.wav/.ogg files to replace default beep sounds. Max 2MB per file.
              </p>

              <div id="custom-sounds-container" style="display: grid; gap: 12px;">
                  <!-- Custom sound upload controls will be populated by setupNotificationsTabHandlers -->
              </div>
          </div>

          <div class="mga-section">
              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Watched Seeds
                  </label>
                  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                      ${[
      "Carrot",
      "Strawberry",
      "Aloe",
      "Blueberry",
      "Apple",
      "Tulip",
      "Tomato",
      "Daffodil",
      "Corn",
      "Watermelon",
      "Pumpkin",
      "Echeveria",
      "Coconut",
      "Banana",
      "Lily",
      "BurrosTail",
      "Mushroom",
      "Cactus",
      "Bamboo",
      "Grape",
      "Pepper",
      "Lemon",
      "PassionFruit",
      "DragonFruit",
      "Lychee",
      "Sunflower",
      "Starweaver",
      "Dawnbinder",
      "Moonbinder"
    ].map(
      (seed) => `
                        <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                            <input type="checkbox" id="watch-${seed.toLowerCase()}" class="mga-checkbox"
                                   ${settings.notifications.watchedSeeds.includes(seed) ? "checked" : ""}
                                   style="accent-color: #4a9eff; transform: scale(0.8);">
                            <span>${seed === "BurrosTail" ? "\u{1F331} Burro's Tail" : seed === "Dawnbinder" ? "\u{1F305} Dawnbinder" : seed === "Moonbinder" ? "\u{1F319} Moonbinder" : seed === "Starweaver" ? "\u2B50 Starweaver" : "\u{1F331} " + seed}</span>
                        </label>
                    `
    ).join("")}
                  </div>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Watched Eggs
                  </label>
                  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                      ${["CommonEgg", "UncommonEgg", "RareEgg", "LegendaryEgg", "MythicalEgg"].map(
      (egg) => `
                        <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                            <input type="checkbox" id="watch-${egg.toLowerCase().replace("egg", "-egg")}" class="mga-checkbox"
                                   ${settings.notifications.watchedEggs.includes(egg) ? "checked" : ""}
                                   style="accent-color: #4a9eff; transform: scale(0.8);">
                            <span>\u{1F95A} ${egg.replace("Egg", " Egg")}</span>
                        </label>
                    `
    ).join("")}
                  </div>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Watched Decor (Hourly Shop)
                  </label>
                  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                      ${DECOR_ITEMS.map(
      (decor) => `
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-decor-${decor.id.toLowerCase()}" class="mga-checkbox"
                                     ${settings.notifications.watchedDecor.includes(decor.id) ? "checked" : ""}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>\u{1F3A8} ${decor.name}</span>
                          </label>
                      `
    ).join("")}
                  </div>
              </div>

              <div style="margin-bottom: 12px; padding: 10px; background: rgba(255,255,255,0.15); border-radius: 4px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px; font-size: 12px;">
                      Last Seen
                  </label>
                  <div id="last-seen-display" style="font-size: 11px; color: #888; line-height: 1.3;">
                      Loading...
                  </div>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F43E} Pet Hunger Alerts</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Get notified when your pets' hunger drops below a threshold.
              </p>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="pet-hunger-enabled" class="mga-checkbox"
                             ${settings.notifications.petHungerEnabled ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F50A} Enable Pet Hunger Notifications</span>
                  </label>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Alert when hunger below: ${settings.notifications.petHungerThreshold || 20}%
                  </label>
                  <input type="range" class="mga-slider" id="pet-hunger-threshold"
                         min="5" max="50" step="5" value="${settings.notifications.petHungerThreshold || 20}"
                         style="width: 100%; accent-color: #ff9900;">
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u2728 Ability Trigger Alerts</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Get notified when your pets trigger abilities. Leave all unchecked to be notified for all abilities.
              </p>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="ability-notifications-enabled" class="mga-checkbox"
                             ${settings.notifications.abilityNotificationsEnabled ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F50A} Enable Ability Notifications</span>
                  </label>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Ability Sound Type
                  </label>
                  <select class="mga-select" id="ability-notification-sound-select"
                          style="width: 100%; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; color: white; font-size: 12px;">
                      <option value="single" ${settings.notifications.abilityNotificationSound === "single" ? "selected" : ""}>\u{1F50A} Single Beep (Subtle)</option>
                      <option value="double" ${settings.notifications.abilityNotificationSound === "double" ? "selected" : ""}>\u{1F514} Double Beep</option>
                      <option value="triple" ${settings.notifications.abilityNotificationSound === "triple" ? "selected" : ""}>\u{1F3B5} Triple Beep</option>
                      <option value="chime" ${settings.notifications.abilityNotificationSound === "chime" ? "selected" : ""}>\u{1F390} Chime (Pleasant)</option>
                      <option value="alert" ${settings.notifications.abilityNotificationSound === "alert" ? "selected" : ""}>\u{1F6A8} Alert (Urgent)</option>
                      <option value="buzz" ${settings.notifications.abilityNotificationSound === "buzz" ? "selected" : ""}>\u{1F4F3} Buzz (Energetic)</option>
                      <option value="ding" ${settings.notifications.abilityNotificationSound === "ding" ? "selected" : ""}>\u{1F514} Ding (Clear)</option>
                      <option value="chirp" ${settings.notifications.abilityNotificationSound === "chirp" ? "selected" : ""}>\u{1F426} Chirp (Cute)</option>
                      <option value="epic" ${settings.notifications.abilityNotificationSound === "epic" ? "selected" : ""}>\u{1F3B5} Epic Fanfare</option>
                  </select>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 4px;">
                      Ability Alert Volume: ${Math.round((settings.notifications.abilityNotificationVolume || 0.2) * 100)}%
                  </label>
                  <input type="range" class="mga-slider" id="ability-notification-volume-slider"
                         min="0" max="100" value="${(settings.notifications.abilityNotificationVolume || 0.2) * 100}"
                         style="width: 100%; accent-color: #9f7aea;">
              </div>

              <div style="margin-bottom: 16px; padding-top: 12px; border-top: 1px solid rgba(255, 255, 255, 0.57);">
                  <label class="mga-label" style="display: block; margin-bottom: 8px; font-weight: 600;">
                      \u{1F4CB} Which Abilities to Notify For
                  </label>
                  <p style="font-size: 11px; color: #888; margin-bottom: 8px;">
                      Select individual abilities that will trigger notifications. All abilities start enabled by default.
                  </p>

                  <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                      <button id="select-all-individual-abilities" class="mga-btn mga-btn-secondary" style="flex: 1; padding: 6px; font-size: 11px;">Select All</button>
                      <button id="select-none-individual-abilities" class="mga-btn mga-btn-secondary" style="flex: 1; padding: 6px; font-size: 11px;">Select None</button>
                  </div>

                  <input type="text" id="ability-search-box" placeholder="\u{1F50D} Search abilities..."
                         style="width: 100%; padding: 8px; margin-bottom: 12px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; color: #fff; font-size: 12px;">

                  <div id="individual-abilities-notification-list" style="display: grid; grid-template-columns: 1fr; gap: 4px; max-height: 400px; overflow-y: auto; padding: 4px;">
                      <!-- Ability checkboxes will be populated by handler -->
                  </div>
              </div>
          </div>

          <div class="mga-section">
              <div class="mga-section-title">\u{1F324}\uFE0F Weather Event Alerts</div>
              <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                  Get notified when weather events occur in the game.
              </p>

              <div style="margin-bottom: 12px;">
                  <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                      <input type="checkbox" id="weather-notifications-enabled" class="mga-checkbox"
                             ${settings.notifications.weatherNotificationsEnabled ? "checked" : ""}
                             style="accent-color: #4a9eff;">
                      <span>\u{1F50A} Enable Weather Notifications</span>
                  </label>
              </div>

              <div style="margin-bottom: 12px;">
                  <label class="mga-label" style="display: block; margin-bottom: 8px;">
                      Watched Weather Events
                  </label>
                  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                      ${["Snow", "Rain", "AmberMoon", "Dawn"].map(
      (weather, idx) => `
                        <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                            <input type="checkbox" id="watch-${weather.toLowerCase().replace("ambermoon", "amber-moon")}" class="mga-checkbox"
                                   ${settings.notifications.watchedWeatherEvents.includes(weather) ? "checked" : ""}
                                   style="accent-color: #4a9eff; transform: scale(0.8);">
                            <span>${idx === 0 ? "\u2744\uFE0F" : idx === 1 ? "\u{1F327}\uFE0F" : idx === 2 ? "\u{1F319}" : "\u{1F305}"} ${weather === "AmberMoon" ? "Amber Moon" : weather}</span>
                        </label>
                    `
    ).join("")}
                  </div>
              </div>
          </div>
      `;
  }
  function setupNotificationsTabHandlers(context = document, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      productionLog: productionLog3 = console.log,
      productionWarn: productionWarn3 = console.warn,
      playSelectedNotification: playSelectedFn = playSelectedNotification,
      queueNotification: queueNotificationFn = queueNotification,
      showVisualNotification: showVisualFn = showVisualNotification,
      getTimeSinceLastSeen: getTimeSinceFn = getTimeSinceLastSeen,
      scanAndAlertHungryPets: scanAndAlertHungryPets2 = typeof window !== "undefined" && window.scanAndAlertHungryPets,
      DECOR_ITEMS = typeof window !== "undefined" && window.DECOR_ITEMS ? window.DECOR_ITEMS : [],
      GM_getValue: GM_getValue2 = typeof window !== "undefined" && window.GM_getValue,
      GM_setValue: GM_setValue2 = typeof window !== "undefined" && window.GM_setValue,
      GM_deleteValue: GM_deleteValue2 = typeof window !== "undefined" && window.GM_deleteValue
    } = dependencies;
    const notificationEnabledCheckbox = context.querySelector("#notifications-enabled-checkbox");
    if (notificationEnabledCheckbox && !notificationEnabledCheckbox.hasAttribute("data-handler-setup")) {
      notificationEnabledCheckbox.setAttribute("data-handler-setup", "true");
      notificationEnabledCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.notifications.enabled = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u{1F514} [NOTIFICATIONS] ${e.target.checked ? "Enabled" : "Disabled"} notifications`);
      });
    }
    const volumeSlider = context.querySelector("#notification-volume-slider");
    if (volumeSlider && !volumeSlider.hasAttribute("data-handler-setup")) {
      volumeSlider.setAttribute("data-handler-setup", "true");
      volumeSlider.addEventListener("input", (e) => {
        const volume = parseInt(e.target.value) / 100;
        UnifiedState3.data.settings.notifications.volume = volume;
        const label = volumeSlider.previousElementSibling;
        label.textContent = `Volume: ${Math.round(volume * 100)}%`;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const continuousCheckbox = context.querySelector("#notification-continuous-checkbox");
    if (continuousCheckbox && !continuousCheckbox.hasAttribute("data-handler-setup")) {
      continuousCheckbox.setAttribute("data-handler-setup", "true");
      if (UnifiedState3.data.settings.notifications.continuousEnabled) {
        const acknowledgmentCheckbox2 = context.querySelector("#notification-acknowledgment-checkbox");
        if (acknowledgmentCheckbox2) {
          acknowledgmentCheckbox2.checked = true;
          acknowledgmentCheckbox2.disabled = true;
          UnifiedState3.data.settings.notifications.requiresAcknowledgment = true;
        }
        const notificationTypeSelect2 = context.querySelector("#notification-type-select");
        if (notificationTypeSelect2) {
          notificationTypeSelect2.value = "continuous";
          UnifiedState3.data.settings.notifications.notificationType = "continuous";
          productionLog3("\u{1F50A} [NOTIFICATIONS] Auto-selected continuous in dropdown (checkbox was checked on load)");
        }
      }
      continuousCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.notifications.continuousEnabled = e.target.checked;
        const acknowledgmentCheckbox2 = context.querySelector("#notification-acknowledgment-checkbox");
        if (acknowledgmentCheckbox2) {
          if (e.target.checked) {
            acknowledgmentCheckbox2.checked = true;
            acknowledgmentCheckbox2.disabled = true;
            UnifiedState3.data.settings.notifications.requiresAcknowledgment = true;
            productionLog3(`\u{1F6A8} [NOTIFICATIONS] Auto-enabled and locked acknowledgment (required for continuous alarms)`);
          } else {
            acknowledgmentCheckbox2.disabled = false;
          }
        }
        const notificationTypeSelect2 = context.querySelector("#notification-type-select");
        if (notificationTypeSelect2) {
          const continuousOption = notificationTypeSelect2.querySelector('option[value="continuous"]');
          if (continuousOption) {
            continuousOption.disabled = !e.target.checked;
            if (e.target.checked) {
              if (notificationTypeSelect2.value !== "continuous") {
                UnifiedState3.data.settings.notifications.previousNotificationType = notificationTypeSelect2.value;
                notificationTypeSelect2.value = "continuous";
                UnifiedState3.data.settings.notifications.notificationType = "continuous";
                productionLog3(
                  `\u{1F50A} [NOTIFICATIONS] Saved previous type (${UnifiedState3.data.settings.notifications.previousNotificationType}), auto-selected continuous`
                );
              }
            } else {
              if (notificationTypeSelect2.value === "continuous") {
                const previousType = UnifiedState3.data.settings.notifications.previousNotificationType || "epic";
                notificationTypeSelect2.value = previousType;
                UnifiedState3.data.settings.notifications.notificationType = previousType;
                productionLog3(`\u{1F50A} [NOTIFICATIONS] Continuous mode disabled, reverted to ${previousType}`);
              }
            }
          }
        }
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u26A0\uFE0F [NOTIFICATIONS] Continuous mode enabled: ${e.target.checked}`);
      });
    }
    const notificationTypeSelect = context.querySelector("#notification-type-select");
    if (notificationTypeSelect && !notificationTypeSelect.hasAttribute("data-handler-setup")) {
      notificationTypeSelect.setAttribute("data-handler-setup", "true");
      const savedNotificationType = UnifiedState3.data.settings.notifications.notificationType || "epic";
      notificationTypeSelect.value = savedNotificationType;
      productionLog3(`\u{1F50A} [NOTIFICATIONS] Restored notification type to: ${savedNotificationType}`);
      if (UnifiedState3.data.settings.notifications.notificationType === "continuous") {
        const acknowledgmentCheckbox2 = context.querySelector("#notification-acknowledgment-checkbox");
        if (acknowledgmentCheckbox2) {
          acknowledgmentCheckbox2.checked = true;
          acknowledgmentCheckbox2.disabled = true;
          UnifiedState3.data.settings.notifications.requiresAcknowledgment = true;
        }
      }
      notificationTypeSelect.addEventListener("change", (e) => {
        if (e.target.value === "continuous" && !UnifiedState3.data.settings.notifications.continuousEnabled) {
          e.target.value = UnifiedState3.data.settings.notifications.notificationType || "epic";
          productionWarn3(`\u26A0\uFE0F [NOTIFICATIONS] Cannot select continuous mode - please enable it first`);
          showVisualFn("\u26A0\uFE0F Please enable Continuous Mode checkbox first", false, dependencies);
          return;
        }
        UnifiedState3.data.settings.notifications.notificationType = e.target.value;
        const acknowledgmentCheckbox2 = context.querySelector("#notification-acknowledgment-checkbox");
        if (acknowledgmentCheckbox2) {
          if (e.target.value === "continuous") {
            acknowledgmentCheckbox2.checked = true;
            acknowledgmentCheckbox2.disabled = true;
            UnifiedState3.data.settings.notifications.requiresAcknowledgment = true;
            productionLog3(`\u{1F6A8} [NOTIFICATIONS] Auto-enabled and locked acknowledgment (required for continuous alarms)`);
          } else {
            if (!UnifiedState3.data.settings.notifications.continuousEnabled) {
              acknowledgmentCheckbox2.disabled = false;
            }
          }
        }
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u{1F50A} [NOTIFICATIONS] Sound type changed to: ${e.target.value}`);
      });
    }
    const acknowledgmentCheckbox = context.querySelector("#notification-acknowledgment-checkbox");
    if (acknowledgmentCheckbox && !acknowledgmentCheckbox.hasAttribute("data-handler-setup")) {
      acknowledgmentCheckbox.setAttribute("data-handler-setup", "true");
      acknowledgmentCheckbox.checked = UnifiedState3.data.settings.notifications.requiresAcknowledgment || false;
      productionLog3(`\u{1F6A8} [NOTIFICATIONS] Restored acknowledgment checkbox to: ${acknowledgmentCheckbox.checked}`);
      acknowledgmentCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.notifications.requiresAcknowledgment = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u{1F6A8} [NOTIFICATIONS] Require acknowledgment: ${e.target.checked}`);
      });
    }
    const testNotificationBtn = context.querySelector("#test-notification-btn");
    if (testNotificationBtn && !testNotificationBtn.hasAttribute("data-handler-setup")) {
      testNotificationBtn.setAttribute("data-handler-setup", "true");
      testNotificationBtn.addEventListener("click", () => {
        const notifications = UnifiedState3.data.settings.notifications;
        playSelectedFn(dependencies);
        queueNotificationFn(
          "\u{1F514} Test notification - This is how alerts will look!",
          notifications.requiresAcknowledgment,
          dependencies
        );
        productionLog3(
          `\u{1F514} [NOTIFICATIONS] Test notification played - Type: ${notifications.notificationType}, Volume: ${Math.round(notifications.volume * 100)}%, Acknowledgment: ${notifications.requiresAcknowledgment}`
        );
      });
    }
    const seedWatchMap = {
      "watch-carrot": "Carrot",
      "watch-strawberry": "Strawberry",
      "watch-aloe": "Aloe",
      "watch-blueberry": "Blueberry",
      "watch-apple": "Apple",
      "watch-tulip": "Tulip",
      "watch-tomato": "Tomato",
      "watch-daffodil": "Daffodil",
      "watch-corn": "Corn",
      "watch-watermelon": "Watermelon",
      "watch-pumpkin": "Pumpkin",
      "watch-echeveria": "Echeveria",
      "watch-coconut": "Coconut",
      "watch-banana": "Banana",
      "watch-lily": "Lily",
      "watch-burrostail": "BurrosTail",
      "watch-mushroom": "Mushroom",
      "watch-cactus": "Cactus",
      "watch-bamboo": "Bamboo",
      "watch-grape": "Grape",
      "watch-pepper": "Pepper",
      "watch-lemon": "Lemon",
      "watch-passionfruit": "PassionFruit",
      "watch-dragonfruit": "DragonFruit",
      "watch-lychee": "Lychee",
      "watch-sunflower": "Sunflower",
      "watch-starweaver": "Starweaver",
      "watch-dawnbinder": "Dawnbinder",
      "watch-moonbinder": "Moonbinder"
    };
    Object.entries(seedWatchMap).forEach(([checkboxId, seedId]) => {
      const checkbox = context.querySelector(`#${checkboxId}`);
      if (checkbox && !checkbox.hasAttribute("data-handler-setup")) {
        checkbox.setAttribute("data-handler-setup", "true");
        checkbox.addEventListener("change", (e) => {
          const notifications = UnifiedState3.data.settings.notifications;
          if (e.target.checked) {
            if (!notifications.watchedSeeds.includes(seedId)) {
              notifications.watchedSeeds.push(seedId);
            }
          } else {
            notifications.watchedSeeds = notifications.watchedSeeds.filter((id) => id !== seedId);
          }
          MGA_saveJSON2("MGA_data", UnifiedState3.data);
          productionLog3(`\u{1F331} [NOTIFICATIONS] ${e.target.checked ? "Added" : "Removed"} ${seedId} to/from watch list`);
          updateLastSeenDisplay();
        });
      }
    });
    const eggWatchMap = {
      "watch-common-egg": "CommonEgg",
      "watch-uncommon-egg": "UncommonEgg",
      "watch-rare-egg": "RareEgg",
      "watch-legendary-egg": "LegendaryEgg",
      "watch-mythical-egg": "MythicalEgg"
    };
    Object.entries(eggWatchMap).forEach(([checkboxId, eggId]) => {
      const checkbox = context.querySelector(`#${checkboxId}`);
      if (checkbox && !checkbox.hasAttribute("data-handler-setup")) {
        checkbox.setAttribute("data-handler-setup", "true");
        checkbox.addEventListener("change", (e) => {
          const notifications = UnifiedState3.data.settings.notifications;
          if (e.target.checked) {
            if (!notifications.watchedEggs.includes(eggId)) {
              notifications.watchedEggs.push(eggId);
            }
          } else {
            notifications.watchedEggs = notifications.watchedEggs.filter((id) => id !== eggId);
          }
          MGA_saveJSON2("MGA_data", UnifiedState3.data);
          productionLog3(`\u{1F95A} [NOTIFICATIONS] ${e.target.checked ? "Added" : "Removed"} ${eggId} to/from watch list`);
          updateLastSeenDisplay();
        });
      }
    });
    DECOR_ITEMS.forEach((decor) => {
      const checkboxId = `watch-decor-${decor.id.toLowerCase()}`;
      const checkbox = context.querySelector(`#${checkboxId}`);
      if (checkbox && !checkbox.hasAttribute("data-handler-setup")) {
        checkbox.setAttribute("data-handler-setup", "true");
        checkbox.addEventListener("change", (e) => {
          const notifications = UnifiedState3.data.settings.notifications;
          if (e.target.checked) {
            if (!notifications.watchedDecor.includes(decor.id)) {
              notifications.watchedDecor.push(decor.id);
            }
          } else {
            notifications.watchedDecor = notifications.watchedDecor.filter((id) => id !== decor.id);
          }
          MGA_saveJSON2("MGA_data", UnifiedState3.data);
          productionLog3(`\u{1F3A8} [NOTIFICATIONS] ${e.target.checked ? "Added" : "Removed"} ${decor.id} to/from watch list`);
          updateLastSeenDisplay();
        });
      }
    });
    function updateLastSeenDisplay() {
      const lastSeenDisplay = context.querySelector("#last-seen-display");
      if (!lastSeenDisplay) return;
      const notifications = UnifiedState3.data.settings.notifications;
      const allWatched = [...notifications.watchedSeeds, ...notifications.watchedEggs, ...notifications.watchedDecor];
      if (allWatched.length === 0) {
        lastSeenDisplay.innerHTML = "No items being watched";
        return;
      }
      let html = "";
      allWatched.forEach((itemId) => {
        const timeSince = getTimeSinceFn(itemId, dependencies);
        html += `<div>${itemId}: ${timeSince}</div>`;
      });
      lastSeenDisplay.innerHTML = html;
    }
    updateLastSeenDisplay();
    setInterval(updateLastSeenDisplay, 3e4);
    const petHungerCheckbox = context.querySelector("#pet-hunger-enabled");
    if (petHungerCheckbox && !petHungerCheckbox.hasAttribute("data-handler-setup")) {
      petHungerCheckbox.setAttribute("data-handler-setup", "true");
      petHungerCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.notifications.petHungerEnabled = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u{1F43E} [PET-HUNGER] ${e.target.checked ? "Enabled" : "Disabled"} pet hunger notifications`);
        if (e.target.checked && scanAndAlertHungryPets2) {
          setTimeout(() => {
            scanAndAlertHungryPets2();
          }, 500);
        }
      });
    }
    const petHungerThreshold = context.querySelector("#pet-hunger-threshold");
    if (petHungerThreshold && !petHungerThreshold.hasAttribute("data-handler-setup")) {
      petHungerThreshold.setAttribute("data-handler-setup", "true");
      petHungerThreshold.addEventListener("input", (e) => {
        const threshold = parseInt(e.target.value);
        UnifiedState3.data.settings.notifications.petHungerThreshold = threshold;
        const label = petHungerThreshold.previousElementSibling;
        label.textContent = `Alert when hunger below: ${threshold}%`;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u{1F43E} [PET-HUNGER] Threshold set to ${threshold}%`);
      });
    }
    const abilityNotificationsCheckbox = context.querySelector("#ability-notifications-enabled");
    if (abilityNotificationsCheckbox && !abilityNotificationsCheckbox.hasAttribute("data-handler-setup")) {
      abilityNotificationsCheckbox.setAttribute("data-handler-setup", "true");
      abilityNotificationsCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.notifications.abilityNotificationsEnabled = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u2728 [ABILITY-NOTIFY] ${e.target.checked ? "Enabled" : "Disabled"} ability notifications`);
      });
    }
    const abilityNotificationSoundSelect = context.querySelector("#ability-notification-sound-select");
    if (abilityNotificationSoundSelect && !abilityNotificationSoundSelect.hasAttribute("data-handler-setup")) {
      abilityNotificationSoundSelect.setAttribute("data-handler-setup", "true");
      abilityNotificationSoundSelect.addEventListener("change", (e) => {
        UnifiedState3.data.settings.notifications.abilityNotificationSound = e.target.value;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u2728 [ABILITY-NOTIFY] Sound type changed to: ${e.target.value}`);
      });
    }
    const abilityVolumeSlider = context.querySelector("#ability-notification-volume-slider");
    if (abilityVolumeSlider && !abilityVolumeSlider.hasAttribute("data-handler-setup")) {
      abilityVolumeSlider.setAttribute("data-handler-setup", "true");
      abilityVolumeSlider.addEventListener("input", (e) => {
        const volume = parseInt(e.target.value) / 100;
        UnifiedState3.data.settings.notifications.abilityNotificationVolume = volume;
        const label = abilityVolumeSlider.previousElementSibling;
        label.textContent = `Ability Alert Volume: ${Math.round(volume * 100)}%`;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
      });
    }
    const individualAbilityCheckboxes = context.querySelectorAll(".individual-ability-checkbox");
    individualAbilityCheckboxes.forEach((checkbox) => {
      if (!checkbox.hasAttribute("data-handler-setup")) {
        checkbox.setAttribute("data-handler-setup", "true");
        checkbox.addEventListener("change", (e) => {
          const abilityName = e.target.dataset.abilityName;
          if (!UnifiedState3.data.settings.notifications.watchedAbilities) {
            UnifiedState3.data.settings.notifications.watchedAbilities = [];
          }
          if (e.target.checked) {
            if (!UnifiedState3.data.settings.notifications.watchedAbilities.includes(abilityName)) {
              UnifiedState3.data.settings.notifications.watchedAbilities.push(abilityName);
            }
          } else {
            const index = UnifiedState3.data.settings.notifications.watchedAbilities.indexOf(abilityName);
            if (index > -1) {
              UnifiedState3.data.settings.notifications.watchedAbilities.splice(index, 1);
            }
          }
          MGA_saveJSON2("MGA_data", UnifiedState3.data);
          productionLog3(`\u2728 [ABILITY-NOTIFY] ${abilityName}: ${e.target.checked ? "Enabled" : "Disabled"}`);
        });
      }
    });
    const abilitySearchBox = context.querySelector("#ability-search-box");
    if (abilitySearchBox && !abilitySearchBox.hasAttribute("data-handler-setup")) {
      abilitySearchBox.setAttribute("data-handler-setup", "true");
      abilitySearchBox.addEventListener("input", (e) => {
        const query = e.target.value.toLowerCase();
        const items = context.querySelectorAll(".ability-checkbox-item");
        items.forEach((item) => {
          const abilityName = item.dataset.ability.toLowerCase();
          item.style.display = abilityName.includes(query) ? "flex" : "none";
        });
      });
    }
    const selectAllIndividualAbilities = context.querySelector("#select-all-individual-abilities");
    if (selectAllIndividualAbilities && !selectAllIndividualAbilities.hasAttribute("data-handler-setup")) {
      selectAllIndividualAbilities.setAttribute("data-handler-setup", "true");
      selectAllIndividualAbilities.addEventListener("click", () => {
        UnifiedState3.data.settings.notifications.watchedAbilities = [];
        context.querySelectorAll(".individual-ability-checkbox").forEach((checkbox) => {
          checkbox.checked = true;
        });
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3("\u2728 [ABILITY-NOTIFY] Enabled all abilities");
      });
    }
    const selectNoneIndividualAbilities = context.querySelector("#select-none-individual-abilities");
    if (selectNoneIndividualAbilities && !selectNoneIndividualAbilities.hasAttribute("data-handler-setup")) {
      selectNoneIndividualAbilities.setAttribute("data-handler-setup", "true");
      selectNoneIndividualAbilities.addEventListener("click", () => {
        const allAbilities = [];
        context.querySelectorAll(".individual-ability-checkbox").forEach((checkbox) => {
          allAbilities.push(checkbox.dataset.abilityName);
        });
        UnifiedState3.data.settings.notifications.watchedAbilities = ["__NONE__"];
        context.querySelectorAll(".individual-ability-checkbox").forEach((checkbox) => {
          checkbox.checked = false;
        });
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3("\u2728 [ABILITY-NOTIFY] Disabled all abilities");
      });
    }
    const weatherNotificationsCheckbox = context.querySelector("#weather-notifications-enabled");
    if (weatherNotificationsCheckbox && !weatherNotificationsCheckbox.hasAttribute("data-handler-setup")) {
      weatherNotificationsCheckbox.setAttribute("data-handler-setup", "true");
      weatherNotificationsCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.settings.notifications.weatherNotificationsEnabled = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u{1F324}\uFE0F [WEATHER] ${e.target.checked ? "Enabled" : "Disabled"} weather notifications`);
      });
    }
    const weatherEventMap = {
      "watch-snow": "Snow",
      "watch-rain": "Rain",
      "watch-amber-moon": "AmberMoon",
      "watch-dawn": "Dawn"
    };
    Object.entries(weatherEventMap).forEach(([checkboxId, eventName]) => {
      const checkbox = context.querySelector(`#${checkboxId}`);
      if (checkbox && !checkbox.hasAttribute("data-handler-setup")) {
        checkbox.setAttribute("data-handler-setup", "true");
        checkbox.addEventListener("change", (e) => {
          const watchedEvents = UnifiedState3.data.settings.notifications.watchedWeatherEvents;
          if (e.target.checked) {
            if (!watchedEvents.includes(eventName)) {
              watchedEvents.push(eventName);
            }
          } else {
            const idx = watchedEvents.indexOf(eventName);
            if (idx > -1) watchedEvents.splice(idx, 1);
          }
          MGA_saveJSON2("MGA_data", UnifiedState3.data);
          productionLog3(`\u{1F324}\uFE0F [WEATHER] ${e.target.checked ? "Added" : "Removed"} ${eventName} to/from watch list`);
        });
      }
    });
    const customSoundsContainer = context.querySelector("#custom-sounds-container");
    if (customSoundsContainer && !customSoundsContainer.hasAttribute("data-handler-setup")) {
      customSoundsContainer.setAttribute("data-handler-setup", "true");
      const soundTypes = [
        { id: "shop", label: "\u{1F6D2} Shop Alerts" },
        { id: "pet", label: "\u{1F43E} Pet Hunger" },
        { id: "ability", label: "\u26A1 Ability Triggers" },
        { id: "weather", label: "\u{1F324}\uFE0F Weather Events" }
      ];
      soundTypes.forEach((type) => {
        const hasCustom = GM_getValue2(`mgtools_custom_sound_${type.id}`, null) !== null;
        const controlDiv = document.createElement("div");
        controlDiv.style.cssText = "border: 1px solid rgba(255, 255, 255, 0.57); padding: 10px; border-radius: 6px; background: rgba(0, 0, 0, 0.48);";
        controlDiv.innerHTML = `
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                      <label class="mga-label" style="margin: 0;">${type.label}</label>
                      <span id="custom-sound-status-${type.id}" style="font-size: 10px; color: ${hasCustom ? "#10b981" : "#666"};">
                          ${hasCustom ? "\u2713 Custom" : "\u25CB Default"}
                      </span>
                  </div>
                  <div style="display: flex; gap: 6px;">
                      <input type="file" accept="audio/*" id="upload-sound-${type.id}" style="display: none;">
                      <button class="mga-btn mga-btn-sm" id="upload-btn-${type.id}" style="flex: 1; background: #4a9eff; font-size: 11px; padding: 6px;">\u{1F4C1} Upload</button>
                      <button class="mga-btn mga-btn-sm" id="test-btn-${type.id}" style="flex: 0.6; background: #10b981; font-size: 11px; padding: 6px;">\u25B6\uFE0F Test</button>
                      <button class="mga-btn mga-btn-sm" id="delete-btn-${type.id}" style="flex: 0.6; background: ${hasCustom ? "#ef4444" : "#666"}; font-size: 11px; padding: 6px;" ${!hasCustom ? "disabled" : ""}>\u{1F5D1}\uFE0F</button>
                  </div>
              `;
        customSoundsContainer.appendChild(controlDiv);
        const uploadBtn = controlDiv.querySelector(`#upload-btn-${type.id}`);
        const fileInput = controlDiv.querySelector(`#upload-sound-${type.id}`);
        uploadBtn.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (!file) return;
          if (file.size > 2 * 1024 * 1024) {
            alert("\u274C File too large! Max 2MB");
            return;
          }
          if (!file.type.startsWith("audio/")) {
            alert("\u274C Please upload an audio file");
            return;
          }
          const reader = new FileReader();
          reader.onload = (event) => {
            GM_setValue2(`mgtools_custom_sound_${type.id}`, event.target.result);
            controlDiv.querySelector(`#custom-sound-status-${type.id}`).textContent = "\u2713 Custom";
            controlDiv.querySelector(`#custom-sound-status-${type.id}`).style.color = "#10b981";
            const delBtn = controlDiv.querySelector(`#delete-btn-${type.id}`);
            delBtn.disabled = false;
            delBtn.style.background = "#ef4444";
            productionLog3(`\u{1F3B5} [CUSTOM-SOUND] Uploaded: ${type.id}`);
            alert(`\u2705 Custom sound uploaded!`);
          };
          reader.readAsDataURL(file);
        });
        controlDiv.querySelector(`#test-btn-${type.id}`).addEventListener("click", () => {
          const customSound = GM_getValue2(`mgtools_custom_sound_${type.id}`, null);
          const volume = UnifiedState3.data.settings.notifications.volume || 0.3;
          if (customSound) {
            const audio = new Audio(customSound);
            audio.volume = volume;
            audio.play();
          } else {
            playSelectedFn(dependencies);
          }
        });
        controlDiv.querySelector(`#delete-btn-${type.id}`).addEventListener("click", () => {
          if (confirm(`Delete custom sound for ${type.label}?`)) {
            GM_deleteValue2(`mgtools_custom_sound_${type.id}`);
            controlDiv.querySelector(`#custom-sound-status-${type.id}`).textContent = "\u25CB Default";
            controlDiv.querySelector(`#custom-sound-status-${type.id}`).style.color = "#666";
            const delBtn = controlDiv.querySelector(`#delete-btn-${type.id}`);
            delBtn.disabled = true;
            delBtn.style.background = "#666";
            alert(`\u2705 Reverted to default sound`);
          }
        });
      });
    }
  }
  var notifications_default = {
    // Core Sound System (Phase 1)
    playNotificationSound,
    playTripleBeepNotification,
    playDoubleBeepNotification,
    playSingleBeepNotification,
    playChimeNotification,
    playAlertNotification,
    playBuzzNotification,
    playDingNotification,
    playChirpNotification,
    playAlarmNotification,
    startContinuousAlarm,
    stopContinuousAlarm,
    playEpicNotification,
    playSelectedNotification,
    // Custom Sound Wrappers (Phase 2)
    playCustomOrDefaultSound,
    playGeneralNotificationSound,
    playShopNotificationSound,
    playWeatherNotificationSound,
    // Visual Notifications (Phase 3)
    queueNotification,
    updateNotificationModal,
    generateNotificationListHTML,
    showBatchedNotificationModal,
    dismissAllNotifications,
    showVisualNotification,
    // Notification Utilities (Phase 4)
    normalizeSpeciesName,
    isWatchedItem,
    updateLastSeen,
    getTimeSinceLastSeen,
    showNotificationToast
  };

  // src/features/shop.js
  var shop_exports = {};
  __export(shop_exports, {
    EGG_IDS_SHOP: () => EGG_IDS_SHOP,
    SEED_SPECIES_SHOP: () => SEED_SPECIES_SHOP,
    SHOP_COLOR_GROUPS: () => SHOP_COLOR_GROUPS,
    SHOP_DISPLAY_NAMES: () => SHOP_DISPLAY_NAMES,
    SHOP_IMAGE_MAP: () => SHOP_IMAGE_MAP,
    SHOP_PRICES: () => SHOP_PRICES,
    SHOP_RAINBOW_ITEMS: () => SHOP_RAINBOW_ITEMS,
    buyItem: () => buyItem,
    checkForWatchedItems: () => checkForWatchedItems,
    createShopItemElement: () => createShopItemElement,
    createShopOverlay: () => createShopOverlay,
    createShopSidebar: () => createShopSidebar,
    createShopSidebars: () => createShopSidebars,
    createShopWindow: () => createShopWindow,
    default: () => shop_default,
    flashInventoryFullFeedback: () => flashInventoryFullFeedback,
    flashPurchaseFeedback: () => flashPurchaseFeedback,
    formatShopPrice: () => formatShopPrice,
    getInventoryItemCount: () => getInventoryItemCount,
    getItemStackCap: () => getItemStackCap,
    getItemStock: () => getItemStock,
    getItemValue: () => getItemValue,
    getLocalPurchaseCount: () => getLocalPurchaseCount,
    getShopItemColorClass: () => getShopItemColorClass,
    getShopTabContent: () => getShopTabContent,
    handleEggRestockDetection: () => handleEggRestockDetection,
    initializeShopWatcher: () => initializeShopWatcher,
    initializeToolRestockWatcher: () => initializeToolRestockWatcher,
    isInventoryFull: () => isInventoryFull,
    isShopDataReady: () => isShopDataReady,
    loadPurchaseTracker: () => loadPurchaseTracker,
    makeShopWindowDraggable: () => makeShopWindowDraggable,
    normalizeShopKey: () => normalizeShopKey,
    preloadShopImages: () => preloadShopImages,
    refreshAllShopWindows: () => refreshAllShopWindows,
    resetLocalPurchases: () => resetLocalPurchases,
    savePurchaseTracker: () => savePurchaseTracker,
    scheduleRefresh: () => scheduleRefresh,
    setupShopTabHandlers: () => setupShopTabHandlers,
    setupShopWindowHandlers: () => setupShopWindowHandlers,
    showFloatingMsg: () => showFloatingMsg,
    startInventoryCounter: () => startInventoryCounter,
    stopInventoryCounter: () => stopInventoryCounter,
    toggleShopWindows: () => toggleShopWindows,
    trackLocalPurchase: () => trackLocalPurchase,
    updateInventoryCounters: () => updateInventoryCounters,
    waitForShopData: () => waitForShopData
  });
  var SHOP_IMAGE_MAP = {
    // Seeds
    Carrot: "https://cdn.discordapp.com/emojis/1423010183574982669.webp",
    Strawberry: "https://cdn.discordapp.com/emojis/1423010222724874330.webp",
    Aloe: "https://cdn.discordapp.com/emojis/1423010259655590028.webp",
    Blueberry: "https://cdn.discordapp.com/emojis/1423010283126784010.webp",
    Apple: "https://cdn.discordapp.com/emojis/1423010302965846046.webp",
    OrangeTulip: "https://cdn.discordapp.com/emojis/1423010324952514621.webp",
    Tomato: "https://cdn.discordapp.com/emojis/1423010355109433478.webp",
    Daffodil: "https://cdn.discordapp.com/emojis/1423010391356866654.webp",
    Corn: "https://cdn.discordapp.com/emojis/1423010497648656566.webp",
    Watermelon: "https://cdn.discordapp.com/emojis/1423010520067346515.webp",
    Pumpkin: "https://cdn.discordapp.com/emojis/1423010546474549338.webp",
    Echeveria: "https://cdn.discordapp.com/emojis/1423010587910078614.webp",
    Coconut: "https://cdn.discordapp.com/emojis/1423010611721273444.webp",
    Banana: "https://cdn.discordapp.com/emojis/1423010652582187089.webp",
    Lily: "https://cdn.discordapp.com/emojis/1423010686388404407.webp",
    BurrosTail: "https://cdn.discordapp.com/emojis/1423010714267942912.webp",
    Mushroom: "https://cdn.discordapp.com/emojis/1423010734002012160.webp",
    Cactus: "https://cdn.discordapp.com/emojis/1423010755267133531.webp",
    Bamboo: "https://cdn.discordapp.com/emojis/1423010797830930552.webp",
    Grape: "https://cdn.discordapp.com/emojis/1423010779522666616.webp",
    Pepper: "https://cdn.discordapp.com/emojis/1423010818953580574.webp",
    Lemon: "https://cdn.discordapp.com/emojis/1423010911144120330.webp",
    PassionFruit: "https://cdn.discordapp.com/emojis/1423010934863171677.webp",
    DragonFruit: "https://cdn.discordapp.com/emojis/1423010954991370271.webp",
    Lychee: "https://cdn.discordapp.com/emojis/1423011007206396076.webp",
    Sunflower: "https://cdn.discordapp.com/emojis/1423010976499765288.webp",
    Starweaver: "https://cdn.discordapp.com/emojis/1423011042744729700.webp",
    DawnCelestial: "https://cdn.discordapp.com/emojis/1423011097883185412.webp",
    MoonCelestial: "https://cdn.discordapp.com/emojis/1423011077410525308.webp",
    // Eggs
    CommonEgg: "https://cdn.discordapp.com/emojis/1423011628978540676.webp",
    UncommonEgg: "https://cdn.discordapp.com/emojis/1423011627602804856.webp",
    RareEgg: "https://cdn.discordapp.com/emojis/1423011625664905316.webp",
    LegendaryEgg: "https://cdn.discordapp.com/emojis/1423011623089737739.webp",
    MythicalEgg: "https://cdn.discordapp.com/emojis/1423011620828745899.webp",
    // Tools (Use Discord emojis for proper display)
    WateringCan: "https://cdn.discordapp.com/emojis/1426622484957888512.webp",
    PlanterPot: "https://cdn.discordapp.com/emojis/1426622518948794451.webp",
    Shovel: "https://cdn.discordapp.com/emojis/1426622542222856282.webp",
    "Watering Can": "https://cdn.discordapp.com/emojis/1426622484957888512.webp",
    "Planter Pot": "https://cdn.discordapp.com/emojis/1426622518948794451.webp",
    "Garden Shovel": "https://cdn.discordapp.com/emojis/1426622542222856282.webp"
  };
  var SHOP_COLOR_GROUPS = {
    white: ["CommonEgg", "Carrot", "Strawberry", "Aloe"],
    green: ["UncommonEgg", "Apple", "OrangeTulip", "Tomato", "Blueberry"],
    blue: ["RareEgg", "Daffodil", "Corn", "Watermelon", "Pumpkin", "Delphinium", "Squash"],
    yellow: ["LegendaryEgg", "Echeveria", "Coconut", "Banana", "Lily", "BurrosTail"],
    purple: ["MythicalEgg", "Mushroom", "Cactus", "Bamboo", "Grape"],
    orange: ["Pepper", "Lemon", "PassionFruit", "DragonFruit", "Lychee", "Sunflower"]
  };
  var SHOP_RAINBOW_ITEMS = ["Starweaver", "DawnCelestial", "MoonCelestial"];
  var SHOP_PRICES = {
    // Seeds - Common tier
    Carrot: 10,
    Strawberry: 50,
    Aloe: 135,
    // Seeds - Uncommon tier
    Blueberry: 400,
    Apple: 500,
    OrangeTulip: 600,
    Tomato: 800,
    // Seeds - Rare tier
    Daffodil: 1e3,
    Corn: 1300,
    Delphinium: 1800,
    Squash: 2200,
    Watermelon: 2500,
    Pumpkin: 3e3,
    // Seeds - Legendary tier
    Echeveria: 4200,
    Coconut: 6e3,
    Banana: 7500,
    Lily: 2e4,
    BurrosTail: 93e3,
    // Seeds - Mythical tier
    Mushroom: 15e4,
    Cactus: 25e4,
    Bamboo: 4e5,
    Grape: 85e4,
    // Seeds - Divine tier
    Pepper: 1e6,
    Lemon: 2e6,
    PassionFruit: 275e4,
    DragonFruit: 5e6,
    Lychee: 25e6,
    Sunflower: 1e8,
    // Seeds - Celestial tier
    Starweaver: 1e9,
    DawnCelestial: 1e10,
    MoonCelestial: 5e10,
    // Eggs
    CommonEgg: 1e5,
    UncommonEgg: 1e6,
    RareEgg: 1e7,
    LegendaryEgg: 1e8,
    MythicalEgg: 1e9,
    // Tools (from game screenshot)
    WateringCan: 3e3,
    "Watering Can": 3e3,
    PlanterPot: 25e3,
    "Planter Pot": 25e3,
    GardenShovel: 0,
    // OWNED - unlimited uses
    "Garden Shovel": 0
  };
  var SHOP_DISPLAY_NAMES = {
    OrangeTulip: "Tulip",
    // Tools
    WateringCan: "Watering Can",
    PlanterPot: "Planter Pot",
    GardenShovel: "Garden Shovel"
  };
  function formatShopPrice(price) {
    let formatted;
    let color;
    if (price >= 1e9) {
      formatted = `${(price / 1e9).toFixed(price % 1e9 === 0 ? 0 : 1)}b`;
      color = "#4a9eff";
    } else if (price >= 1e6) {
      formatted = `${(price / 1e6).toFixed(price % 1e6 === 0 ? 0 : 1)}m`;
      color = "#ffd700";
    } else if (price >= 1e3) {
      formatted = `${(price / 1e3).toFixed(price % 1e3 === 0 ? 0 : 1)}k`;
      color = "#999";
    } else {
      formatted = price.toString();
      color = "#999";
    }
    return { formatted, color };
  }
  function normalizeShopKey(s) {
    return String(s ?? "").toLowerCase().replace(/[^a-z0-9]/g, "");
  }
  function getShopItemColorClass(itemId) {
    const normalized = normalizeShopKey(itemId);
    for (const rainbowItem of SHOP_RAINBOW_ITEMS) {
      if (normalized.includes(normalizeShopKey(rainbowItem))) {
        return "shop-rainbow-text";
      }
    }
    const colorKeys = Object.keys(SHOP_COLOR_GROUPS);
    for (let i = 0; i < colorKeys.length; i += 1) {
      const color = colorKeys[i];
      const items = SHOP_COLOR_GROUPS[color];
      for (const item of items) {
        if (normalized === normalizeShopKey(item) || normalized.includes(normalizeShopKey(item))) {
          return `shop-color-${color}`;
        }
      }
    }
    return "";
  }
  function preloadShopImages(dependencies = {}) {
    const { Image: ImageConstructor = typeof window !== "undefined" ? window.Image : null } = dependencies;
    if (!ImageConstructor) return;
    Object.values(SHOP_IMAGE_MAP).forEach((src) => {
      if (!src) return;
      const img = new ImageConstructor();
      img.src = src;
    });
  }
  function flashPurchaseFeedback(el2, message, duration = 1500, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      showFloatingMsg: showFloatingMsgFn = showFloatingMsg,
      console: consoleObj = console
    } = dependencies;
    if (!targetDocument2) return;
    try {
      const stuckTooltips = targetDocument2.querySelectorAll(".mga-flash-tooltip");
      stuckTooltips.forEach((t) => {
        if (t && t.parentNode) t.remove();
      });
    } catch (e) {
    }
    try {
      if (!el2 || !(el2 instanceof Element)) {
        consoleObj.warn("flashPurchaseFeedback: invalid element", el2);
        showFloatingMsgFn(message, duration, { targetDocument: targetDocument2 });
        return;
      }
      const rect = el2.getBoundingClientRect();
      const msg = targetDocument2.createElement("div");
      msg.className = "mga-flash-tooltip";
      msg.textContent = message;
      msg.setAttribute("role", "status");
      msg.style.cssText = "position:fixed;pointer-events:none;padding:6px 10px;border-radius:8px;font-size:12px;background:rgba(0,0,0,.9);color:#fff;z-index:2147483647;transition:opacity 180ms ease,transform 220ms ease;opacity:0;transform:translateY(-6px);";
      if (rect && rect.width > 0 && rect.height > 0) {
        const left = rect.left + rect.width / 2;
        let top = rect.top - 10;
        if (top < 6) top = rect.bottom + 8;
        msg.style.left = `${Math.round(left)}px`;
        msg.style.top = `${Math.round(top)}px`;
        msg.style.transform += " translateX(-50%)";
      } else {
        const left = window.innerWidth / 2;
        const top = 20;
        msg.style.left = `${Math.round(left)}px`;
        msg.style.top = `${Math.round(top)}px`;
        msg.style.transform += " translateX(-50%)";
      }
      targetDocument2.body.appendChild(msg);
      requestAnimationFrame(() => {
        msg.style.opacity = "1";
        msg.style.transform = msg.style.transform.replace("translateY(-6px)", "translateY(0)");
      });
      const removeMsg = () => {
        try {
          if (msg && msg.parentNode) {
            msg.style.opacity = "0";
            msg.style.transform = msg.style.transform.replace("translateY(0)", "translateY(-6px)");
            setTimeout(() => {
              try {
                if (msg && msg.parentNode) msg.remove();
              } catch (e) {
              }
            }, 220);
          }
        } catch (e) {
          try {
            if (msg && msg.parentNode) msg.remove();
          } catch (_) {
          }
        }
      };
      setTimeout(removeMsg, duration);
    } catch (err) {
      consoleObj.error("flashPurchaseFeedback error:", err);
      try {
        showFloatingMsgFn(message, duration, { targetDocument: targetDocument2 });
      } catch (e) {
      }
    }
  }
  function showFloatingMsg(msg, dur = 900, dependencies = {}) {
    const { targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null } = dependencies;
    if (!targetDocument2) return;
    const m = targetDocument2.createElement("div");
    m.textContent = msg;
    m.style.cssText = "position:fixed;left:50%;top:20px;transform:translateX(-50%);background:rgba(0,0,0,.9);color:#fff;padding:6px 10px;border-radius:8px;z-index:2147483647;";
    targetDocument2.body.appendChild(m);
    setTimeout(() => m.remove(), dur);
  }
  var localPurchaseTrackerState = {
    seed: {},
    egg: {},
    tool: {}
  };
  function loadPurchaseTracker(dependencies = {}) {
    const { MGA_loadJSON: MGA_loadJSON2 = typeof window !== "undefined" && window.MGA_loadJSON, console: consoleObj = console } = dependencies;
    if (!MGA_loadJSON2) return;
    try {
      const saved = MGA_loadJSON2("MGA_purchaseTracker");
      if (saved && typeof saved === "object") {
        localPurchaseTrackerState = {
          seed: saved.seed || {},
          egg: saved.egg || {},
          tool: saved.tool || {}
        };
        consoleObj.log("\u{1F4E6} [LOCAL-TRACK] Loaded purchase tracker:", {
          seeds: Object.keys(localPurchaseTrackerState.seed).length,
          eggs: Object.keys(localPurchaseTrackerState.egg).length,
          tools: Object.keys(localPurchaseTrackerState.tool).length,
          toolData: localPurchaseTrackerState.tool
        });
      }
    } catch (e) {
      consoleObj.error("[LOCAL-TRACK] Error loading purchase tracker:", e);
    }
  }
  function savePurchaseTracker(dependencies = {}) {
    const {
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      localPurchaseTracker = localPurchaseTrackerState,
      console: consoleObj = console
    } = dependencies;
    if (!MGA_saveJSON2) return;
    try {
      MGA_saveJSON2("MGA_purchaseTracker", localPurchaseTracker);
    } catch (e) {
      consoleObj.error("[LOCAL-TRACK] Error saving purchase tracker:", e);
    }
  }
  function trackLocalPurchase(id, type, amount = 1, dependencies = {}) {
    const {
      localPurchaseTracker = localPurchaseTrackerState,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog,
      savePurchaseTracker: saveFn = savePurchaseTracker
    } = dependencies;
    if (!localPurchaseTracker[type][id]) {
      localPurchaseTracker[type][id] = 0;
    }
    localPurchaseTracker[type][id] += amount;
    if (productionLog3) {
      productionLog3(
        `\u{1F4DD} [LOCAL-TRACK] Recorded ${amount}x ${id} (${type}). Total local: ${localPurchaseTracker[type][id]}`
      );
    }
    saveFn({ localPurchaseTracker });
  }
  function getLocalPurchaseCount(id, type, dependencies = {}) {
    const { localPurchaseTracker = localPurchaseTrackerState } = dependencies;
    if (localPurchaseTracker[type][id]) {
      return localPurchaseTracker[type][id];
    }
    if (type === "tool") {
      const idNoSpaces = id.replace(/\s+/g, "");
      const typeKeys = Object.keys(localPurchaseTracker[type]);
      for (let i = 0; i < typeKeys.length; i += 1) {
        const key = typeKeys[i];
        const keyNoSpaces = key.replace(/\s+/g, "");
        if (keyNoSpaces === idNoSpaces) {
          return localPurchaseTracker[type][key];
        }
      }
    }
    return 0;
  }
  function resetLocalPurchases(type = null, dependencies = {}) {
    const {
      localPurchaseTracker = localPurchaseTrackerState,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog,
      savePurchaseTracker: saveFn = savePurchaseTracker
    } = dependencies;
    if (type) {
      localPurchaseTracker[type] = {};
      if (productionLog3) {
        productionLog3(`\u{1F504} [LOCAL-TRACK] Reset ${type} purchases for restock`);
      }
    } else {
      localPurchaseTracker.seed = {};
      localPurchaseTracker.egg = {};
      localPurchaseTracker.tool = {};
      if (productionLog3) {
        productionLog3(`\u{1F504} [LOCAL-TRACK] Reset all purchases for restock`);
      }
    }
    saveFn({ localPurchaseTracker });
  }
  function isInventoryFull(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const inventory = UnifiedState3?.atoms?.inventory;
    if (!inventory || !inventory.items) return false;
    const MAX_INVENTORY = 100;
    const currentCount = inventory.items.length;
    return currentCount >= MAX_INVENTORY;
  }
  function getInventoryItemCount(itemId, itemType, dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const inventory = UnifiedState3?.atoms?.inventory;
    if (!inventory || !inventory.items) return 0;
    let count = 0;
    for (const item of inventory.items) {
      if (itemType === "seed" && item.species === itemId) {
        count += item.quantity || 1;
      } else if (itemType === "egg" && item.eggId === itemId) {
        count += item.quantity || 1;
      } else if (itemType === "tool" && item.toolId === itemId) {
        count += item.quantity || 1;
      }
    }
    return count;
  }
  function getItemStackCap(itemId, itemType) {
    if (itemType === "tool" && (itemId === "Shovel" || itemId === "GardenShovel")) {
      return Infinity;
    }
    if (itemType === "tool" && itemId === "WateringCan") {
      return 99;
    }
    return Infinity;
  }
  function flashInventoryFullFeedback(element, message, dependencies = {}) {
    const { productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog } = dependencies;
    let flashes = 0;
    const flashInterval = setInterval(() => {
      if (flashes >= 6) {
        clearInterval(flashInterval);
        element.style.background = "";
        element.style.borderColor = "";
        element.style.boxShadow = "";
        return;
      }
      if (flashes % 2 === 0) {
        element.style.background = "rgba(255, 0, 0, 0.3)";
        element.style.borderColor = "rgba(255, 0, 0, 0.8)";
        element.style.boxShadow = "0 0 15px rgba(255, 0, 0, 0.5)";
      } else {
        element.style.background = "";
        element.style.borderColor = "";
        element.style.boxShadow = "";
      }
      flashes += 1;
    }, 200);
    if (productionLog3) {
      productionLog3(`\u274C [SHOP] ${message}`);
    }
  }
  function getItemStock(id, type, dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      getLocalPurchaseCount: getPurchasesFn = getLocalPurchaseCount,
      productionError: productionError2 = console.error
    } = dependencies;
    try {
      const shop = targetWindow3?.globalShop?.shops;
      if (!shop) return 0;
      let inventory;
      let item;
      if (type === "seed") {
        inventory = shop.seed?.inventory;
        if (!inventory) return 0;
        item = inventory.find((i) => i.species === id);
      } else if (type === "egg") {
        inventory = shop.egg?.inventory;
        if (!inventory) return 0;
        item = inventory.find((i) => i.eggId === id);
      } else if (type === "tool") {
        inventory = shop.tool?.inventory;
        if (!inventory) return 0;
        const idNoSpaces = id.replace(/\s+/g, "");
        item = inventory.find(
          (i) => i.toolId === id || i.name === id || i.toolId?.replace(/\s+/g, "") === idNoSpaces || i.name?.replace(/\s+/g, "") === idNoSpaces
        );
      } else {
        return 0;
      }
      if (!item) return 0;
      const initial = item.initialStock || item.stock || 0;
      const purchased = Math.min(getPurchasesFn(id, type), initial);
      const stock = Math.max(0, initial - purchased);
      return stock;
    } catch (e) {
      productionError2("[SHOP] getItemStock error:", e);
      return 0;
    }
  }
  function isShopDataReady(dependencies = {}) {
    const { targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null } = dependencies;
    return !!targetWindow3?.globalShop?.shops;
  }
  function waitForShopData(callback, timeout = 5e3, dependencies = {}) {
    const {
      isShopDataReady: isReadyFn = isShopDataReady,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog,
      productionWarn: productionWarn3 = typeof window !== "undefined" && window.productionWarn
    } = dependencies;
    const startTime = Date.now();
    const pollInterval = 100;
    const poller = setInterval(() => {
      if (isReadyFn(dependencies)) {
        clearInterval(poller);
        if (productionLog3) {
          productionLog3(`\u2705 [SHOP] Shop data ready after ${Date.now() - startTime}ms`);
        }
        callback(true);
      } else if (Date.now() - startTime >= timeout) {
        clearInterval(poller);
        if (productionWarn3) {
          productionWarn3(`\u26A0\uFE0F [SHOP] Shop data timeout after ${timeout}ms`);
        }
        callback(false);
      }
    }, pollInterval);
  }
  function createShopItemElement(id, type, stock, value, options = {}, dependencies = {}) {
    const { owned = false, unlimited = false } = options;
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      SHOP_DISPLAY_NAMES: displayNames = SHOP_DISPLAY_NAMES,
      SHOP_IMAGE_MAP: imageMap = SHOP_IMAGE_MAP,
      SHOP_PRICES: prices = SHOP_PRICES,
      getShopItemColorClass: getColorClassFn = getShopItemColorClass,
      formatShopPrice: formatPriceFn = formatShopPrice,
      getInventoryItemCount: getInventoryCountFn = getInventoryItemCount,
      getItemStackCap: getStackCapFn = getItemStackCap,
      buyItem: buyItemFn = buyItem
    } = dependencies;
    if (!targetDocument2) return null;
    const div = targetDocument2.createElement("div");
    div.className = "shop-item";
    if (stock > 0 && !owned) div.classList.add("in-stock");
    div.style.cssText = `
    padding: 8px;
    background: ${stock > 0 && !owned ? "rgba(76, 255, 106, 0.40)" : "rgba(255,255,255,0.03)"};
    border: 1px solid ${stock > 0 && !owned ? "rgba(9, 255, 0, 0.48)" : "rgba(255, 255, 255, 0.57)"};
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    transition: all 0.2s ease;
  `;
    const displayName = displayNames[id] || id.replace(/([A-Z])/g, " $1").trim();
    const spriteUrl = imageMap[id] || "";
    const colorClass = getColorClassFn(id);
    const price = prices[id] || 0;
    const priceData = formatPriceFn(price);
    let stockDisplay;
    if (owned || unlimited) {
      stockDisplay = '<span style="color: #888; font-weight: 600;">OWNED</span>';
    } else {
      stockDisplay = `Stock: ${stock} | <span style="color: ${priceData.color};">\u{1F4B0}${priceData.formatted}</span>`;
    }
    const ownedCount = getInventoryCountFn(id, type, dependencies);
    const stackCap = getStackCapFn(id, type);
    let quantityDisplay = "";
    if (stackCap < Infinity && ownedCount > 0) {
      const percentFull = ownedCount / stackCap * 100;
      let color = "rgba(255, 255, 255, 0.7)";
      if (percentFull >= 100) {
        color = "#ff4444";
      } else if (percentFull >= 80) {
        color = "#ffaa44";
      } else if (percentFull >= 50) {
        color = "#ffff44";
      }
      quantityDisplay = `<div class="quantity-display" style="font-size: 11px; color: ${color}; margin-top: 2px; font-weight: bold;">Owned: ${ownedCount}/${stackCap}</div>`;
    } else if (ownedCount > 0 && !owned && !unlimited) {
      quantityDisplay = `<div class="quantity-display" style="font-size: 11px; color: rgba(255, 255, 255, 0.7); margin-top: 2px;">Owned: ${ownedCount}</div>`;
    }
    div.innerHTML = `
    <div style="flex: 1; min-width: 0; display: flex; align-items: center; gap: 8px;">
      ${spriteUrl ? `<img src="${spriteUrl}" alt="${displayName}" class="shop-sprite" loading="lazy">` : ""}
      <div style="flex: 1; min-width: 0;">
        <div style="font-size: 12px; font-weight: 600; margin-bottom: 2px;" class="${colorClass}">${displayName}</div>
        <div class="stock-display" style="font-size: 10px; color: #888;">${stockDisplay}</div>
        ${quantityDisplay}
      </div>
    </div>
    <div style="display: ${owned || unlimited ? "none" : "flex"}; gap: 4px;">
      <button class="buy-btn" data-amount="1" ${stock === 0 ? "disabled" : ""}
        style="padding: 4px 8px; font-size: 11px; background: rgba(74, 158, 255, 0.3); border: 1px solid rgba(74, 158, 255, 0.5); border-radius: 3px; color: #fff; cursor: ${stock > 0 ? "pointer" : "not-allowed"}; transition: all 0.15s ease;">1</button>
      <button class="buy-btn" data-amount="all" ${stock === 0 ? "disabled" : ""}
        style="padding: 4px 8px; font-size: 11px; background: rgba(76, 175, 80, 0.3); border: 1px solid rgba(76, 175, 80, 0.5); border-radius: 3px; color: #fff; cursor: ${stock > 0 ? "pointer" : "not-allowed"}; transition: all 0.15s ease;">All</button>
    </div>
  `;
    div.querySelectorAll(".buy-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        const amount = btn.dataset.amount === "all" ? stock : 1;
        buyItemFn(id, type, amount, div, dependencies);
      });
      if (stock > 0) {
        btn.addEventListener("mouseenter", () => {
          btn.style.background = "rgba(9, 255, 0, 0.5)";
          btn.style.borderColor = "rgba(9, 255, 0, 0.8)";
          btn.style.boxShadow = "0 0 8px rgba(9, 255, 0, 0.4)";
        });
        btn.addEventListener("mouseleave", () => {
          const isAllButton = btn.dataset.amount === "all";
          btn.style.background = isAllButton ? "rgba(76, 175, 80, 0.3)" : "rgba(74, 158, 255, 0.3)";
          btn.style.borderColor = isAllButton ? "rgba(76, 175, 80, 0.5)" : "rgba(74, 158, 255, 0.5)";
          btn.style.boxShadow = "";
        });
      }
    });
    return div;
  }
  function buyItem(id, type, amount, itemEl, dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      SHOP_DISPLAY_NAMES: displayNames = SHOP_DISPLAY_NAMES,
      SHOP_PRICES: prices = SHOP_PRICES,
      isInventoryFull: isInvFullFn = isInventoryFull,
      flashInventoryFullFeedback: flashInvFullFn = flashInventoryFullFeedback,
      getInventoryItemCount: getInvCountFn = getInventoryItemCount,
      getItemStackCap: getStackCapFn = getItemStackCap,
      getItemStock: getStockFn = getItemStock,
      formatShopPrice: formatPriceFn = formatShopPrice,
      flashPurchaseFeedback: flashPurchaseFn = flashPurchaseFeedback,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog,
      alert: alertFn = typeof window !== "undefined" ? window.alert : console.log,
      console: consoleObj = console
    } = dependencies;
    const conn = targetWindow3?.MagicCircle_RoomConnection;
    if (!conn?.sendMessage) {
      alertFn("Connection not available");
      return;
    }
    const inventory = UnifiedState3?.atoms?.inventory;
    const hasExistingStack = inventory?.items?.some((item) => {
      if (type === "seed") return item.species === id && item.itemType !== "Produce";
      if (type === "egg") return item.eggId === id;
      if (type === "tool") return item.toolId === id || item.name === id;
      return false;
    });
    if (isInvFullFn(dependencies) && !hasExistingStack) {
      flashInvFullFn(itemEl, `Inventory Full! (100/100) - Cannot purchase new items`, dependencies);
      if (UnifiedState3?.data?.settings?.debugMode) {
        consoleObj.log(`[SHOP] Purchase blocked: Inventory full and no existing stack for ${id}`);
      }
      return;
    }
    if (hasExistingStack && UnifiedState3?.data?.settings?.debugMode) {
      consoleObj.log(`[SHOP] \u2705 Inventory full but ${id} can stack on existing item`);
    }
    const currentCount = getInvCountFn(id, type, dependencies);
    const stackCap = getStackCapFn(id, type);
    if (currentCount >= stackCap) {
      const displayName = displayNames[id] || id.replace(/([A-Z])/g, " $1").trim();
      if (stackCap < Infinity) {
        flashInvFullFn(
          itemEl,
          `${displayName} at MAX! (${currentCount}/${stackCap}) - Cannot purchase more`,
          dependencies
        );
        const quantityDisplay = itemEl.querySelector(".quantity-display");
        if (quantityDisplay) {
          quantityDisplay.textContent = `Owned: ${currentCount}/${stackCap}`;
          quantityDisplay.style.color = "#ff4444";
          quantityDisplay.style.fontWeight = "bold";
        }
      } else {
        flashInvFullFn(itemEl, `${displayName} at max capacity! (${currentCount}/${stackCap})`, dependencies);
      }
      if (UnifiedState3?.data?.settings?.debugMode) {
        consoleObj.log(`[SHOP] \u274C Purchase blocked: ${id} at cap (${currentCount}/${stackCap})`);
      }
      return;
    }
    if (currentCount + amount > stackCap) {
      const displayName = displayNames[id] || id.replace(/([A-Z])/g, " $1").trim();
      const canPurchase = stackCap - currentCount;
      flashInvFullFn(
        itemEl,
        `Can only purchase ${canPurchase} more ${displayName} (currently ${currentCount}/${stackCap})`,
        dependencies
      );
      if (UnifiedState3?.data?.settings?.debugMode) {
        consoleObj.log(`[SHOP] \u274C Purchase blocked: would exceed cap (${currentCount} + ${amount} > ${stackCap})`);
      }
      return;
    }
    if (UnifiedState3?.data?.settings?.debugMode) {
      consoleObj.log(`[SHOP] \u2705 Purchase allowed: ${id} (${currentCount} + ${amount} <= ${stackCap})`);
    }
    try {
      for (let i = 0; i < amount; i += 1) {
        let messageType;
        let itemKey;
        if (type === "seed") {
          messageType = "PurchaseSeed";
          itemKey = "species";
        } else if (type === "egg") {
          messageType = "PurchaseEgg";
          itemKey = "eggId";
        } else if (type === "tool") {
          messageType = "PurchaseTool";
          itemKey = "toolId";
        }
        conn.sendMessage({
          scopePath: ["Room", "Quinoa"],
          type: messageType,
          [itemKey]: id
        });
      }
      const displayName = id.replace(/([A-Z])/g, " $1").trim();
      flashPurchaseFn(itemEl, `Purchased x${amount} ${displayName}`, 1500, dependencies);
      if (productionLog3) {
        productionLog3(`\u2705 Purchased ${amount}x ${id}`);
      }
      setTimeout(() => {
        const newStock = getStockFn(id, type, dependencies);
        const stockSpan = itemEl.querySelector(".stock-display");
        if (stockSpan) {
          const priceData = formatPriceFn(prices[id] || 0);
          stockSpan.innerHTML = `Stock: ${newStock} | <span style="color: ${priceData.color};">\u{1F4B0}${priceData.formatted}</span>`;
        }
        const quantityDiv = itemEl.querySelector(".quantity-display");
        if (quantityDiv) {
          const ownedCount = getInvCountFn(id, type, dependencies);
          const itemStackCap = getStackCapFn(id, type);
          if (itemStackCap < Infinity && ownedCount > 0) {
            const percentFull = ownedCount / itemStackCap * 100;
            let color = "rgba(255, 255, 255, 0.7)";
            if (percentFull >= 100) {
              color = "#ff4444";
            } else if (percentFull >= 80) {
              color = "#ffaa44";
            } else if (percentFull >= 50) {
              color = "#ffff44";
            }
            quantityDiv.style.color = color;
            quantityDiv.style.fontWeight = percentFull >= 100 ? "bold" : "normal";
            quantityDiv.textContent = `Owned: ${ownedCount}/${itemStackCap}`;
          } else if (ownedCount > 0) {
            quantityDiv.textContent = `Owned: ${ownedCount}`;
          }
        }
        if (UnifiedState3?.data?.settings?.debugMode) {
          consoleObj.log(`[SHOP DEBUG] Stock updated for ${id}: ${newStock} (using game's purchase data)`);
        }
        if (newStock === 0) {
          itemEl.classList.remove("in-stock");
          itemEl.style.background = "rgba(255,255,255,0.03)";
          itemEl.style.borderColor = "rgba(255, 255, 255, 0.57)";
          itemEl.querySelectorAll(".buy-btn").forEach((btn) => {
            btn.disabled = true;
            btn.style.cursor = "not-allowed";
          });
        } else {
          itemEl.classList.add("in-stock");
          itemEl.style.background = "rgba(76, 255, 106, 0.40)";
          itemEl.style.borderColor = "rgba(9, 255, 0, 0.48)";
        }
      }, 100);
    } catch (e) {
      consoleObj.error("Purchase error:", e);
      alertFn("Purchase failed");
    }
  }
  var shopWindowsOpen = false;
  var seedShopWindow = null;
  var eggShopWindow = null;
  var shopOverlay = null;
  var shopRenderFunctions = {
    seed: null,
    egg: null
  };
  var SEED_SPECIES_SHOP = [
    "Carrot",
    "Strawberry",
    "Aloe",
    "Blueberry",
    "Apple",
    "OrangeTulip",
    "Tomato",
    "Daffodil",
    "Corn",
    "Watermelon",
    "Pumpkin",
    "Echeveria",
    "Coconut",
    "Banana",
    "Lily",
    "BurrosTail",
    "Mushroom",
    "Cactus",
    "Bamboo",
    "Grape",
    "Pepper",
    "Lemon",
    "PassionFruit",
    "DragonFruit",
    "Lychee",
    "Sunflower",
    "Starweaver",
    "DawnCelestial",
    "MoonCelestial"
  ];
  var EGG_IDS_SHOP = ["CommonEgg", "UncommonEgg", "RareEgg", "LegendaryEgg", "MythicalEgg"];
  function refreshAllShopWindows(dependencies = {}) {
    const { shopRenderFunctions: renderFns = shopRenderFunctions } = dependencies;
    if (renderFns.seed) {
      renderFns.seed();
    }
    if (renderFns.egg) {
      renderFns.egg();
    }
  }
  function createShopOverlay(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      toggleShopWindows: toggleFn = toggleShopWindows,
      shopOverlay: cachedOverlay = shopOverlay
    } = dependencies;
    if (!targetDocument2) return null;
    if (cachedOverlay) return cachedOverlay;
    const overlay = targetDocument2.createElement("div");
    overlay.id = "mga-shop-overlay";
    targetDocument2.body.appendChild(overlay);
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        toggleFn(dependencies);
      }
    });
    shopOverlay = overlay;
    return overlay;
  }
  var inventoryUpdateInterval = null;
  var cachedCounterElements = null;
  var cachedCountElements = null;
  var inventoryCounterRefs = 0;
  function createShopSidebar(type, title, side, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      toggleShopWindows: toggleFn = toggleShopWindows
    } = dependencies;
    if (!targetDocument2) return null;
    const sidebar = targetDocument2.createElement("div");
    sidebar.className = `mga-shop-sidebar mga-shop-sidebar-${side}`;
    sidebar.id = `mga-shop-${type}`;
    const inventory = UnifiedState3?.atoms?.inventory;
    const currentCount = inventory?.items?.length || 0;
    const maxCount = 100;
    let inventoryColor = "#4caf50";
    if (currentCount >= 100) {
      inventoryColor = "#ff4444";
    } else if (currentCount >= 95) {
      inventoryColor = "#ffa500";
    }
    sidebar.innerHTML = `
    <div class="mga-shop-sidebar-header">
      <h3 style="margin: 0; font-size: 16px; font-weight: 600;">\u{1F331} ${title}</h3>
      <div style="display: flex; gap: 8px; align-items: center;">
        <button class="shop-refresh-btn" style="cursor: pointer; font-size: 16px; color: #4a9eff; background: none; border: none; padding: 4px 8px; transition: color 0.2s ease;" title="Refresh shop">\u{1F504}</button>
        <button class="shop-close-btn" style="cursor: pointer; font-weight: 700; font-size: 20px; color: #cfcfcf; background: none; border: none; padding: 0 8px; transition: color 0.2s ease;">\xD7</button>
      </div>
    </div>

    <!-- Inventory counter -->
    <div class="shop-inventory-counter" style="
      font-size: 12px;
      font-weight: 600;
      color: ${inventoryColor};
      margin: 12px 12px 0 12px;
      padding: 8px 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      border-left: 3px solid ${inventoryColor};
      display: flex;
      align-items: center;
      gap: 8px;
    ">
      <span>\u{1F4E6}</span>
      <span>Inventory: <span class="shop-inventory-count">${currentCount}</span>/${maxCount}</span>
    </div>

    <div style="display: flex; flex-direction: column; gap: 8px; padding: 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.57);">
      <label style="font-size: 12px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
        <input type="checkbox" class="show-available-only" style="accent-color: #2afd23;">
        <span>Show available only</span>
      </label>
      <label style="font-size: 12px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
        <input type="checkbox" class="sort-by-value" style="accent-color: #4a9eff;">
        <span>Sort by Value</span>
      </label>
    </div>
    <div class="shop-items-list" style="display: flex; flex-direction: column; gap: 6px; padding: 12px; overflow-y: auto; flex: 1;"></div>
  `;
    targetDocument2.body.appendChild(sidebar);
    const closeBtn = sidebar.querySelector(".shop-close-btn");
    closeBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleFn(dependencies);
    });
    closeBtn.addEventListener("mouseenter", () => {
      closeBtn.style.color = "#ff5555";
    });
    closeBtn.addEventListener("mouseleave", () => {
      closeBtn.style.color = "#cfcfcf";
    });
    const refreshBtn = sidebar.querySelector(".shop-refresh-btn");
    refreshBtn.addEventListener("mouseenter", () => {
      refreshBtn.style.color = "#6fbfff";
    });
    refreshBtn.addEventListener("mouseleave", () => {
      refreshBtn.style.color = "#4a9eff";
    });
    return sidebar;
  }
  function updateInventoryCounters(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState
    } = dependencies;
    if (!targetDocument2) return;
    const inventory = UnifiedState3?.atoms?.inventory;
    const currentCount = inventory?.items?.length || 0;
    const maxCount = 100;
    let inventoryColor = "#4caf50";
    if (currentCount >= 100) {
      inventoryColor = "#ff4444";
    } else if (currentCount >= 95) {
      inventoryColor = "#ffa500";
    }
    if (!cachedCountElements || cachedCountElements.length === 0) {
      cachedCountElements = targetDocument2.querySelectorAll(".shop-inventory-count, #shop-inventory-count");
    }
    if (!cachedCounterElements || cachedCounterElements.length === 0) {
      cachedCounterElements = targetDocument2.querySelectorAll(".shop-inventory-counter, #shop-inventory-counter");
    }
    cachedCountElements.forEach((el2) => {
      if (el2 && el2.textContent !== String(currentCount)) {
        el2.textContent = currentCount;
      }
    });
    cachedCounterElements.forEach((el2) => {
      if (el2 && el2.style.color !== inventoryColor) {
        el2.style.color = inventoryColor;
        el2.style.borderLeftColor = inventoryColor;
      }
    });
  }
  function startInventoryCounter(dependencies = {}) {
    const { updateInventoryCounters: updateFn = updateInventoryCounters } = dependencies;
    inventoryCounterRefs += 1;
    if (inventoryCounterRefs === 1) {
      updateFn(dependencies);
      if (inventoryUpdateInterval) clearInterval(inventoryUpdateInterval);
      inventoryUpdateInterval = setInterval(() => updateFn(dependencies), 1e3);
    }
  }
  function stopInventoryCounter(dependencies = {}) {
    inventoryCounterRefs = Math.max(0, inventoryCounterRefs - 1);
    if (inventoryCounterRefs === 0 && inventoryUpdateInterval) {
      clearInterval(inventoryUpdateInterval);
      inventoryUpdateInterval = null;
      cachedCounterElements = null;
      cachedCountElements = null;
    }
  }
  function toggleShopWindows(dependencies = {}) {
    const {
      createShopSidebars: createSidebarsFn = createShopSidebars,
      startInventoryCounter: startCounterFn = startInventoryCounter,
      stopInventoryCounter: stopCounterFn = stopInventoryCounter
    } = dependencies;
    if (shopWindowsOpen) {
      if (seedShopWindow) {
        seedShopWindow.classList.remove("open");
      }
      if (eggShopWindow) {
        eggShopWindow.classList.remove("open");
      }
      shopWindowsOpen = false;
      stopCounterFn(dependencies);
    } else {
      if (!seedShopWindow) createSidebarsFn(dependencies);
      seedShopWindow.classList.add("open");
      eggShopWindow.classList.add("open");
      shopWindowsOpen = true;
      startCounterFn(dependencies);
    }
  }
  function createShopSidebars(dependencies = {}) {
    const {
      createShopSidebar: createSidebarFn = createShopSidebar,
      setupShopWindowHandlers: setupHandlersFn = setupShopWindowHandlers
    } = dependencies;
    seedShopWindow = createSidebarFn("seed", "Seeds", "left", dependencies);
    eggShopWindow = createSidebarFn("egg", "Eggs & Tools", "right", dependencies);
    setupHandlersFn(seedShopWindow, "seed", dependencies);
    setupHandlersFn(eggShopWindow, "egg", dependencies);
  }
  function createShopWindow(type, title, leftOffset, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      MGA_loadJSON: MGA_loadJSON2 = typeof window !== "undefined" && window.MGA_loadJSON,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      makeShopWindowDraggable: makeDraggableFn = makeShopWindowDraggable,
      makeElementResizable: makeElementResizable2 = typeof window !== "undefined" && window.makeElementResizable
    } = dependencies;
    if (!targetDocument2) return null;
    const windowEl = targetDocument2.createElement("div");
    windowEl.className = "mga-shop-window";
    windowEl.id = `mga-shop-${type}`;
    const savedPositions = MGA_loadJSON2 ? MGA_loadJSON2("MGA_shopWindowPositions", {}) : {};
    const savedSizes = MGA_loadJSON2 ? MGA_loadJSON2("MGA_shopWindowSizes", {}) : {};
    const savedPos = savedPositions[type] || { left: leftOffset, top: 120 };
    const savedSize = savedSizes[type] || { width: 300, height: 500 };
    if (targetWindow3) {
      if (savedPos.left < 0 || savedPos.left > targetWindow3.innerWidth - 100) {
        savedPos.left = leftOffset;
      }
      if (savedPos.top < 0 || savedPos.top > targetWindow3.innerHeight - 100) {
        savedPos.top = 120;
      }
    }
    if (savedSize.width < 250 || savedSize.width > 800) {
      savedSize.width = 300;
    }
    if (savedSize.height < 300 || savedSize.height > 900) {
      savedSize.height = 500;
    }
    windowEl.style.cssText = `
    position: fixed;
    top: ${savedPos.top}px;
    left: ${savedPos.left}px;
    width: ${savedSize.width}px;
    height: ${savedSize.height}px;
    background: rgba(17, 24, 39, 0.98);
    border: 1px solid rgba(255, 255, 255, 0.73);
    border-radius: 8px;
    padding: 12px;
    z-index: 999999;
    overflow-y: auto;
    color: #fff;
    transition: transform 0.3s ease, opacity 0.3s ease;
  `;
    windowEl.innerHTML = `
    <div class="shop-window-header" style="padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid rgba(255, 255, 255, 0.57); cursor: grab;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; position: relative;">
        <h3 style="margin: 0; font-size: 14px;">\u{1F331} ${title}</h3>
        <button class="shop-close-btn" style="position: absolute; top: -4px; right: -4px; cursor: pointer; font-weight: 700; font-size: 16px; color: #cfcfcf; background: none; border: none; padding: 0 6px; transition: color 0.2s ease;">\xD7</button>
      </div>
      <div style="display: flex; flex-direction: column; gap: 6px;">
        <label style="font-size: 11px; display: flex; align-items: center; gap: 4px; cursor: pointer;">
          <input type="checkbox" class="show-available-only" style="accent-color: #2afd23;">
          <span>Show available only</span>
        </label>
        <label style="font-size: 11px; display: flex; align-items: center; gap: 4px; cursor: pointer;">
          <input type="checkbox" class="sort-by-value" style="accent-color: #4a9eff;">
          <span>Sort by Value</span>
        </label>
      </div>
    </div>
    <div class="shop-items-list" style="display: flex; flex-direction: column; gap: 6px;"></div>
  `;
    targetDocument2.body.appendChild(windowEl);
    const closeBtn = windowEl.querySelector(".shop-close-btn");
    closeBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      windowEl.remove();
      if (type === "seed") {
        seedShopWindow = null;
      } else {
        eggShopWindow = null;
      }
      if (!seedShopWindow && !eggShopWindow) {
        if (shopOverlay) shopOverlay.classList.remove("active");
        shopWindowsOpen = false;
      }
    });
    closeBtn.addEventListener("mouseenter", () => {
      closeBtn.style.color = "#ff5555";
    });
    closeBtn.addEventListener("mouseleave", () => {
      closeBtn.style.color = "#cfcfcf";
    });
    makeDraggableFn(windowEl, windowEl.querySelector(".shop-window-header"), type, dependencies);
    if (makeElementResizable2) {
      makeElementResizable2(windowEl, {
        minWidth: 250,
        minHeight: 300,
        maxWidth: 600,
        maxHeight: 800,
        showHandleOnHover: true
      });
      if (typeof ResizeObserver !== "undefined" && MGA_saveJSON2 && MGA_loadJSON2) {
        const resizeObserver = new ResizeObserver(() => {
          const sizes = MGA_loadJSON2("MGA_shopWindowSizes", {});
          sizes[type] = {
            width: windowEl.offsetWidth,
            height: windowEl.offsetHeight
          };
          MGA_saveJSON2("MGA_shopWindowSizes", sizes);
        });
        resizeObserver.observe(windowEl);
      }
    }
    return windowEl;
  }
  function makeShopWindowDraggable(element, handle, windowType, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      MGA_loadJSON: MGA_loadJSON2 = typeof window !== "undefined" && window.MGA_loadJSON,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON
    } = dependencies;
    if (!targetDocument2 || !element || !handle) return;
    let isDragging = false;
    let startX;
    let startY;
    let startLeft;
    let startTop;
    handle.style.cursor = "grab";
    handle.addEventListener("mousedown", (e) => {
      if (e.target.tagName === "INPUT" || e.target.tagName === "BUTTON") return;
      if (e.target.tagName === "LABEL" && e.target.querySelector("input")) return;
      if (e.target.classList && e.target.classList.contains("mga-resize-handle")) return;
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      startLeft = element.offsetLeft;
      startTop = element.offsetTop;
      handle.style.cursor = "grabbing";
      element.style.zIndex = "9999999";
    });
    targetDocument2.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      element.style.left = `${startLeft + dx}px`;
      element.style.top = `${startTop + dy}px`;
    });
    targetDocument2.addEventListener("mouseup", () => {
      if (isDragging) {
        isDragging = false;
        handle.style.cursor = "grab";
        element.style.zIndex = "999999";
        if (MGA_loadJSON2 && MGA_saveJSON2) {
          const positions = MGA_loadJSON2("MGA_shopWindowPositions", {});
          positions[windowType] = {
            left: element.offsetLeft,
            top: element.offsetTop
          };
          MGA_saveJSON2("MGA_shopWindowPositions", positions);
        }
      }
    });
  }
  function setupShopWindowHandlers(windowEl, type, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_loadJSON: MGA_loadJSON2 = typeof window !== "undefined" && window.MGA_loadJSON,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      createShopItemElement: createItemFn = createShopItemElement,
      getItemStock: getStockFn = getItemStock,
      getItemValue: getValueFn = getItemValue,
      resetLocalPurchases: resetPurchasesFn = resetLocalPurchases,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog,
      productionWarn: productionWarn3 = typeof window !== "undefined" && window.productionWarn,
      isShopDataReady: isReadyFn = isShopDataReady,
      waitForShopData: waitForDataFn = waitForShopData
    } = dependencies;
    if (!windowEl) return;
    const itemsList = windowEl.querySelector(".shop-items-list");
    const sortCheckbox = windowEl.querySelector(".sort-by-value");
    const showAvailableCheckbox = windowEl.querySelector(".show-available-only");
    const items = type === "seed" ? SEED_SPECIES_SHOP : EGG_IDS_SHOP;
    function renderItems(sortByValue = false, showAvailableOnly = false) {
      if (!itemsList) return;
      itemsList.innerHTML = "";
      if (type === "egg") {
        let eggItemsToRender = EGG_IDS_SHOP.map((id) => ({
          id,
          stock: getStockFn(id, "egg", dependencies),
          value: getValueFn(id, "egg"),
          type: "egg"
        }));
        if (showAvailableOnly) {
          eggItemsToRender = eggItemsToRender.filter((item) => item.stock > 0);
        }
        if (sortByValue) {
          eggItemsToRender.sort((a, b) => b.value - a.value);
        }
        eggItemsToRender.forEach(({ id, stock, value }) => {
          const itemEl = createItemFn(id, "egg", stock, value, {}, dependencies);
          if (itemEl) itemsList.appendChild(itemEl);
        });
        const toolShop = targetWindow3?.globalShop?.shops?.tool;
        const toolInventory = toolShop?.inventory || [];
        if (toolInventory.length > 0) {
          const divider = targetDocument2.createElement("div");
          divider.style.cssText = `
          margin: 12px 0;
          padding: 8px 0;
          border-top: 1px solid rgba(255, 255, 255, 0.1);
          border-bottom: 1px solid rgba(255, 255, 255, 0.05);
          text-align: center;
          font-size: 11px;
          font-weight: 600;
          color: rgba(255, 255, 255, 0.5);
          text-transform: uppercase;
          letter-spacing: 1px;
        `;
          divider.textContent = "\u{1F527} Tools";
          itemsList.appendChild(divider);
          let toolItemsToRender = toolInventory.map((tool, idx) => {
            const toolId = tool.toolId || tool.name || `Tool_${idx}`;
            let isOwned = false;
            let isUnlimited = false;
            if (toolId === "Shovel" || toolId === "GardenShovel") {
              const playerInventory = targetWindow3.myData?.inventory?.items || [];
              isOwned = playerInventory.some(
                (item) => item.itemType === "Tool" && (item.toolId === "Shovel" || item.toolId === "GardenShovel")
              );
              if (isOwned) {
                isUnlimited = true;
              }
            }
            const toolStock = isOwned ? 0 : getStockFn(toolId, "tool", dependencies);
            return {
              id: toolId,
              stock: toolStock,
              value: getValueFn(toolId, "tool"),
              type: "tool",
              owned: isOwned,
              unlimited: isUnlimited
            };
          });
          if (showAvailableOnly) {
            toolItemsToRender = toolItemsToRender.filter((item) => item.stock > 0 || item.owned || item.unlimited);
          }
          if (sortByValue) {
            toolItemsToRender.sort((a, b) => b.value - a.value);
          }
          toolItemsToRender.forEach(({ id, stock, value, owned, unlimited }) => {
            const itemEl = createItemFn(id, "tool", stock, value, { owned, unlimited }, dependencies);
            if (itemEl) itemsList.appendChild(itemEl);
          });
        }
        if (eggItemsToRender.length === 0 && toolInventory.length === 0 && showAvailableOnly) {
          itemsList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px; font-size: 12px;">No items in stock</div>';
        }
      } else {
        let itemsToRender = items.map((id) => ({
          id,
          stock: getStockFn(id, type, dependencies),
          value: getValueFn(id, type)
        }));
        if (showAvailableOnly) {
          itemsToRender = itemsToRender.filter((item) => item.stock > 0);
        }
        if (sortByValue) {
          itemsToRender.sort((a, b) => b.value - a.value);
        }
        itemsToRender.forEach(({ id, stock, value }) => {
          const itemEl = createItemFn(id, type, stock, value, {}, dependencies);
          if (itemEl) itemsList.appendChild(itemEl);
        });
        if (itemsToRender.length === 0 && showAvailableOnly) {
          itemsList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px; font-size: 12px;">No items in stock</div>';
        }
      }
    }
    const savedFilters = MGA_loadJSON2 ? MGA_loadJSON2("MGA_shopFilters", {}) : {};
    const savedShowAvailable = savedFilters.showAvailableOnly ?? false;
    const savedSortByValue = savedFilters.sortByValue ?? false;
    if (sortCheckbox) sortCheckbox.checked = savedSortByValue;
    if (showAvailableCheckbox) showAvailableCheckbox.checked = savedShowAvailable;
    if (sortCheckbox) {
      sortCheckbox.addEventListener("change", () => {
        if (MGA_saveJSON2) {
          const filters = {
            showAvailableOnly: showAvailableCheckbox?.checked ?? false,
            sortByValue: sortCheckbox.checked
          };
          MGA_saveJSON2("MGA_shopFilters", filters);
        }
        renderItems(sortCheckbox.checked, showAvailableCheckbox?.checked ?? false);
      });
    }
    if (showAvailableCheckbox) {
      showAvailableCheckbox.addEventListener("change", () => {
        if (MGA_saveJSON2) {
          const filters = {
            showAvailableOnly: showAvailableCheckbox.checked,
            sortByValue: sortCheckbox?.checked ?? false
          };
          MGA_saveJSON2("MGA_shopFilters", filters);
        }
        renderItems(sortCheckbox?.checked ?? false, showAvailableCheckbox.checked);
      });
    }
    const refreshBtn = windowEl.querySelector(".shop-refresh-btn");
    if (refreshBtn) {
      refreshBtn.addEventListener("click", () => {
        renderItems(sortCheckbox?.checked ?? false, showAvailableCheckbox?.checked ?? false);
      });
    }
    function showLoadingState() {
      if (!itemsList) return;
      itemsList.innerHTML = `
      <div style="color: #4a9eff; text-align: center; padding: 40px 20px; font-size: 13px;">
        <div style="margin-bottom: 12px; font-size: 24px;">\u23F3</div>
        <div style="font-weight: 600; margin-bottom: 8px;">Loading shop data...</div>
        <div style="font-size: 11px; color: rgba(255, 255, 255, 0.5);">Waiting for game data</div>
      </div>
    `;
    }
    function showTimeoutError() {
      if (!itemsList) return;
      itemsList.innerHTML = `
      <div style="color: #ff6b6b; text-align: center; padding: 40px 20px; font-size: 13px;">
        <div style="margin-bottom: 12px; font-size: 24px;">\u26A0\uFE0F</div>
        <div style="font-weight: 600; margin-bottom: 8px;">Shop data unavailable</div>
        <div style="font-size: 11px; color: rgba(255, 255, 255, 0.5); margin-bottom: 16px;">
          Game data not loaded yet
        </div>
        <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7);">
          Try using the refresh button (\u{1F504}) or closing and reopening the shop
        </div>
      </div>
    `;
    }
    if (isReadyFn(dependencies)) {
      renderItems(savedSortByValue, savedShowAvailable);
    } else {
      if (productionLog3) {
        productionLog3(`\u23F3 [SHOP] Shop data not ready yet, showing loading state for ${type} shop`);
      }
      showLoadingState();
      waitForDataFn(
        (success) => {
          if (success) {
            renderItems(savedSortByValue, savedShowAvailable);
          } else {
            showTimeoutError();
          }
        },
        5e3,
        dependencies
      );
    }
    shopRenderFunctions[type] = () => renderItems(sortCheckbox?.checked ?? false, showAvailableCheckbox?.checked ?? false);
    let lastTimerValue = null;
    let timerWasDecreasing = false;
    setInterval(() => {
      const shop = targetWindow3?.globalShop?.shops;
      if (shop) {
        const shopData = type === "seed" ? shop.seed : shop.egg;
        if (shopData && typeof shopData.secondsUntilRestock !== "undefined") {
          const currentTimer = Number(shopData.secondsUntilRestock) || 0;
          if (lastTimerValue === null) {
            lastTimerValue = currentTimer;
            return;
          }
          let restockDetected = false;
          if (currentTimer < lastTimerValue) {
            timerWasDecreasing = true;
          } else if (timerWasDecreasing && currentTimer > lastTimerValue + 2) {
            restockDetected = true;
            timerWasDecreasing = false;
            if (UnifiedState3?.data?.settings?.debugMode) {
              console.log(
                `[SHOP DEBUG] Restock detected for ${type}! Pattern: ${lastTimerValue}s \u2192 ${currentTimer}s (was decreasing, then increased)`
              );
            }
          }
          lastTimerValue = currentTimer;
          if (restockDetected) {
            resetPurchasesFn(type, dependencies);
            setTimeout(() => {
              renderItems(sortCheckbox?.checked ?? false, showAvailableCheckbox?.checked ?? false);
            }, 500);
            return;
          }
        }
      }
      const isHovering = itemsList?.querySelector(".buy-btn:hover");
      if (!isHovering) {
        renderItems(sortCheckbox?.checked ?? false, showAvailableCheckbox?.checked ?? false);
      }
    }, 2e3);
  }
  function getItemValue(id, type) {
    const valueMap = {
      // Seeds (approximate values)
      MoonCelestial: 5e4,
      DawnCelestial: 45e3,
      Starweaver: 4e4,
      Lychee: 8e3,
      DragonFruit: 7e3,
      PassionFruit: 6e3,
      Sunflower: 5e3,
      Lemon: 4e3,
      Pepper: 3500,
      Grape: 3e3,
      Bamboo: 2500,
      Cactus: 2e3,
      Mushroom: 1800,
      BurrosTail: 1500,
      Lily: 1200,
      Banana: 1e3,
      Coconut: 900,
      Echeveria: 800,
      Pumpkin: 600,
      Watermelon: 500,
      Corn: 400,
      Daffodil: 300,
      Tomato: 250,
      OrangeTulip: 200,
      Apple: 150,
      Blueberry: 100,
      Aloe: 80,
      Strawberry: 60,
      Carrot: 40,
      // Eggs
      MythicalEgg: 1e4,
      LegendaryEgg: 5e3,
      RareEgg: 1e3,
      UncommonEgg: 200,
      CommonEgg: 50,
      // Tools (placeholder values)
      Shovel: 500,
      WateringCan: 300,
      PlanterPot: 200,
      Fertilizer: 200
    };
    return valueMap[id] || 100;
  }
  function getShopTabContent(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const inventory = UnifiedState3?.atoms?.inventory;
    const currentCount = inventory?.items?.length || 0;
    const maxCount = 100;
    let inventoryColor = "#4caf50";
    if (currentCount >= 100) {
      inventoryColor = "#ff4444";
    } else if (currentCount >= 95) {
      inventoryColor = "#ffa500";
    }
    return `
    <div class="mga-section">
      <div class="mga-section-title">\u{1F6D2} Shop</div>
      <p style="font-size: 12px; color: #aaa; margin-bottom: 8px;">
        Quick buy seeds and eggs. Stock updates automatically when shop resets.
      </p>

      <!-- Inventory counter -->
      <div id="shop-inventory-counter" style="
        font-size: 13px;
        font-weight: 600;
        color: ${inventoryColor};
        margin-bottom: 16px;
        padding: 8px 12px;
        background: rgba(255,255,255,0.05);
        border-radius: 6px;
        border-left: 3px solid ${inventoryColor};
        display: flex;
        align-items: center;
        gap: 8px;
      ">
        <span>\u{1F4E6}</span>
        <span>Inventory: <span id="shop-inventory-count">${currentCount}</span>/${maxCount}</span>
      </div>

      <div style="margin-bottom: 20px;">
        <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
          <input type="checkbox" id="shop-in-stock-only" class="mga-checkbox">
          <span>Show only items in stock</span>
        </label>
      </div>

      <div id="shop-seed-section" style="margin-bottom: 24px;">
        <h3 style="font-size: 14px; margin-bottom: 12px; color: #fff;">\u{1F331} Seeds</h3>
        <div id="shop-seed-list" style="display: grid; gap: 6px;"></div>
      </div>

      <div id="shop-egg-section">
        <h3 style="font-size: 14px; margin-bottom: 12px; color: #fff;">\u{1F95A} Eggs</h3>
        <div id="shop-egg-list" style="display: grid; gap: 6px;"></div>
      </div>
    </div>
  `;
  }
  function setupShopTabHandlers(context, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      SHOP_DISPLAY_NAMES: displayNames = SHOP_DISPLAY_NAMES,
      getItemStock: getStockFn = getItemStock,
      isInventoryFull: isInvFullFn = isInventoryFull,
      flashInventoryFullFeedback: flashInvFullFn = flashInventoryFullFeedback,
      getInventoryItemCount: getInvCountFn = getInventoryItemCount,
      getItemStackCap: getStackCapFn = getItemStackCap,
      getLocalPurchaseCount: getPurchaseCountFn = getLocalPurchaseCount,
      startInventoryCounter: startCounterFn = startInventoryCounter,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog,
      productionError: productionError2 = typeof window !== "undefined" && window.productionError,
      alert: alertFn = typeof window !== "undefined" ? window.alert : console.log,
      console: consoleObj = console
    } = dependencies;
    let contextLocal = context;
    if (!contextLocal) contextLocal = targetDocument2;
    if (!contextLocal) return;
    const inStockCheckbox = contextLocal.querySelector("#shop-in-stock-only");
    const seedList = contextLocal.querySelector("#shop-seed-list");
    const eggList = contextLocal.querySelector("#shop-egg-list");
    if (!seedList || !eggList) return;
    if (startCounterFn) {
      startCounterFn(dependencies);
    }
    const SEED_SPECIES = SEED_SPECIES_SHOP;
    const EGG_IDS = EGG_IDS_SHOP;
    function createShopItem(id, type) {
      if (!targetDocument2) return null;
      const item = targetDocument2.createElement("div");
      item.className = "shop-item";
      item.dataset.itemId = id;
      item.dataset.itemType = type;
      item.style.cssText = `
      padding: 10px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255, 255, 255, 0.57);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      transition: all 0.2s ease;
    `;
      const displayName = displayNames[id] || id.replace(/([A-Z])/g, " $1").trim();
      const stock = getTabItemStock(id, type);
      item.innerHTML = `
      <div style="flex: 1; min-width: 0;">
        <div style="font-weight: 600; font-size: 13px; color: #fff; margin-bottom: 2px;">${displayName}</div>
        <div class="stock-display" style="font-size: 11px; color: #888;">Stock: ${stock}</div>
      </div>
      <div style="display: flex; gap: 6px;">
        <button class="mga-btn mga-btn-secondary buy-one" ${stock === 0 ? "disabled" : ""}
          style="padding: 6px 12px; font-size: 12px;">Buy 1</button>
        <button class="mga-btn mga-btn-secondary buy-all" ${stock === 0 ? "disabled" : ""}
          style="padding: 6px 12px; font-size: 12px;">Buy All</button>
      </div>
    `;
      if (stock > 0) {
        item.style.background = "rgba(76, 255, 106, 0.40)";
        item.style.borderColor = "rgba(9, 255, 0, 0.48)";
      }
      const buyOneBtn = item.querySelector(".buy-one");
      const buyAllBtn = item.querySelector(".buy-all");
      if (buyOneBtn) {
        buyOneBtn.addEventListener("click", () => buyTabItem(id, type, 1, item));
      }
      if (buyAllBtn) {
        buyAllBtn.addEventListener("click", () => buyTabItem(id, type, stock, item));
      }
      return item;
    }
    function getTabItemStock(id, type) {
      try {
        const shop = targetWindow3?.globalShop?.shops;
        if (!shop) return 0;
        const inventory = type === "seed" ? shop.seed?.inventory : shop.egg?.inventory;
        if (!inventory) return 0;
        const item = inventory.find((i) => {
          const itemId = type === "seed" ? i.species : i.eggId;
          return itemId === id;
        });
        if (!item) return 0;
        const initial = item.initialStock || 0;
        const purchased = Math.min(getPurchaseCountFn(id, type, dependencies), initial);
        const stock = Math.max(0, initial - purchased);
        return stock;
      } catch (e) {
        if (productionError2) {
          productionError2("[SHOP-TAB] getItemStock error:", e);
        }
        return 0;
      }
    }
    function buyTabItem(id, type, amount, itemEl) {
      const conn = targetWindow3?.MagicCircle_RoomConnection;
      if (!conn?.sendMessage) {
        alertFn("Connection not available");
        return;
      }
      const inventory = UnifiedState3?.atoms?.inventory;
      const hasExistingStack = inventory?.items?.some((item) => {
        if (type === "seed") return item.species === id && item.itemType !== "Produce";
        if (type === "egg") return item.eggId === id;
        if (type === "tool") return item.toolId === id || item.name === id;
        return false;
      });
      if (isInvFullFn(dependencies) && !hasExistingStack) {
        flashInvFullFn(itemEl, `Inventory Full! (100/100) - Cannot purchase new items`, dependencies);
        if (consoleObj) {
          consoleObj.log(`[SHOP] Purchase blocked: Inventory full and no existing stack for ${id}`);
        }
        return;
      }
      if (hasExistingStack && consoleObj) {
        consoleObj.log(`[SHOP] \u2705 Inventory full but ${id} can stack on existing item`);
      }
      const currentCount = getInvCountFn(id, type, dependencies);
      const stackCap = getStackCapFn(id, type);
      if (currentCount >= stackCap) {
        const displayName = displayNames[id] || id.replace(/([A-Z])/g, " $1").trim();
        if (stackCap < Infinity) {
          flashInvFullFn(
            itemEl,
            `${displayName} at MAX! (${currentCount}/${stackCap}) - Cannot purchase more`,
            dependencies
          );
          const quantityDisplay = itemEl.querySelector(".quantity-display");
          if (quantityDisplay) {
            quantityDisplay.textContent = `Owned: ${currentCount}/${stackCap}`;
            quantityDisplay.style.color = "#ff4444";
            quantityDisplay.style.fontWeight = "bold";
          }
        } else {
          flashInvFullFn(itemEl, `${displayName} at max capacity! (${currentCount}/${stackCap})`, dependencies);
        }
        if (UnifiedState3?.data?.settings?.debugMode && consoleObj) {
          consoleObj.log(`[SHOP-TAB] \u274C Purchase blocked: ${id} at cap (${currentCount}/${stackCap})`);
        }
        return;
      }
      if (currentCount + amount > stackCap) {
        const displayName = displayNames[id] || id.replace(/([A-Z])/g, " $1").trim();
        const canPurchase = stackCap - currentCount;
        flashInvFullFn(
          itemEl,
          `Can only purchase ${canPurchase} more ${displayName} (currently ${currentCount}/${stackCap})`,
          dependencies
        );
        if (UnifiedState3?.data?.settings?.debugMode && consoleObj) {
          consoleObj.log(`[SHOP-TAB] \u274C Purchase blocked: would exceed cap (${currentCount} + ${amount} > ${stackCap})`);
        }
        return;
      }
      if (UnifiedState3?.data?.settings?.debugMode && consoleObj) {
        consoleObj.log(`[SHOP-TAB] \u2705 Purchase allowed: ${id} (${currentCount} + ${amount} <= ${stackCap})`);
      }
      try {
        for (let i = 0; i < amount; i += 1) {
          let messageType;
          let itemKey;
          if (type === "seed") {
            messageType = "PurchaseSeed";
            itemKey = "species";
          } else if (type === "egg") {
            messageType = "PurchaseEgg";
            itemKey = "eggId";
          } else if (type === "tool") {
            messageType = "PurchaseTool";
            itemKey = "toolId";
          }
          conn.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: messageType,
            [itemKey]: id
          });
        }
        setTimeout(() => {
          const newStock = getTabItemStock(id, type);
          const stockDisplay = itemEl.querySelector(".stock-display");
          if (stockDisplay) stockDisplay.textContent = `Stock: ${newStock}`;
          const quantityDiv = itemEl.querySelector(".quantity-display");
          if (quantityDiv) {
            const ownedCount = getInvCountFn(id, type, dependencies);
            const itemStackCap = getStackCapFn(id, type);
            if (itemStackCap < Infinity && ownedCount > 0) {
              const percentFull = ownedCount / itemStackCap * 100;
              let color = "rgba(255, 255, 255, 0.7)";
              if (percentFull >= 100) {
                color = "#ff4444";
              } else if (percentFull >= 80) {
                color = "#ffaa44";
              } else if (percentFull >= 50) {
                color = "#ffff44";
              }
              quantityDiv.style.color = color;
              quantityDiv.style.fontWeight = percentFull >= 100 ? "bold" : "normal";
              quantityDiv.textContent = `Owned: ${ownedCount}/${itemStackCap}`;
            } else if (ownedCount > 0) {
              quantityDiv.textContent = `Owned: ${ownedCount}`;
            }
          }
          const buttons = itemEl.querySelectorAll("button");
          buttons.forEach((btn) => {
            btn.disabled = newStock === 0;
          });
          if (newStock === 0) {
            itemEl.style.background = "rgba(255,255,255,0.03)";
            itemEl.style.borderColor = "rgba(255, 255, 255, 0.57)";
          }
          applyStockFilter();
        }, 100);
        if (productionLog3) {
          productionLog3(`\u2705 Purchased ${amount}x ${id}`);
        }
      } catch (e) {
        if (consoleObj) {
          consoleObj.error("Purchase error:", e);
        }
        alertFn("Purchase failed");
      }
    }
    function applyStockFilter() {
      if (!inStockCheckbox || !contextLocal) return;
      const showOnlyInStock = inStockCheckbox.checked;
      contextLocal.querySelectorAll(".shop-item").forEach((item) => {
        const id = item.dataset.itemId;
        const type = item.dataset.itemType;
        const stock = getTabItemStock(id, type);
        item.style.display = showOnlyInStock && stock === 0 ? "none" : "flex";
      });
    }
    SEED_SPECIES.forEach((species) => {
      const itemEl = createShopItem(species, "seed");
      if (itemEl) seedList.appendChild(itemEl);
    });
    EGG_IDS.forEach((eggId) => {
      const itemEl = createShopItem(eggId, "egg");
      if (itemEl) eggList.appendChild(itemEl);
    });
    if (inStockCheckbox) {
      inStockCheckbox.addEventListener("change", applyStockFilter);
    }
    const refreshInterval = setInterval(() => {
      if (!contextLocal || !contextLocal.querySelector("#shop-seed-list")) {
        clearInterval(refreshInterval);
        return;
      }
      contextLocal.querySelectorAll(".shop-item").forEach((item) => {
        const id = item.dataset.itemId;
        const type = item.dataset.itemType;
        const newStock = getTabItemStock(id, type);
        const stockDisplay = item.querySelector(".stock-display");
        if (stockDisplay) stockDisplay.textContent = `Stock: ${newStock}`;
        const buttons = item.querySelectorAll("button");
        buttons.forEach((btn) => {
          btn.disabled = newStock === 0;
        });
        if (newStock > 0) {
          item.style.background = "rgba(76, 255, 106, 0.40)";
          item.style.borderColor = "rgba(9, 255, 0, 0.48)";
        } else {
          item.style.background = "rgba(255,255,255,0.03)";
          item.style.borderColor = "rgba(255, 255, 255, 0.57)";
        }
      });
      applyStockFilter();
    }, 2e3);
  }
  var shopWatcherInitialized = false;
  var lastEggSeconds = null;
  var eggWasDecreasing = false;
  var refreshDebounceTimer = null;
  function checkForWatchedItems(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      isWatchedItem: isWatchedItem2 = typeof window !== "undefined" && window.isWatchedItem,
      updateLastSeen: updateLastSeen2 = typeof window !== "undefined" && window.updateLastSeen,
      queueNotification: queueNotification2 = typeof window !== "undefined" && window.queueNotification,
      playShopNotificationSound: playShopNotificationSound2 = typeof window !== "undefined" && window.playShopNotificationSound,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog,
      console: consoleObj = console
    } = dependencies;
    const notifications = UnifiedState3?.data?.settings?.notifications;
    if (!notifications || !notifications.enabled) return;
    try {
      const now = Date.now();
      const detectedItems = [];
      const CHECK_INTERVAL = 5e3;
      const SMALL_EDGE = 5;
      const LARGE_EDGE = 180;
      const BIG_JUMP_DELTA = 60;
      const RESTOCK_COOLDOWN = 3e4;
      const NOTIFICATION_COOLDOWN = 6e4;
      if (!checkForWatchedItems._state) {
        checkForWatchedItems._state = {
          lastRestockCheck: 0,
          lastSeedTimer: 999,
          lastEggTimer: 999,
          lastDecorTimer: 999,
          lastSeedRestock: 0,
          lastEggRestock: 0,
          lastDecorRestock: 0,
          previousSeedInventory: [],
          previousSeedQuantities: {},
          previousEggInventory: [],
          previousEggQuantities: {},
          previousDecorInventory: [],
          previousDecorQuantities: {},
          seedRestockNotifiedItems: /* @__PURE__ */ new Set(),
          eggRestockNotifiedItems: /* @__PURE__ */ new Set(),
          decorRestockNotifiedItems: /* @__PURE__ */ new Set(),
          isFirstRun: true
        };
      }
      const state = checkForWatchedItems._state;
      if (now - state.lastRestockCheck < CHECK_INTERVAL) return;
      state.lastRestockCheck = now;
      const quinoaData = UnifiedState3?.atoms?.quinoaData || targetWindow3?.globalShop;
      if (!quinoaData && !targetWindow3?.globalShop) return;
      const shopData = targetWindow3?.globalShop || UnifiedState3?.atoms?.quinoaData || quinoaData;
      const seedTimer = shopData?.shops?.seed?.secondsUntilRestock || 999;
      const eggTimer = shopData?.shops?.egg?.secondsUntilRestock || 999;
      const decorTimer = shopData?.shops?.decor?.secondsUntilRestock || 999;
      const seedRestocked = state.lastSeedTimer <= SMALL_EDGE && seedTimer >= LARGE_EDGE || seedTimer - state.lastSeedTimer >= BIG_JUMP_DELTA && state.lastSeedTimer > 0;
      const eggRestocked = state.lastEggTimer <= SMALL_EDGE && eggTimer >= LARGE_EDGE || eggTimer - state.lastEggTimer >= BIG_JUMP_DELTA && state.lastEggTimer > 0;
      const decorRestocked = state.lastDecorTimer <= SMALL_EDGE && decorTimer >= LARGE_EDGE || decorTimer - state.lastDecorTimer >= BIG_JUMP_DELTA && state.lastDecorTimer > 0;
      if (seedRestocked) {
        if (productionLog3) {
          productionLog3(`\u{1F504} [NOTIFICATIONS] SEED SHOP RESTOCKED! (Edge detection: ${state.lastSeedTimer}\u2192${seedTimer})`);
        }
        state.previousSeedInventory = [];
        state.previousSeedQuantities = {};
        state.seedRestockNotifiedItems.clear();
        state.lastSeedRestock = now;
      }
      if (eggRestocked) {
        if (productionLog3) {
          productionLog3(`\u{1F504} [NOTIFICATIONS] EGG SHOP RESTOCKED! (Edge detection: ${state.lastEggTimer}\u2192${eggTimer})`);
        }
        state.previousEggInventory = [];
        state.previousEggQuantities = {};
        state.eggRestockNotifiedItems.clear();
        state.lastEggRestock = now;
      }
      if (decorRestocked) {
        if (productionLog3) {
          productionLog3(
            `\u{1F504} [NOTIFICATIONS] DECOR SHOP RESTOCKED! (Edge detection: ${state.lastDecorTimer}\u2192${decorTimer})`
          );
        }
        state.previousDecorInventory = [];
        state.previousDecorQuantities = {};
        state.decorRestockNotifiedItems.clear();
        state.lastDecorRestock = now;
      }
      state.lastSeedTimer = seedTimer;
      state.lastEggTimer = eggTimer;
      state.lastDecorTimer = decorTimer;
      const currentSeeds = targetWindow3?.globalShop?.shops?.seed?.inventory || [];
      const inStockSeeds = currentSeeds.filter((item) => item.initialStock > 0);
      const currentSeedIds = inStockSeeds.map((item) => item.species);
      const currentSeedQuantities = {};
      inStockSeeds.forEach((item) => {
        currentSeedQuantities[item.species] = item.initialStock;
      });
      if (Object.keys(state.previousSeedQuantities).length === 0 && !seedRestocked) {
        if (productionLog3) {
          productionLog3(`\u{1F527} [NOTIFICATIONS] Initializing previous seed quantities...`);
        }
        Object.keys(currentSeedQuantities).forEach((seedId) => {
          state.previousSeedQuantities[seedId] = currentSeedQuantities[seedId];
        });
      }
      if (productionLog3) {
        productionLog3(
          `\u{1F6D2} [NOTIFICATIONS] Current seed quantities:`,
          currentSeedQuantities,
          `| Previous:`,
          state.previousSeedQuantities
        );
      }
      Object.keys(currentSeedQuantities).forEach((seedId) => {
        const oldQuantity = state.previousSeedQuantities[seedId] || 0;
        const newQuantity = currentSeedQuantities[seedId];
        if (productionLog3) {
          productionLog3(`\u{1F50D} [NOTIFICATIONS] Processing seed: ${seedId} (${oldQuantity}\u2192${newQuantity})`);
        }
        const quantityIncreased = newQuantity > oldQuantity;
        const isRestockWindow = seedRestocked && now - state.lastSeedRestock < RESTOCK_COOLDOWN;
        const alreadyNotifiedInRestock = state.seedRestockNotifiedItems.has(seedId);
        if (productionLog3) {
          productionLog3(
            `\u{1F50D} [NOTIFICATIONS] ${seedId} check logic: quantityIncreased=${quantityIncreased}, isRestockWindow=${isRestockWindow}, alreadyNotifiedInRestock=${alreadyNotifiedInRestock}`
          );
        }
        const shouldCheck = state.isFirstRun && newQuantity > 0 || quantityIncreased && !isRestockWindow || isRestockWindow && !alreadyNotifiedInRestock || oldQuantity === 0 && newQuantity > 0;
        if (productionLog3) {
          productionLog3(`\u{1F50D} [NOTIFICATIONS] ${seedId} shouldCheck: ${shouldCheck}`);
        }
        if (shouldCheck) {
          if (productionLog3) {
            productionLog3(
              `\u{1F195} [NOTIFICATIONS] Seed stock change: ${seedId} (${oldQuantity}\u2192${newQuantity}) | Restock: ${seedRestocked} | RestockWindow: ${isRestockWindow}`
            );
          }
          if (updateLastSeen2) {
            updateLastSeen2(seedId);
          }
          const isWatched = isWatchedItem2 ? isWatchedItem2(seedId, "seed") : false;
          if (productionLog3) {
            productionLog3(`\u{1F50D} [NOTIFICATIONS] Is ${seedId} watched? ${isWatched}`);
          }
          if (isWatched) {
            const itemKey = `seed_${seedId}`;
            const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
            const canNotify = now - lastNotified > NOTIFICATION_COOLDOWN;
            if (productionLog3) {
              productionLog3(
                `\u{1F50D} [NOTIFICATIONS] ${seedId} cooldown check: lastNotified=${lastNotified}, now=${now}, diff=${now - lastNotified}, canNotify=${canNotify}`
              );
            }
            if (canNotify) {
              if (productionLog3) {
                productionLog3(`\u{1F389} [NOTIFICATIONS] RARE SEED DETECTED: ${seedId} (${newQuantity} in stock)`);
              }
              notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;
              if (isRestockWindow) {
                state.seedRestockNotifiedItems.add(seedId);
              }
              if (MGA_saveJSON2) {
                MGA_saveJSON2("MGA_data", UnifiedState3.data);
              }
              detectedItems.push({
                type: "seed",
                id: seedId,
                quantity: newQuantity,
                icon: "\u{1F331}"
              });
            } else if (productionLog3) {
              productionLog3(`\u23F0 [NOTIFICATIONS] ${seedId} on cooldown, not notifying`);
            }
          } else if (productionLog3) {
            productionLog3(`\u274C [NOTIFICATIONS] ${seedId} is not watched, skipping notification`);
          }
        } else if (productionLog3) {
          productionLog3(`\u23ED\uFE0F [NOTIFICATIONS] ${seedId} shouldCheck=false, skipping`);
        }
      });
      if (productionLog3) {
        productionLog3(`\u2705 [NOTIFICATIONS] Finished checking seeds, moving to eggs...`);
      }
      let currentEggIds = [];
      const currentEggQuantities = {};
      try {
        if (productionLog3) {
          productionLog3(`\u{1F95A} [NOTIFICATIONS] === CHECKING EGG SHOP ===`);
        }
        const currentEggs = targetWindow3?.globalShop?.shops?.egg?.inventory || [];
        const inStockEggs = currentEggs.filter((item) => item.initialStock > 0);
        currentEggIds = inStockEggs.map((item) => item.eggId);
        if (productionLog3) {
          productionLog3(
            `\u{1F95A} [NOTIFICATIONS] Current eggs in shop: [${currentEggIds.join(", ")}] | Previous: [${state.previousEggInventory.join(", ")}]`
          );
        }
        inStockEggs.forEach((item) => {
          currentEggQuantities[item.eggId] = item.initialStock;
        });
        if (Object.keys(state.previousEggQuantities).length === 0 && !eggRestocked) {
          if (productionLog3) {
            productionLog3(`\u{1F527} [NOTIFICATIONS] Initializing previous egg quantities...`);
          }
          Object.keys(currentEggQuantities).forEach((eggId) => {
            state.previousEggQuantities[eggId] = currentEggQuantities[eggId];
          });
        }
        if (productionLog3) {
          productionLog3(
            `\u{1F95A} [NOTIFICATIONS] Current egg quantities:`,
            currentEggQuantities,
            `| Previous:`,
            state.previousEggQuantities
          );
        }
        Object.keys(currentEggQuantities).forEach((eggId) => {
          const oldQuantity = state.previousEggQuantities[eggId] || 0;
          const newQuantity = currentEggQuantities[eggId];
          if (productionLog3) {
            productionLog3(`\u{1F50D} [NOTIFICATIONS] Processing egg: ${eggId} (${oldQuantity}\u2192${newQuantity})`);
          }
          const quantityIncreased = newQuantity > oldQuantity;
          const isRestockWindow = eggRestocked && now - state.lastEggRestock < RESTOCK_COOLDOWN;
          const alreadyNotifiedInRestock = state.eggRestockNotifiedItems.has(eggId);
          const shouldCheck = state.isFirstRun && newQuantity > 0 || quantityIncreased && !isRestockWindow || isRestockWindow && !alreadyNotifiedInRestock || oldQuantity === 0 && newQuantity > 0;
          if (shouldCheck) {
            if (updateLastSeen2) {
              updateLastSeen2(eggId);
            }
            const isWatched = isWatchedItem2 ? isWatchedItem2(eggId, "egg") : false;
            if (isWatched) {
              const itemKey = `egg_${eggId}`;
              const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
              const canNotify = now - lastNotified > NOTIFICATION_COOLDOWN;
              if (canNotify) {
                if (productionLog3) {
                  productionLog3(`\u{1F389} [NOTIFICATIONS] RARE EGG DETECTED: ${eggId} (${newQuantity} in stock)`);
                }
                notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;
                if (isRestockWindow) {
                  state.eggRestockNotifiedItems.add(eggId);
                }
                if (MGA_saveJSON2) {
                  MGA_saveJSON2("MGA_data", UnifiedState3.data);
                }
                detectedItems.push({
                  type: "egg",
                  id: eggId,
                  quantity: newQuantity,
                  icon: "\u{1F95A}"
                });
              }
            }
          }
        });
        if (productionLog3) {
          productionLog3(`\u2705 [NOTIFICATIONS] Finished checking all eggs`);
        }
        state.previousEggInventory = [...currentEggIds];
        state.previousEggQuantities = { ...currentEggQuantities };
      } catch (eggError) {
        if (consoleObj) {
          consoleObj.error(`\u274C [NOTIFICATIONS] Error checking eggs:`, eggError);
        }
      }
      if (productionLog3) {
        productionLog3(`\u2705 [NOTIFICATIONS] Finished checking eggs, moving to decor...`);
      }
      let currentDecorIds = [];
      const currentDecorQuantities = {};
      try {
        if (!notifications.watchedDecor) {
          notifications.watchedDecor = [];
        }
        if (productionLog3) {
          productionLog3(`\u{1F3A8} [NOTIFICATIONS] === CHECKING DECOR SHOP ===`);
        }
        const currentDecor = targetWindow3?.globalShop?.shops?.decor?.inventory || [];
        const inStockDecor = currentDecor.filter((item) => item.initialStock > 0);
        currentDecorIds = inStockDecor.map((item) => item.decorId);
        if (productionLog3) {
          productionLog3(
            `\u{1F3A8} [NOTIFICATIONS] Current decor in shop: [${currentDecorIds.join(", ")}] | Previous: [${state.previousDecorInventory.join(", ")}]`
          );
        }
        inStockDecor.forEach((item) => {
          currentDecorQuantities[item.decorId] = item.initialStock;
        });
        if (Object.keys(state.previousDecorQuantities).length === 0 && !decorRestocked) {
          if (productionLog3) {
            productionLog3(`\u{1F527} [NOTIFICATIONS] Initializing previous decor quantities...`);
          }
          Object.keys(currentDecorQuantities).forEach((decorId) => {
            state.previousDecorQuantities[decorId] = currentDecorQuantities[decorId];
          });
        }
        Object.keys(currentDecorQuantities).forEach((decorId) => {
          const oldQuantity = state.previousDecorQuantities[decorId] || 0;
          const newQuantity = currentDecorQuantities[decorId];
          const quantityIncreased = newQuantity > oldQuantity;
          const isRestockWindow = decorRestocked && now - state.lastDecorRestock < RESTOCK_COOLDOWN;
          const alreadyNotifiedInRestock = state.decorRestockNotifiedItems.has(decorId);
          const shouldCheck = state.isFirstRun && newQuantity > 0 || quantityIncreased && !isRestockWindow || isRestockWindow && !alreadyNotifiedInRestock || oldQuantity === 0 && newQuantity > 0;
          if (shouldCheck) {
            if (updateLastSeen2) {
              updateLastSeen2(decorId);
            }
            const isWatched = isWatchedItem2 ? isWatchedItem2(decorId, "decor") : false;
            if (isWatched) {
              const itemKey = `decor_${decorId}`;
              const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
              const canNotify = now - lastNotified > NOTIFICATION_COOLDOWN;
              if (canNotify) {
                if (productionLog3) {
                  productionLog3(`\u{1F389} [NOTIFICATIONS] WATCHED DECOR DETECTED: ${decorId} (${newQuantity} in stock)`);
                }
                notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;
                if (isRestockWindow) {
                  state.decorRestockNotifiedItems.add(decorId);
                }
                if (MGA_saveJSON2) {
                  MGA_saveJSON2("MGA_data", UnifiedState3.data);
                }
                detectedItems.push({
                  type: "decor",
                  id: decorId,
                  quantity: newQuantity,
                  icon: "\u{1F3A8}"
                });
              }
            }
          }
        });
        if (productionLog3) {
          productionLog3(`\u2705 [NOTIFICATIONS] Finished checking all decor`);
        }
        state.previousDecorInventory = [...currentDecorIds];
        state.previousDecorQuantities = { ...currentDecorQuantities };
      } catch (decorError) {
        if (consoleObj) {
          consoleObj.error(`\u274C [NOTIFICATIONS] Error checking decor:`, decorError);
        }
      }
      if (detectedItems.length > 0) {
        if (productionLog3) {
          productionLog3(`\u{1F389} [NOTIFICATIONS] Batch detected: ${detectedItems.length} items`);
        }
        const volume = UnifiedState3?.data?.settings?.notifications?.volume || 0.3;
        if (playShopNotificationSound2) {
          playShopNotificationSound2(volume);
        }
        let notificationMessage;
        if (detectedItems.length === 1) {
          const item = detectedItems[0];
          notificationMessage = `${item.icon} Rare ${item.type} in shop: ${item.id}! (${item.quantity} available)`;
        } else {
          notificationMessage = `\u{1F389} Multiple items in stock:
`;
          detectedItems.forEach((item) => {
            notificationMessage += `${item.icon} ${item.id} (${item.quantity} available)
`;
          });
        }
        if (queueNotification2) {
          queueNotification2(notificationMessage.trim(), notifications.requiresAcknowledgment);
        }
        if (productionLog3) {
          productionLog3(`\u{1F4E2} [NOTIFICATIONS] Batched notification sent for ${detectedItems.length} items`);
        }
      }
      state.previousSeedInventory = [...currentSeedIds];
      state.previousSeedQuantities = { ...currentSeedQuantities };
      if (state.isFirstRun) {
        if (productionLog3) {
          productionLog3(`\u2705 [NOTIFICATIONS] First run complete - will now only notify on changes`);
        }
        state.isFirstRun = false;
      }
    } catch (error) {
      if (consoleObj) {
        consoleObj.error("\u274C [NOTIFICATIONS] Error checking for watched items:", error);
        consoleObj.error("Stack trace:", error.stack);
      }
    }
  }
  function scheduleRefresh(type, shopValue, dependencies = {}) {
    const {
      checkForWatchedItems: checkWatchedFn = checkForWatchedItems,
      refreshAllShopWindows: refreshWindowsFn = refreshAllShopWindows,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog
    } = dependencies;
    if (refreshDebounceTimer) {
      clearTimeout(refreshDebounceTimer);
    }
    refreshDebounceTimer = setTimeout(() => {
      if (productionLog3) {
        productionLog3(`\u{1F504} [SHOP-REFRESH] Refreshing ${type} shop after pattern-based restock detection`);
      }
      if (checkWatchedFn) {
        checkWatchedFn(dependencies);
      }
      if (refreshWindowsFn) {
        refreshWindowsFn(dependencies);
      }
      refreshDebounceTimer = null;
    }, 100);
  }
  function handleEggRestockDetection(curr, shopValue, dependencies = {}) {
    const {
      resetLocalPurchases: resetPurchasesFn = resetLocalPurchases,
      scheduleRefresh: scheduleRefreshFn = scheduleRefresh,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog
    } = dependencies;
    if (lastEggSeconds === null) {
      lastEggSeconds = curr;
      return;
    }
    if (curr < lastEggSeconds) {
      eggWasDecreasing = true;
    } else if (eggWasDecreasing && curr > lastEggSeconds + 2) {
      if (productionLog3) {
        productionLog3("\u{1F423} Egg restock detected (pattern-based jump)", { curr, lastEggSeconds });
      }
      eggWasDecreasing = false;
      lastEggSeconds = curr;
      if (resetPurchasesFn) {
        resetPurchasesFn("egg", dependencies);
      }
      if (scheduleRefreshFn) {
        scheduleRefreshFn("egg", shopValue, dependencies);
      }
      return;
    }
    lastEggSeconds = curr;
  }
  function initializeToolRestockWatcher(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      setManagedInterval: setManagedInterval2 = typeof window !== "undefined" && window.setManagedInterval,
      resetLocalPurchases: resetPurchasesFn = resetLocalPurchases,
      scheduleRefresh: scheduleRefreshFn = scheduleRefresh,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog
    } = dependencies;
    if (!setManagedInterval2) return;
    let toolWasDecreasing = false;
    let lastToolSeconds = 0;
    setManagedInterval2(
      "toolRestockWatch",
      () => {
        const toolShop = targetWindow3?.globalShop?.shops?.tool;
        if (!toolShop || !toolShop.secondsUntilRestock) return;
        const curr = toolShop.secondsUntilRestock;
        if (curr < lastToolSeconds) {
          toolWasDecreasing = true;
        } else if (toolWasDecreasing && curr > lastToolSeconds + 2) {
          if (productionLog3) {
            productionLog3("\u{1F527} Tool restock detected (pattern-based jump)", { curr, lastToolSeconds });
          }
          toolWasDecreasing = false;
          lastToolSeconds = curr;
          if (resetPurchasesFn) {
            resetPurchasesFn("tool", dependencies);
          }
          if (scheduleRefreshFn) {
            scheduleRefreshFn("tool", toolShop, dependencies);
          }
        }
        lastToolSeconds = curr;
      },
      1e3
    );
  }
  function initializeShopWatcher(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      checkForWatchedItems: checkWatchedFn = checkForWatchedItems,
      refreshAllShopWindows: refreshWindowsFn = refreshAllShopWindows,
      resetLocalPurchases: resetPurchasesFn = resetLocalPurchases,
      handleEggRestockDetection: handleEggRestockFn = handleEggRestockDetection,
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog,
      productionWarn: productionWarn3 = typeof window !== "undefined" && window.productionWarn
    } = dependencies;
    if (shopWatcherInitialized) return;
    if (productionLog3) {
      productionLog3("\u{1F504} [SHOP-WATCHER] Initializing event-driven shop monitoring...");
    }
    function watchShopData() {
      if (!targetWindow3 || !targetWindow3.globalShop) {
        if (productionWarn3) {
          productionWarn3("\u26A0\uFE0F [SHOP-WATCHER] globalShop not found, will retry...");
        }
        setTimeout(() => watchShopData(), 5e3);
        return;
      }
      if (productionLog3) {
        productionLog3("\u2705 [SHOP-WATCHER] Found globalShop, setting up watchers...");
      }
      let lastSeedRestock = 0;
      let lastEggRestock = 0;
      let lastDecorRestock = 0;
      setInterval(() => {
        try {
          if (!targetWindow3.globalShop || !targetWindow3.globalShop.shops) return;
          const shops = targetWindow3.globalShop.shops;
          if (shops.seed) {
            const currentRestock = shops.seed.secondsUntilRestock || 0;
            if (lastSeedRestock > 100 && currentRestock > lastSeedRestock) {
              if (productionLog3) {
                productionLog3("\u{1F504} [SHOP-WATCHER] Seed shop restocked");
              }
              if (resetPurchasesFn) {
                resetPurchasesFn("seed", dependencies);
              }
              setTimeout(() => {
                if (checkWatchedFn) {
                  checkWatchedFn(dependencies);
                }
                if (refreshWindowsFn) {
                  refreshWindowsFn(dependencies);
                }
              }, 0);
            }
            lastSeedRestock = currentRestock;
          }
          if (shops.egg) {
            const currentRestock = shops.egg.secondsUntilRestock || 0;
            if (typeof currentRestock === "number" && handleEggRestockFn) {
              handleEggRestockFn(currentRestock, shops.egg, dependencies);
            }
            if (lastEggRestock > 100 && currentRestock > lastEggRestock) {
              if (productionLog3) {
                productionLog3("\u{1F504} [SHOP-WATCHER] Egg shop restocked (fallback detection)");
              }
              if (resetPurchasesFn) {
                resetPurchasesFn("egg", dependencies);
              }
              setTimeout(() => {
                if (checkWatchedFn) {
                  checkWatchedFn(dependencies);
                }
                if (refreshWindowsFn) {
                  refreshWindowsFn(dependencies);
                }
              }, 0);
            }
            lastEggRestock = currentRestock;
          }
          if (shops.decor) {
            const currentRestock = shops.decor.secondsUntilRestock || 0;
            if (lastDecorRestock > 100 && currentRestock > lastDecorRestock) {
              if (productionLog3) {
                productionLog3("\u{1F504} [SHOP-WATCHER] Decor shop restocked");
              }
              setTimeout(() => {
                if (checkWatchedFn) {
                  checkWatchedFn(dependencies);
                }
              }, 0);
            }
            lastDecorRestock = currentRestock;
          }
        } catch (e) {
        }
      }, 5e3);
      if (productionLog3) {
        productionLog3("\u2705 [SHOP-WATCHER] Using lightweight restock detection (5s interval)");
      }
      const globalShopDescriptor = Object.getOwnPropertyDescriptor(targetWindow3, "globalShop");
      if (!globalShopDescriptor || globalShopDescriptor.configurable !== false) {
        Object.defineProperty(targetWindow3, "globalShop", {
          get() {
            return this._globalShop;
          },
          set(newValue) {
            if (productionLog3) {
              productionLog3("\u{1F504} [SHOP-WATCHER] globalShop replaced entirely!");
            }
            this._globalShop = newValue;
            shopWatcherInitialized = false;
            setTimeout(() => initializeShopWatcher(dependencies), 100);
            setTimeout(() => {
              if (checkWatchedFn) {
                checkWatchedFn(dependencies);
              }
            }, 0);
          },
          configurable: true
        });
        targetWindow3._globalShop = targetWindow3.globalShop;
        if (productionLog3) {
          productionLog3("\u2705 [SHOP-WATCHER] globalShop setter installed");
        }
      }
      shopWatcherInitialized = true;
    }
    watchShopData();
  }
  var shop_default = {
    // Phase 1: Constants & Utilities
    SHOP_IMAGE_MAP,
    SHOP_COLOR_GROUPS,
    SHOP_RAINBOW_ITEMS,
    SHOP_PRICES,
    SHOP_DISPLAY_NAMES,
    formatShopPrice,
    normalizeShopKey,
    getShopItemColorClass,
    preloadShopImages,
    flashPurchaseFeedback,
    showFloatingMsg,
    // Phase 2: Inventory & Stock Management
    loadPurchaseTracker,
    savePurchaseTracker,
    trackLocalPurchase,
    getLocalPurchaseCount,
    resetLocalPurchases,
    isInventoryFull,
    getInventoryItemCount,
    getItemStackCap,
    flashInventoryFullFeedback,
    getItemStock,
    // Phase 3: Shop Item Elements & Purchase Logic
    isShopDataReady,
    waitForShopData,
    createShopItemElement,
    buyItem,
    // Phase 4: Shop Windows & Overlays
    SEED_SPECIES_SHOP,
    EGG_IDS_SHOP,
    refreshAllShopWindows,
    createShopOverlay,
    createShopSidebar,
    updateInventoryCounters,
    startInventoryCounter,
    stopInventoryCounter,
    toggleShopWindows,
    createShopSidebars,
    createShopWindow,
    makeShopWindowDraggable,
    setupShopWindowHandlers,
    getItemValue,
    // Phase 5: Shop Tab Content
    getShopTabContent,
    setupShopTabHandlers,
    // Phase 6: Shop Monitoring & Restock Detection
    checkForWatchedItems,
    scheduleRefresh,
    handleEggRestockDetection,
    initializeToolRestockWatcher,
    initializeShopWatcher
  };

  // src/init/modular-bootstrap.js
  function initializeModular({ targetDocument: targetDocument2, targetWindow: targetWindow3 }) {
    productionLog2("[MGTools v2.1] \u{1F680} Starting Simplified Modular Bootstrap...");
    try {
      productionLog2("[MGTools] Step 1: Loading saved data...");
      const savedData = MGA_loadJSON("MGA_data", null);
      if (savedData && typeof savedData === "object") {
        Object.assign(UnifiedState2.data, savedData);
        productionLog2("[MGTools] \u2705 Loaded saved data from storage");
      } else {
        productionLog2("[MGTools] Using default settings (no saved data found)");
      }
      productionLog2("[MGTools] Step 2: Creating UI...");
      const contentGetters = {
        getPetsTabContent: () => getPetsTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getPetsPopoutContent: () => getPetsPopoutContent(),
        getAbilitiesTabContent: () => getAbilitiesTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getSeedsTabContent: () => getSeedsTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getShopTabContent: () => getShopTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getValuesTabContent: () => getValuesTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getTimersTabContent: () => getTimersTabContent(),
        getRoomStatusTabContent: () => getRoomStatusTabContent2({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getToolsTabContent: () => getToolsTabContent(),
        getSettingsTabContent: () => getSettingsTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getHotkeysTabContent: () => getHotkeysTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getNotificationsTabContent: () => getNotificationsTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getProtectTabContent: () => getProtectTabContent({ UnifiedState: UnifiedState2, targetDocument: targetDocument2 }),
        getHelpTabContent: () => getHelpTabContent()
      };
      const updateTabContent = () => {
        const contentEl = targetDocument2.querySelector("#mga-tab-content");
        if (!contentEl) return;
        const tabName = UnifiedState2.activeTab;
        if (!tabName) return;
        try {
          const content = getContentForTab({ contentGetters }, tabName, false);
          contentEl.innerHTML = content;
        } catch (error) {
          debugError("[MGTools] Failed to update tab content:", error);
          contentEl.innerHTML = '<div style="padding: 20px; color: #ff6b6b;">Error loading content</div>';
        }
      };
      const minimalUIConfig = {
        targetDocument: targetDocument2,
        productionLog: productionLog2,
        UnifiedState: UnifiedState2,
        // Simple wrapper for drag functionality
        makeDockDraggable: (dock) => {
          makeDraggable(dock, dock, {
            targetDocument: targetDocument2,
            debugLog: debugLog2,
            saveMainHUDPosition: (pos) => saveDockPosition(pos)
          });
        },
        // WIRED: openSidebarTab - now functional with updateTabContent
        openSidebarTab: (tabName) => {
          openSidebarTab({ targetDocument: targetDocument2, UnifiedState: UnifiedState2, updateTabContent }, tabName);
        },
        // STUBBED: Shop windows toggle
        toggleShopWindows: () => {
          productionLog2("[MGTools] \u26A0\uFE0F toggleShopWindows() called but not wired yet");
        },
        // STUBBED: openPopoutWidget - needs many dependencies
        openPopoutWidget: (tabName) => {
          productionLog2(`[MGTools] \u26A0\uFE0F openPopoutWidget('${tabName}') called but not fully wired yet`);
        },
        // STUBBED: Version checker
        checkVersion: () => {
          productionLog2("[MGTools] \u26A0\uFE0F checkVersion() called but not wired yet");
        },
        // Dock orientation management - uses localStorage to match overlay.js expectations
        saveDockOrientation: (orientation) => {
          try {
            localStorage.setItem("mgh_dock_orientation", orientation);
          } catch (e) {
            debugError("[MGTools] Failed to save dock orientation:", e);
          }
        },
        loadDockOrientation: () => {
          try {
            return localStorage.getItem("mgh_dock_orientation") || "horizontal";
          } catch (e) {
            return "horizontal";
          }
        },
        // Dock position loading - uses localStorage and returns {left, top} object
        // Note: saving is handled by saveDockPosition from overlay.js (called via makeDraggable)
        loadDockPosition: () => {
          try {
            const saved = localStorage.getItem("mgh_dock_position");
            if (saved) {
              const position = JSON.parse(saved);
              if (position && typeof position.left === "number" && typeof position.top === "number") {
                return position;
              }
            }
            return null;
          } catch (e) {
            debugError("[MGTools] Failed to load dock position:", e);
            return null;
          }
        },
        // Theme system (wired)
        generateThemeStyles: (theme) => generateThemeStyles(theme),
        applyAccentToDock: (gradient) => applyAccentToDock(gradient, { targetDocument: targetDocument2 }),
        applyAccentToSidebar: (gradient) => applyAccentToSidebar(gradient, { targetDocument: targetDocument2 }),
        applyThemeToDock: (theme) => applyThemeToDock(theme, { targetDocument: targetDocument2 }),
        applyThemeToSidebar: (theme) => applyThemeToSidebar(theme, { targetDocument: targetDocument2 }),
        // Environment detection
        isDiscordEnv: targetWindow3.location.href?.includes("discordsays.com") || false,
        // Constants
        UNIFIED_STYLES,
        CURRENT_VERSION: CONFIG.CURRENT_VERSION || "2.1.0",
        IS_LIVE_BETA: CONFIG.IS_LIVE_BETA || false
      };
      createUnifiedUI(minimalUIConfig);
      productionLog2("[MGTools] \u2705 UI created (minimal version)");
      productionLog2("[MGTools] \u2705 Initialization complete (minimal)");
      productionLog2("[MGTools] \u26A0\uFE0F Note: Many features are stubbed - will wire incrementally");
      return true;
    } catch (error) {
      debugError("[MGTools] \u274C Initialization failed:", error);
      debugError("[MGTools] Stack:", error.stack);
      return false;
    }
  }

  // src/features/hotkeys.js
  var hotkeys_exports = {};
  __export(hotkeys_exports, {
    default: () => hotkeys_default,
    getProperKeyCode: () => getProperKeyCode,
    handleHotkeyPress: () => handleHotkeyPress,
    handleHotkeyRelease: () => handleHotkeyRelease,
    initializeHotkeySystem: () => initializeHotkeySystem,
    isTypingInInput: () => isTypingInInput,
    matchesKeyCombo: () => matchesKeyCombo,
    parseKeyCombo: () => parseKeyCombo,
    setupHotkeysTabHandlers: () => setupHotkeysTabHandlers,
    shouldBlockHotkey: () => shouldBlockHotkey,
    simulateKeyDown: () => simulateKeyDown,
    simulateKeyUp: () => simulateKeyUp,
    startRecordingHotkey: () => startRecordingHotkey,
    startRecordingHotkeyMGTools: () => startRecordingHotkeyMGTools,
    stopRecordingHotkey: () => stopRecordingHotkey
  });
  var currentlyRecordingHotkey = null;
  function startRecordingHotkey(key, buttonElement, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      productionLog: productionLog3 = console.log,
      updateTabContent = typeof window !== "undefined" && window.updateTabContent,
      stopRecordingHotkey: stopRecordingFn = stopRecordingHotkey,
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null
    } = dependencies;
    if (currentlyRecordingHotkey) return;
    currentlyRecordingHotkey = key;
    const originalText = buttonElement.textContent;
    buttonElement.textContent = "Press any key...";
    buttonElement.style.background = "#ff9900";
    const recordHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (["Control", "Alt", "Shift", "Meta"].includes(e.key)) return;
      if (e.key === "Escape") {
        stopRecordingFn(buttonElement, originalText, dependencies);
        targetDocument2.removeEventListener("keydown", recordHandler, true);
        return;
      }
      let keyCombo = "";
      if (e.ctrlKey) keyCombo += "ctrl+";
      if (e.altKey) keyCombo += "alt+";
      if (e.shiftKey) keyCombo += "shift+";
      const keyName = e.key === " " ? "space" : e.key.toLowerCase();
      keyCombo += keyName;
      const conflicts = [];
      Object.entries(UnifiedState3.data.hotkeys.gameKeys).forEach(([k, config2]) => {
        if (k !== key && config2.custom && config2.custom === keyCombo) {
          conflicts.push(config2.name);
        }
      });
      if (conflicts.length > 0) {
        alert(`Key "${keyCombo}" is already assigned to: ${conflicts.join(", ")}`);
        stopRecordingFn(buttonElement, originalText, dependencies);
        targetDocument2.removeEventListener("keydown", recordHandler, true);
        return;
      }
      UnifiedState3.data.hotkeys.gameKeys[key].custom = keyCombo;
      MGA_saveJSON2("MGA_hotkeys", UnifiedState3.data.hotkeys);
      stopRecordingFn(buttonElement, null, dependencies);
      if (updateTabContent) updateTabContent();
      targetDocument2.removeEventListener("keydown", recordHandler, true);
      productionLog3(`\u{1F3AE} [HOTKEYS] Remapped ${key}: ${UnifiedState3.data.hotkeys.gameKeys[key].original} \u2192 ${keyCombo}`);
    };
    targetDocument2.addEventListener("keydown", recordHandler, true);
  }
  function stopRecordingHotkey(buttonElement, originalText, dependencies = {}) {
    if (!currentlyRecordingHotkey) return;
    if (originalText) {
      buttonElement.textContent = originalText;
    }
    buttonElement.style.background = "";
    currentlyRecordingHotkey = null;
  }
  function startRecordingHotkeyMGTools(key, buttonElement, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      productionLog: productionLog3 = console.log,
      updateTabContent = typeof window !== "undefined" && window.updateTabContent,
      stopRecordingHotkey: stopRecordingFn = stopRecordingHotkey,
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null
    } = dependencies;
    if (currentlyRecordingHotkey) return;
    currentlyRecordingHotkey = key;
    const originalText = buttonElement.textContent;
    buttonElement.textContent = "Press any key...";
    buttonElement.style.background = "#ff9900";
    const recordHandler = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (["Control", "Alt", "Shift", "Meta"].includes(e.key)) return;
      if (e.key === "Escape") {
        stopRecordingFn(buttonElement, originalText, dependencies);
        targetDocument2.removeEventListener("keydown", recordHandler, true);
        return;
      }
      let keyCombo = "";
      if (e.ctrlKey) keyCombo += "ctrl+";
      if (e.altKey) keyCombo += "alt+";
      if (e.shiftKey) keyCombo += "shift+";
      const keyName = e.key === " " ? "space" : e.key.toLowerCase();
      keyCombo += keyName;
      const conflicts = [];
      Object.entries(UnifiedState3.data.hotkeys.gameKeys).forEach(([k, config2]) => {
        if (config2.custom && config2.custom === keyCombo) {
          conflicts.push(config2.name);
        }
      });
      Object.entries(UnifiedState3.data.hotkeys.mgToolsKeys).forEach(([k, config2]) => {
        if (k !== key && config2.custom && config2.custom === keyCombo) {
          conflicts.push(config2.name);
        }
      });
      if (conflicts.length > 0) {
        alert(`Key "${keyCombo}" is already assigned to: ${conflicts.join(", ")}`);
        stopRecordingFn(buttonElement, originalText, dependencies);
        targetDocument2.removeEventListener("keydown", recordHandler, true);
        return;
      }
      UnifiedState3.data.hotkeys.mgToolsKeys[key].custom = keyCombo;
      MGA_saveJSON2("MGA_hotkeys", UnifiedState3.data.hotkeys);
      stopRecordingFn(buttonElement, null, dependencies);
      if (updateTabContent) updateTabContent();
      targetDocument2.removeEventListener("keydown", recordHandler, true);
      productionLog3(`\u{1F3AE} [HOTKEYS] Set MGTools key ${key}: ${keyCombo}`);
    };
    targetDocument2.addEventListener("keydown", recordHandler, true);
  }
  function shouldBlockHotkey(event, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null
    } = dependencies;
    const active = targetDocument2.activeElement;
    if (!active) return false;
    const tagName = active.tagName?.toLowerCase();
    if (tagName === "input" || tagName === "textarea" || tagName === "select") {
      return true;
    }
    if (active.classList?.contains("chakra-input")) {
      if (UnifiedState3?.data?.settings?.debugMode) {
        console.log("[FIX_HOTKEYS] Blocking - Chakra UI input detected");
      }
      return true;
    }
    if (active.contentEditable === "true" || active.isContentEditable) {
      return true;
    }
    if (active.getAttribute("role") === "textbox") {
      return true;
    }
    if (event && event.composedPath) {
      const path = event.composedPath();
      for (const element of path) {
        if (!element.tagName) continue;
        const tag = element.tagName.toLowerCase();
        if (tag === "input" || tag === "textarea" || tag === "select") {
          return true;
        }
        if (element.contentEditable === "true" || element.getAttribute?.("role") === "textbox") {
          return true;
        }
      }
    }
    const discordSelectors = [
      ".chat-input-container",
      '[class*="textArea"]',
      '[class*="slateTextArea"]',
      ".markup-input"
    ];
    for (const selector of discordSelectors) {
      try {
        const chatElement = targetDocument2.querySelector(selector);
        if (chatElement && chatElement.contains(active)) {
          return true;
        }
      } catch {
      }
    }
    const activeClasses = active.className || "";
    const activeId = active.id || "";
    const chatPatterns = ["chat", "message", "input", "text", "field", "edit"];
    const hasChatPattern = chatPatterns.some(
      (pattern) => activeClasses.toLowerCase().includes(pattern) || activeId.toLowerCase().includes(pattern)
    );
    if (hasChatPattern && (tagName === "div" || tagName === "span" || active.isContentEditable)) {
      console.log("[FIX_HOTKEYS] Blocking hotkey - detected chat input:", {
        tag: tagName,
        classes: activeClasses,
        id: activeId,
        contentEditable: active.contentEditable
      });
      return true;
    }
    let parent = active.parentElement;
    let depth = 0;
    while (parent && depth < 5) {
      const parentClasses = parent.className || "";
      const parentId = parent.id || "";
      if (chatPatterns.some(
        (pattern) => parentClasses.toLowerCase().includes(pattern) || parentId.toLowerCase().includes(pattern)
      )) {
        console.log("[FIX_HOTKEYS] Blocking hotkey - active element in chat container:", {
          parentTag: parent.tagName,
          parentClasses,
          parentId,
          activeTag: tagName
        });
        return true;
      }
      parent = parent.parentElement;
      depth++;
    }
    return false;
  }
  function isTypingInInput(dependencies = {}) {
    return shouldBlockHotkey(null, dependencies);
  }
  function parseKeyCombo(combo) {
    const parts = combo.toLowerCase().split("+");
    return {
      ctrl: parts.includes("ctrl"),
      alt: parts.includes("alt"),
      shift: parts.includes("shift"),
      key: parts[parts.length - 1] === "space" ? " " : parts[parts.length - 1]
    };
  }
  function getProperKeyCode(key) {
    const codeMap = {
      " ": "Space",
      space: "Space",
      enter: "Enter",
      tab: "Tab",
      escape: "Escape",
      backspace: "Backspace",
      delete: "Delete",
      arrowup: "ArrowUp",
      arrowdown: "ArrowDown",
      arrowleft: "ArrowLeft",
      arrowright: "ArrowRight",
      home: "Home",
      end: "End",
      pageup: "PageUp",
      pagedown: "PageDown",
      "-": "Minus",
      "=": "Equal",
      "[": "BracketLeft",
      "]": "BracketRight",
      ";": "Semicolon",
      "'": "Quote",
      ",": "Comma",
      ".": "Period",
      "/": "Slash",
      "\\": "Backslash",
      "`": "Backquote"
    };
    const lowerKey = key.toLowerCase();
    if (codeMap[lowerKey]) return codeMap[lowerKey];
    if (/^f([1-9]|1[0-2])$/.test(lowerKey)) {
      return "F" + lowerKey.substring(1);
    }
    if (/^[0-9]$/.test(key)) {
      return "Digit" + key;
    }
    if (/^[a-z]$/i.test(key)) {
      return "Key" + key.toUpperCase();
    }
    return key.charAt(0).toUpperCase() + key.slice(1);
  }
  var heldRemappedKeys = /* @__PURE__ */ new Map();
  function matchesKeyCombo(event, combo, dependencies = {}) {
    const { parseKeyCombo: parseFn = parseKeyCombo } = dependencies;
    const parsed = parseFn(combo);
    const eventKey = event.key.toLowerCase();
    return event.ctrlKey === parsed.ctrl && event.altKey === parsed.alt && event.shiftKey === parsed.shift && (eventKey === parsed.key || parsed.key === " " && eventKey === " ");
  }
  function simulateKeyDown(keyCombo, dependencies = {}) {
    const {
      parseKeyCombo: parseFn = parseKeyCombo,
      getProperKeyCode: getCodeFn = getProperKeyCode,
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null
    } = dependencies;
    const parsed = parseFn(keyCombo);
    const downEvent = new KeyboardEvent("keydown", {
      key: parsed.key,
      code: getCodeFn(parsed.key),
      ctrlKey: parsed.ctrl,
      altKey: parsed.alt,
      shiftKey: parsed.shift,
      bubbles: true,
      cancelable: true,
      repeat: false
      // First press
    });
    targetDocument2.dispatchEvent(downEvent);
  }
  function simulateKeyUp(keyCombo, dependencies = {}) {
    const {
      parseKeyCombo: parseFn = parseKeyCombo,
      getProperKeyCode: getCodeFn = getProperKeyCode,
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null
    } = dependencies;
    const parsed = parseFn(keyCombo);
    const upEvent = new KeyboardEvent("keyup", {
      key: parsed.key,
      code: getCodeFn(parsed.key),
      ctrlKey: parsed.ctrl,
      altKey: parsed.alt,
      shiftKey: parsed.shift,
      bubbles: true,
      cancelable: true
    });
    targetDocument2.dispatchEvent(upEvent);
  }
  function handleHotkeyPress(e, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      shouldBlockHotkey: shouldBlockFn = shouldBlockHotkey,
      matchesKeyCombo: matchesFn = matchesKeyCombo,
      simulateKeyDown: simDownFn = simulateKeyDown,
      simulateKeyUp: simUpFn = simulateKeyUp,
      toggleShopWindows: toggleShopWindows2 = typeof window !== "undefined" && window.toggleShopWindows,
      productionLog: productionLog3 = console.log,
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null
    } = dependencies;
    if (e.key === "Escape" && e.type === "keydown") {
      const sidebar = targetDocument2.getElementById("mgh-sidebar");
      if (sidebar && sidebar.classList.contains("open")) {
        sidebar.classList.remove("open");
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }
    const isRoomSearch = e.target && e.target.id === "room-search-input";
    const isAddRoomInput = e.target && e.target.id === "add-room-input";
    const isRoomSearchFocused = targetDocument2.activeElement && targetDocument2.activeElement.id === "room-search-input";
    const isAddRoomFocused = targetDocument2.activeElement && targetDocument2.activeElement.id === "add-room-input";
    if (!e.isTrusted) return;
    if (shouldBlockFn(e, dependencies)) {
      if (e.key !== "Enter") {
        e.stopImmediatePropagation();
      }
      if (UnifiedState3.data.settings?.debugMode) {
        const active = targetDocument2.activeElement;
        console.log("[FIX_HOTKEYS] Hotkey blocked - typing detected:", {
          key: e.key,
          tag: active?.tagName,
          id: active?.id,
          classes: active?.className,
          contentEditable: active?.contentEditable
        });
      }
      return;
    }
    if (!UnifiedState3.data.hotkeys.enabled || currentlyRecordingHotkey || isRoomSearch || isRoomSearchFocused || isAddRoomInput || isAddRoomFocused)
      return;
    const isKeyDown = e.type === "keydown";
    const isKeyUp = e.type === "keyup";
    for (const [action, config2] of Object.entries(UnifiedState3.data.hotkeys.gameKeys)) {
      if (config2.custom) {
        if (matchesFn(e, config2.custom, dependencies)) {
          e.preventDefault();
          e.stopPropagation();
          if (action === "toggleQuickShop") {
            if (isKeyDown && !e.repeat) {
              if (toggleShopWindows2) toggleShopWindows2();
              if (UnifiedState3.data.settings.debugMode) {
                productionLog3(`\u{1F3AE} [HOTKEYS] Triggered Quick Shop toggle via ${config2.custom}`);
              }
            }
            return false;
          }
          if (isKeyDown) {
            if (!e.repeat) {
              simDownFn(config2.original, dependencies);
              heldRemappedKeys.set(config2.custom, config2.original);
              if (UnifiedState3.data.settings.debugMode) {
                productionLog3(`\u{1F3AE} [HOTKEYS] Remapped keydown ${config2.custom} \u2192 ${config2.original} (${config2.name})`);
              }
            }
          } else if (isKeyUp) {
            simUpFn(config2.original, dependencies);
            heldRemappedKeys.delete(config2.custom);
            if (UnifiedState3.data.settings.debugMode) {
              productionLog3(`\u{1F3AE} [HOTKEYS] Remapped keyup ${config2.custom} \u2192 ${config2.original} (${config2.name})`);
            }
          }
          return false;
        }
      }
    }
    for (const [action, config2] of Object.entries(UnifiedState3.data.hotkeys.gameKeys)) {
      if (!config2.custom && action === "toggleQuickShop") {
        if (matchesFn(e, config2.original, dependencies)) {
          if (isKeyDown && !e.repeat) {
            e.preventDefault();
            e.stopPropagation();
            if (toggleShopWindows2) toggleShopWindows2();
            if (UnifiedState3.data.settings.debugMode) {
              productionLog3(`\u{1F3AE} [HOTKEYS] Triggered Quick Shop toggle via ${config2.original}`);
            }
            return false;
          }
        }
      }
    }
    for (const [action, config2] of Object.entries(UnifiedState3.data.hotkeys.gameKeys)) {
      if (config2.custom && matchesFn(e, config2.original, dependencies)) {
        e.preventDefault();
        e.stopPropagation();
        if (UnifiedState3.data.settings.debugMode && !e.repeat) {
          productionLog3(`\u{1F6AB} [HOTKEYS] Suppressed ${config2.original} (remapped to ${config2.custom} for ${config2.name})`);
        }
        return false;
      }
    }
  }
  function handleHotkeyRelease(e, dependencies = {}) {
    const { handleHotkeyPress: handleFn = handleHotkeyPress } = dependencies;
    handleFn(e, dependencies);
  }
  function initializeHotkeySystem(dependencies = {}) {
    const {
      handleHotkeyPress: handlePressFn = handleHotkeyPress,
      handleHotkeyRelease: handleReleaseFn = handleHotkeyRelease,
      productionLog: productionLog3 = console.log,
      targetDocument: targetDocument2 = typeof window !== "undefined" ? window.document : null
    } = dependencies;
    targetDocument2.addEventListener("keydown", (e) => handlePressFn(e, dependencies), true);
    targetDocument2.addEventListener("keyup", (e) => handleReleaseFn(e, dependencies), true);
    productionLog3("\u{1F3AE} [HOTKEYS] Key interception system installed (keydown + keyup)");
  }
  function setupHotkeysTabHandlers(context = document, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      productionLog: productionLog3 = console.log,
      startRecordingHotkey: startRecordingFn = startRecordingHotkey,
      startRecordingHotkeyMGTools: startRecordingMGToolsFn = startRecordingHotkeyMGTools,
      updateTabContent = typeof window !== "undefined" && window.updateTabContent
    } = dependencies;
    const enableCheckbox = context.querySelector("#hotkeys-enabled");
    if (enableCheckbox) {
      enableCheckbox.addEventListener("change", (e) => {
        UnifiedState3.data.hotkeys.enabled = e.target.checked;
        MGA_saveJSON2("MGA_hotkeys", UnifiedState3.data.hotkeys);
        productionLog3(`\u{1F3AE} [HOTKEYS] ${e.target.checked ? "Enabled" : "Disabled"}`);
      });
    }
    context.querySelectorAll(".hotkey-button").forEach((button) => {
      button.addEventListener("click", function() {
        const key = this.dataset.key;
        startRecordingFn(key, this, dependencies);
      });
    });
    context.querySelectorAll(".hotkey-reset").forEach((button) => {
      button.addEventListener("click", function() {
        const key = this.dataset.key;
        UnifiedState3.data.hotkeys.gameKeys[key].custom = null;
        MGA_saveJSON2("MGA_hotkeys", UnifiedState3.data.hotkeys);
        if (updateTabContent) updateTabContent();
        productionLog3(`\u{1F3AE} [HOTKEYS] Reset ${key} to default`);
      });
    });
    context.querySelectorAll(".hotkey-button-mgtools").forEach((button) => {
      button.addEventListener("click", function() {
        const key = this.dataset.key;
        startRecordingMGToolsFn(key, this, dependencies);
      });
    });
    context.querySelectorAll(".hotkey-reset-mgtools").forEach((button) => {
      button.addEventListener("click", function() {
        const key = this.dataset.key;
        UnifiedState3.data.hotkeys.mgToolsKeys[key].custom = null;
        MGA_saveJSON2("MGA_hotkeys", UnifiedState3.data.hotkeys);
        if (updateTabContent) updateTabContent();
        productionLog3(`\u{1F3AE} [HOTKEYS] Reset MGTools key ${key} to default`);
      });
    });
    const resetAllBtn = context.querySelector("#hotkeys-reset-all");
    if (resetAllBtn) {
      resetAllBtn.addEventListener("click", () => {
        if (confirm("Reset all hotkeys to defaults?")) {
          Object.keys(UnifiedState3.data.hotkeys.gameKeys).forEach((key) => {
            UnifiedState3.data.hotkeys.gameKeys[key].custom = null;
          });
          Object.keys(UnifiedState3.data.hotkeys.mgToolsKeys).forEach((key) => {
            UnifiedState3.data.hotkeys.mgToolsKeys[key].custom = null;
          });
          MGA_saveJSON2("MGA_hotkeys", UnifiedState3.data.hotkeys);
          if (updateTabContent) updateTabContent();
          productionLog3("\u{1F3AE} [HOTKEYS] Reset all hotkeys to defaults");
        }
      });
    }
    const exportBtn = context.querySelector("#hotkeys-export");
    if (exportBtn) {
      exportBtn.addEventListener("click", () => {
        const exportData = {};
        Object.entries(UnifiedState3.data.hotkeys.gameKeys).forEach(([key, config2]) => {
          if (config2.custom) {
            exportData[key] = config2.custom;
          }
        });
        const json = JSON.stringify(exportData, null, 2);
        navigator.clipboard.writeText(json);
        alert("Hotkey configuration copied to clipboard!");
      });
    }
  }
  var hotkeys_default = {
    // Recording Functions (Phase 1)
    startRecordingHotkey,
    stopRecordingHotkey,
    startRecordingHotkeyMGTools,
    // Input Detection (Phase 1)
    shouldBlockHotkey,
    isTypingInInput,
    // Key Parsing Utilities (Phase 1)
    parseKeyCombo,
    getProperKeyCode,
    // Key Simulation & Matching (Phase 2)
    matchesKeyCombo,
    simulateKeyDown,
    simulateKeyUp,
    // Event Handlers (Phase 3)
    handleHotkeyPress,
    handleHotkeyRelease,
    initializeHotkeySystem,
    // Tab UI (Phase 4)
    setupHotkeysTabHandlers
  };

  // src/features/protection.js
  var protection_exports = {};
  __export(protection_exports, {
    applyHarvestRule: () => applyHarvestRule,
    applySellBlockThreshold: () => applySellBlockThreshold,
    default: () => protection_default,
    initializeProtectionHooks: () => initializeProtectionHooks,
    setupProtectTabHandlers: () => setupProtectTabHandlers,
    updateProtectStatus: () => updateProtectStatus
  });
  function setupProtectTabHandlers(context = document, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      productionLog: productionLog3 = console.log,
      updateProtectStatus: updateProtectStatusFn = updateProtectStatus,
      applyHarvestRule: applyHarvestRuleFn = applyHarvestRule,
      applySellBlockThreshold: applySellBlockThresholdFn = applySellBlockThreshold,
      DECOR_ITEMS = typeof window !== "undefined" && window.DECOR_ITEMS
    } = dependencies;
    const cropSpecies = [
      "Mushroom",
      "Cactus",
      "Bamboo",
      "Grape",
      "Pepper",
      "Lemon",
      "PassionFruit",
      "DragonFruit",
      "Lychee",
      "Sunflower",
      "Starweaver",
      "DawnCelestial",
      "MoonCelestial"
    ];
    const cropMutations = [
      "Rainbow",
      "Frozen",
      "Wet",
      "Chilled",
      "Gold",
      "Dawnlit",
      "Amberlit",
      "Dawnbound",
      "Amberbound",
      "Lock All Mutations",
      "Lock Only Non-Mutated"
    ];
    if (!UnifiedState3.data.protectionSettings) {
      UnifiedState3.data.protectionSettings = {
        allowFrozenPickup: false
        // Allow pickup of protected crops when frozen
      };
    }
    if (!UnifiedState3.data.lockedCrops) {
      UnifiedState3.data.lockedCrops = { species: [], mutations: [] };
    }
    if (!UnifiedState3.data.sellBlockThreshold) {
      UnifiedState3.data.sellBlockThreshold = 1;
    }
    if (!UnifiedState3.data.lockedDecor) {
      UnifiedState3.data.lockedDecor = [];
    }
    if (!UnifiedState3.data.lockedPetAbilities) {
      UnifiedState3.data.lockedPetAbilities = [];
    }
    const lockedCrops = UnifiedState3.data.lockedCrops;
    const speciesList = context.querySelector("#protect-species-list");
    if (speciesList) {
      speciesList.innerHTML = cropSpecies.map(
        (species) => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-species-checkbox" value="${species}"
                          ${lockedCrops.species?.includes(species) ? "checked" : ""}
                          style="cursor: pointer;">
                      <span style="font-size: 12px;">${species}</span>
                  </label>
              `
      ).join("");
    }
    const mutationsList = context.querySelector("#protect-mutations-list");
    if (mutationsList) {
      mutationsList.innerHTML = cropMutations.map(
        (mutation) => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-mutation-checkbox" value="${mutation}"
                          ${lockedCrops.mutations?.includes(mutation) ? "checked" : ""}
                          style="cursor: pointer;">
                      <span style="font-size: 12px;">${mutation}</span>
                  </label>
              `
      ).join("");
    }
    const petAbilities = ["Rainbow Granter", "Gold Granter"];
    const petAbilitiesList = context.querySelector("#protect-pet-abilities-list");
    if (petAbilitiesList) {
      petAbilitiesList.innerHTML = petAbilities.map(
        (ability) => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-pet-ability-checkbox" value="${ability}"
                          ${UnifiedState3.data.lockedPetAbilities?.includes(ability) ? "checked" : ""}
                          style="cursor: pointer;">
                      <span style="font-size: 12px;">${ability}</span>
                  </label>
              `
      ).join("");
    }
    const decorList = context.querySelector("#protect-decor-list");
    if (decorList && DECOR_ITEMS) {
      decorList.innerHTML = DECOR_ITEMS.map(
        (decor) => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-decor-checkbox" value="${decor.id}"
                          ${UnifiedState3.data.lockedDecor?.includes(decor.id) ? "checked" : ""}
                          style="cursor: pointer;">
                      <span style="font-size: 11px;">${decor.name}</span>
                  </label>
              `
      ).join("");
    }
    const speciesCheckboxes = context.querySelectorAll(".protect-species-checkbox");
    const mutationCheckboxes = context.querySelectorAll(".protect-mutation-checkbox");
    console.log(
      `\u2705 [Protect] Found ${speciesCheckboxes.length} species checkboxes, ${mutationCheckboxes.length} mutation checkboxes`
    );
    context.querySelectorAll(".protect-species-checkbox").forEach((checkbox) => {
      checkbox.addEventListener("change", (e) => {
        console.log("[Protect] \u{1F514} Species checkbox changed!", e.target.value, "checked:", e.target.checked);
        const species = e.target.value;
        if (e.target.checked) {
          if (!lockedCrops.species.includes(species)) {
            lockedCrops.species.push(species);
          }
        } else {
          lockedCrops.species = lockedCrops.species.filter((s) => s !== species);
        }
        console.log("[Protect] Saving species change:", species, e.target.checked);
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        console.log("[Protect] Save completed");
        updateProtectStatusFn(context, dependencies);
        applyHarvestRuleFn(dependencies);
      });
    });
    context.querySelectorAll(".protect-mutation-checkbox").forEach((checkbox) => {
      checkbox.addEventListener("change", (e) => {
        console.log("[Protect] \u{1F514} Mutation checkbox changed!", e.target.value, "checked:", e.target.checked);
        const mutation = e.target.value;
        if (mutation === "Lock All Mutations") {
          const allMutationCheckboxes = context.querySelectorAll(".protect-mutation-checkbox");
          if (e.target.checked) {
            allMutationCheckboxes.forEach((cb) => {
              if (cb.value !== "Lock All Mutations" && cb.value !== "Lock Only Non-Mutated") {
                cb.checked = true;
                if (!lockedCrops.mutations.includes(cb.value)) {
                  lockedCrops.mutations.push(cb.value);
                }
              }
            });
          } else {
            allMutationCheckboxes.forEach((cb) => {
              if (cb.value !== "Lock All Mutations" && cb.value !== "Lock Only Non-Mutated") {
                cb.checked = false;
              }
            });
            lockedCrops.mutations = lockedCrops.mutations.filter((m) => m === "Lock Only Non-Mutated");
          }
        } else if (mutation === "Lock Only Non-Mutated") {
          if (e.target.checked) {
            if (!lockedCrops.mutations.includes(mutation)) {
              lockedCrops.mutations.push(mutation);
            }
          } else {
            lockedCrops.mutations = lockedCrops.mutations.filter((m) => m !== mutation);
          }
        } else {
          if (e.target.checked) {
            if (!lockedCrops.mutations.includes(mutation)) {
              lockedCrops.mutations.push(mutation);
            }
          } else {
            lockedCrops.mutations = lockedCrops.mutations.filter((m) => m !== mutation);
            const lockAllCheckbox = context.querySelector('.protect-mutation-checkbox[value="Lock All Mutations"]');
            if (lockAllCheckbox) {
              lockAllCheckbox.checked = false;
            }
          }
        }
        console.log("[Protect] Saving mutation change:", mutation, e.target.checked);
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        console.log("[Protect] Save completed");
        updateProtectStatusFn(context, dependencies);
        applyHarvestRuleFn(dependencies);
      });
    });
    context.querySelectorAll(".protect-pet-ability-checkbox").forEach((checkbox) => {
      checkbox.addEventListener("change", (e) => {
        const ability = e.target.value;
        if (e.target.checked) {
          if (!UnifiedState3.data.lockedPetAbilities.includes(ability)) {
            UnifiedState3.data.lockedPetAbilities.push(ability);
          }
        } else {
          UnifiedState3.data.lockedPetAbilities = UnifiedState3.data.lockedPetAbilities.filter((a) => a !== ability);
        }
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        updateProtectStatusFn(context, dependencies);
      });
    });
    context.querySelectorAll(".protect-decor-checkbox").forEach((checkbox) => {
      checkbox.addEventListener("change", (e) => {
        const decorId = e.target.value;
        if (e.target.checked) {
          if (!UnifiedState3.data.lockedDecor.includes(decorId)) {
            UnifiedState3.data.lockedDecor.push(decorId);
          }
        } else {
          UnifiedState3.data.lockedDecor = UnifiedState3.data.lockedDecor.filter((d) => d !== decorId);
        }
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        updateProtectStatusFn(context, dependencies);
      });
    });
    const clearButton = context.querySelector("#protect-clear-all");
    if (clearButton) {
      clearButton.addEventListener("click", () => {
        lockedCrops.species = [];
        lockedCrops.mutations = [];
        UnifiedState3.data.lockedDecor = [];
        UnifiedState3.data.lockedPetAbilities = [];
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        context.querySelectorAll(
          ".protect-species-checkbox, .protect-mutation-checkbox, .protect-decor-checkbox, .protect-pet-ability-checkbox"
        ).forEach((cb) => {
          cb.checked = false;
        });
        updateProtectStatusFn(context, dependencies);
        applyHarvestRuleFn(dependencies);
      });
    }
    const thresholdSlider = context.querySelector("#protect-sell-threshold");
    const thresholdValue = context.querySelector("#protect-sell-threshold-value");
    if (thresholdSlider) {
      thresholdSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        UnifiedState3.data.sellBlockThreshold = value;
        if (thresholdValue) {
          thresholdValue.textContent = `${value.toFixed(2)}x (${((value - 1) * 100).toFixed(0)}%)`;
        }
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        applySellBlockThresholdFn(dependencies);
      });
    }
    console.log("[Protect-Debug] \u{1F50D} Looking for #allow-frozen-pickup checkbox in context:", context);
    const frozenCheckbox = context.querySelector("#allow-frozen-pickup");
    console.log("[Protect-Debug] \u{1F4CB} Frozen checkbox found?", !!frozenCheckbox, frozenCheckbox);
    if (frozenCheckbox) {
      console.log("[Protect-Debug] \u2705 Attaching change event handler to frozen checkbox");
      frozenCheckbox.addEventListener("change", (e) => {
        console.log("[Protect-Debug] \u{1F514} FROZEN CHECKBOX CHANGED!", e.target.checked);
        if (!UnifiedState3.data.protectionSettings) {
          UnifiedState3.data.protectionSettings = {};
        }
        UnifiedState3.data.protectionSettings.allowFrozenPickup = e.target.checked;
        MGA_saveJSON2("MGA_data", UnifiedState3.data);
        productionLog3(`\u2744\uFE0F [PROTECTION] Frozen exception: ${e.target.checked ? "enabled" : "disabled"}`);
        applyHarvestRuleFn(dependencies);
      });
      console.log("[Protect-Debug] \u2705 Frozen checkbox handler attached successfully");
    } else {
      console.warn("[Protect-Debug] \u26A0\uFE0F Frozen checkbox NOT FOUND in context!");
    }
    updateProtectStatusFn(context, dependencies);
    applyHarvestRuleFn(dependencies);
    applySellBlockThresholdFn(dependencies);
  }
  function updateProtectStatus(context = document, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      DECOR_ITEMS = typeof window !== "undefined" && window.DECOR_ITEMS
    } = dependencies;
    const statusDisplay = context.querySelector("#protect-status-display");
    if (!statusDisplay) return;
    const lockedCrops = UnifiedState3.data.lockedCrops || { species: [], mutations: [] };
    const lockedDecor = UnifiedState3.data.lockedDecor || [];
    const lockedPetAbilities = UnifiedState3.data.lockedPetAbilities || [];
    const hasLocks = lockedCrops.species.length > 0 || lockedCrops.mutations.length > 0 || lockedDecor.length > 0 || lockedPetAbilities.length > 0;
    if (!hasLocks) {
      statusDisplay.innerHTML = '<div style="color: #888;">No protections are currently active.</div>';
      return;
    }
    let html = "";
    if (lockedCrops.species.length > 0) {
      html += `<div style="margin-bottom: 8px;"><strong>\u{1F512} Locked Crop Species:</strong> ${lockedCrops.species.join(", ")}</div>`;
    }
    if (lockedCrops.mutations.length > 0) {
      html += `<div style="margin-bottom: 8px;"><strong>\u{1F512} Locked Mutations:</strong> ${lockedCrops.mutations.join(", ")}</div>`;
    }
    if (lockedPetAbilities.length > 0) {
      html += `<div style="margin-bottom: 8px;"><strong>\u{1F43E} Locked Pet Abilities:</strong> ${lockedPetAbilities.join(", ")}</div>`;
    }
    if (lockedDecor.length > 0 && DECOR_ITEMS) {
      const decorNames = lockedDecor.map((id) => {
        const decor = DECOR_ITEMS.find((d) => d.id === id);
        return decor ? decor.name : id;
      }).join(", ");
      html += `<div><strong>\u{1F3DB}\uFE0F Locked Decor:</strong> ${decorNames}</div>`;
    }
    statusDisplay.innerHTML = html;
  }
  function applyHarvestRule(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null
    } = dependencies;
    targetWindow3.currentHarvestRule = ({ species, mutations } = {}) => {
      const freshLockedCrops = UnifiedState3.data.lockedCrops || { species: [], mutations: [] };
      let mutationsLocal = mutations;
      mutationsLocal = Array.isArray(mutationsLocal) ? mutationsLocal : [];
      const isFrozen = mutationsLocal.includes("Frozen");
      const allowFrozenPickup = UnifiedState3.data.protectionSettings?.allowFrozenPickup || false;
      if (freshLockedCrops.species && freshLockedCrops.species.includes(species)) {
        if (isFrozen && allowFrozenPickup) {
          return true;
        }
        return false;
      }
      if (freshLockedCrops.mutations && freshLockedCrops.mutations.includes("Lock Only Non-Mutated")) {
        if (mutationsLocal.length === 0) {
          return false;
        }
      }
      if (freshLockedCrops.mutations && freshLockedCrops.mutations.length > 0) {
        const regularMutations = freshLockedCrops.mutations.filter(
          (m) => m !== "Lock All Mutations" && m !== "Lock Only Non-Mutated"
        );
        const hasLockedMutation = regularMutations.some((m) => mutationsLocal.includes(m));
        if (hasLockedMutation) {
          if (isFrozen && allowFrozenPickup) {
            return true;
          }
          return false;
        }
      }
      return true;
    };
  }
  function applySellBlockThreshold(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null
    } = dependencies;
    targetWindow3.sellBlockThreshold = UnifiedState3.data.sellBlockThreshold || 1;
    console.log(`\u2705 Sell block threshold set to ${targetWindow3.sellBlockThreshold}x`);
  }
  function initializeProtectionHooks(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      trackLocalPurchase: trackLocalPurchase2 = typeof window !== "undefined" && window.trackLocalPurchase,
      insertTurtleEstimate: insertTurtleEstimate3 = typeof window !== "undefined" && window.insertTurtleEstimate,
      applyHarvestRule: applyHarvestRuleFn = applyHarvestRule,
      applySellBlockThreshold: applySellBlockThresholdFn = applySellBlockThreshold
    } = dependencies;
    let roomConnectionRetries = 0;
    const MAX_ROOM_CONNECTION_RETRIES = 10;
    setTimeout(() => {
      if (!targetWindow3.MagicCircle_RoomConnection) {
        if (roomConnectionRetries < MAX_ROOM_CONNECTION_RETRIES) {
          roomConnectionRetries++;
          console.warn(`\u23F3 Waiting for RoomConnection (${roomConnectionRetries}/${MAX_ROOM_CONNECTION_RETRIES})...`);
          setTimeout(() => initializeProtectionHooks(dependencies), 1e3);
          return;
        }
        console.warn("\u26A0\uFE0F RoomConnection not found after max retries - continuing without protection hooks");
        return;
      }
      roomConnectionRetries = 0;
      console.log("\u2705 MagicCircle_RoomConnection found - initializing protection hooks");
      const originalSendMessage = targetWindow3.MagicCircle_RoomConnection.sendMessage.bind(
        targetWindow3.MagicCircle_RoomConnection
      );
      targetWindow3.MagicCircle_RoomConnection.sendMessage = function(message, ...rest) {
        try {
          if (!message || typeof message.type !== "string") {
            return originalSendMessage(message, ...rest);
          }
          const friendBonus = targetWindow3.friendBonus ?? 1.5;
          const msgType = message.type;
          const isSellMessage = msgType === "SellAllCrops";
          if (msgType === "PurchaseSeed" && message.species) {
            if (typeof trackLocalPurchase2 === "function") {
              trackLocalPurchase2(message.species, "seed", 1);
            }
          } else if (msgType === "PurchaseEgg" && message.eggId) {
            if (typeof trackLocalPurchase2 === "function") {
              trackLocalPurchase2(message.eggId, "egg", 1);
            }
          } else if (msgType === "PurchaseTool" && message.toolId) {
            if (UnifiedState3.data.settings?.debugMode) {
              console.log(`\u{1F527} [PURCHASE-INTERCEPT] Tool Purchase Detected!`, {
                toolId: message.toolId,
                toolIdType: typeof message.toolId,
                fullMessage: JSON.stringify(message)
              });
            }
            if (typeof trackLocalPurchase2 === "function") {
              trackLocalPurchase2(message.toolId, "tool", 1);
              if (UnifiedState3.data.settings?.debugMode) {
                console.log(`\u{1F527} [PURCHASE-INTERCEPT] Called trackLocalPurchase with: "${message.toolId}"`);
              }
            } else {
              console.error(`\u274C [PURCHASE-INTERCEPT] trackLocalPurchase function not available!`);
            }
          }
          if (isSellMessage && friendBonus < targetWindow3.sellBlockThreshold) {
            console.warn(
              `[SellBlock] Blocked ${msgType} (friendBonus=${friendBonus} < ${targetWindow3.sellBlockThreshold})`
            );
            return;
          }
          if (msgType === "HarvestCrop") {
            const tile = targetWindow3.myGarden?.garden?.tileObjects?.[message.slot];
            const slotData = tile?.slots?.[message.slotsIndex];
            console.log(`[HarvestCheck] Attempting harvest: slot=${message.slot}, index=${message.slotsIndex}`);
            console.log(`[HarvestCheck] Tile data:`, tile);
            console.log(`[HarvestCheck] Slot data:`, slotData);
            if (slotData) {
              const species = slotData.species;
              const slotMutations = slotData.mutations || [];
              console.log(`[HarvestCheck] Species: ${species}, Mutations:`, slotMutations);
              console.log(`[HarvestCheck] currentHarvestRule exists:`, !!targetWindow3.currentHarvestRule);
              if (targetWindow3.currentHarvestRule && !targetWindow3.currentHarvestRule({ species, mutations: slotMutations })) {
                console.log(`\u{1F512} BLOCKED HarvestCrop: ${species} with mutations [${slotMutations.join(", ")}]`);
                return;
              }
              console.log(`\u2705 ALLOWED HarvestCrop: ${species} with mutations [${slotMutations.join(", ")}]`);
              if (UnifiedState3.data.settings?.debugMode) {
                console.log("[FIX_HARVEST] Harvest handler called for:", species, "Will attempt sync in 100ms...");
              }
              const preHarvestIndex = window._mgtools_currentSlotIndex || 0;
              const qmt = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
              qmt(() => {
                setTimeout(() => {
                  try {
                    if (!window.syncSlotIndexFromGame) {
                      if (UnifiedState3.data.settings?.debugMode) {
                        console.error("[FIX_HARVEST] ERROR: syncSlotIndexFromGame not found on window!");
                      }
                      return;
                    }
                    const newIndex = window.syncSlotIndexFromGame();
                    if (UnifiedState3.data.settings?.debugMode) {
                      console.log("[FIX_HARVEST] Post-harvest slot sync:", {
                        species,
                        preHarvest: preHarvestIndex,
                        postHarvest: newIndex !== null ? newIndex : preHarvestIndex,
                        slotAdvanced: newIndex !== null,
                        isMultiHarvest: newIndex !== null,
                        note: newIndex === null ? "Single-harvest crop (expected - no slot advance)" : "Multi-harvest detected - slot advanced"
                      });
                    }
                    if (typeof insertTurtleEstimate3 === "function") {
                      requestAnimationFrame(() => {
                        insertTurtleEstimate3();
                        if (UnifiedState3.data.settings?.debugMode) {
                          console.log("[FIX_HARVEST] Refreshed value display");
                        }
                      });
                    }
                  } catch (error) {
                    console.error("[FIX_HARVEST] Sync error:", error);
                  }
                }, 100);
              });
            } else {
              console.warn(`[HarvestCheck] No slot data found for slot ${message.slot}, index ${message.slotsIndex}`);
            }
          }
          if (msgType.toLowerCase().includes("pet") && msgType.toLowerCase().includes("sell")) {
            const lockedAbilities = UnifiedState3.data.lockedPetAbilities || [];
            const petId = message.itemId || message.petId;
            if (UnifiedState3.data.settings?.debugMode) {
              console.log(`\u{1F43E} [PetSellDebug] Message type: ${msgType}`, message);
              console.log(`\u{1F43E} [PetSellDebug] Locked abilities:`, lockedAbilities);
            }
            if (lockedAbilities.length > 0 && petId) {
              let pet = null;
              if (UnifiedState3.atoms.activePets) {
                pet = UnifiedState3.atoms.activePets.find((p) => p.id === petId);
              }
              if (!pet && UnifiedState3.atoms.inventory?.items) {
                pet = UnifiedState3.atoms.inventory.items.find((item) => item.id === petId && item.itemType === "Pet");
              }
              if (UnifiedState3.data.settings?.debugMode) {
                console.log(`\u{1F43E} [PetSellDebug] Found pet:`, pet);
              }
              if (pet) {
                const petMutations = pet.mutations || [];
                if (UnifiedState3.data.settings?.debugMode) {
                  console.log(`\u{1F43E} [PetSellDebug] Pet mutations:`, petMutations);
                  let abilityFromAtom = null;
                  if (UnifiedState3.atoms.petAbility && UnifiedState3.atoms.petAbility[petId]) {
                    const abilityData = UnifiedState3.atoms.petAbility[petId];
                    abilityFromAtom = abilityData.lastAbilityTrigger?.abilityId;
                    console.log(`\u{1F43E} [PetSellDebug] Pet ability from atom:`, abilityFromAtom);
                  }
                }
                const hasGoldMutation = petMutations.includes("Gold");
                const hasRainbowMutation = petMutations.includes("Rainbow");
                if (UnifiedState3.data.settings?.debugMode) {
                  console.log(
                    `\u{1F43E} [PetSellDebug] Has Gold mutation: ${hasGoldMutation}, Has Rainbow mutation: ${hasRainbowMutation}`
                  );
                }
                const isGoldGranterLocked = lockedAbilities.includes("Gold Granter");
                const isRainbowGranterLocked = lockedAbilities.includes("Rainbow Granter");
                const shouldBlockGold = hasGoldMutation && isGoldGranterLocked;
                const shouldBlockRainbow = hasRainbowMutation && isRainbowGranterLocked;
                if (UnifiedState3.data.settings?.debugMode) {
                  console.log(
                    `\u{1F43E} [PetSellDebug] Should block gold: ${shouldBlockGold}, Should block rainbow: ${shouldBlockRainbow}`
                  );
                }
                if (shouldBlockGold || shouldBlockRainbow) {
                  const blockedType = shouldBlockGold ? "Gold" : "Rainbow";
                  console.warn(`\u{1F43E} [PetLock] \u274C BLOCKED selling ${blockedType} pet (${blockedType} Granter is locked)`);
                  return;
                }
                if (UnifiedState3.data.settings?.debugMode) {
                  console.log(`\u{1F43E} [PetSellDebug] \u2705 Pet mutations not locked, allowing sale`);
                }
              } else if (UnifiedState3.data.settings?.debugMode) {
                console.log(`\u{1F43E} [PetSellDebug] \u26A0\uFE0F Could not find pet with ID ${petId}`);
              }
            }
          }
          if (msgType === "PickupDecor") {
            console.log(`\u{1F3DB}\uFE0F [DecorCheck] PickupDecor message:`, JSON.stringify(message, null, 2));
            const lockedDecor = UnifiedState3.data.lockedDecor || [];
            if (lockedDecor.length > 0) {
              const tileType = message.tileType;
              const tileIndex = message.localTileIndex;
              console.log(`\u{1F3DB}\uFE0F [DecorCheck] Looking for decor at ${tileType} tile ${tileIndex}`);
              let decorAtPosition = null;
              if (targetWindow3.myGarden?.garden) {
                const garden = targetWindow3.myGarden.garden;
                if (tileType === "Boardwalk" && garden.boardwalkTileObjects) {
                  const tile = garden.boardwalkTileObjects[tileIndex];
                  if (tile && tile.objectType === "decor" && tile.decorId) {
                    decorAtPosition = tile.decorId;
                  }
                } else if (tileType === "Garden" && garden.tileObjects) {
                  const tile = garden.tileObjects[tileIndex];
                  if (tile && tile.objectType === "decor" && tile.decorId) {
                    decorAtPosition = tile.decorId;
                  }
                }
              }
              console.log(`\u{1F3DB}\uFE0F [DecorCheck] Decor at position: "${decorAtPosition}"`);
              console.log(`\u{1F3DB}\uFE0F [DecorCheck] Locked decor list:`, lockedDecor);
              if (decorAtPosition && lockedDecor.includes(decorAtPosition)) {
                console.warn(`\u{1F3DB}\uFE0F [DecorLock] \u274C BLOCKED pickup of "${decorAtPosition}"`);
                return;
              }
              if (decorAtPosition) {
                console.log(`\u{1F3DB}\uFE0F [DecorCheck] \u2705 Decor "${decorAtPosition}" not locked, allowing pickup`);
              } else {
                console.log(`\u{1F3DB}\uFE0F [DecorCheck] \u26A0\uFE0F Could not find decor at tile position`);
              }
            }
          }
          if (Array.isArray(message?.scopePath)) {
            targetWindow3.__mga_lastScopePath = message.scopePath.slice();
          }
          if (message?.type === "FeedPet") {
            console.log("[FEED-DEBUG] \u{1F50D} FeedPet message being sent:", {
              type: message.type,
              petItemId: message.petItemId,
              cropItemId: message.cropItemId,
              scopePath: message.scopePath,
              fullMsg: JSON.stringify(message)
            });
            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
            if (!uuidRegex.test(message.petItemId)) {
              console.error("[FEED-DEBUG] \u274C Invalid petItemId format:", message.petItemId);
            }
            if (!uuidRegex.test(message.cropItemId)) {
              console.error("[FEED-DEBUG] \u274C Invalid cropItemId format:", message.cropItemId);
            }
          }
          return originalSendMessage(message, ...rest);
        } catch (err) {
          console.error("[SendMessageHook] Error:", err);
          return originalSendMessage(message, ...rest);
        }
      };
      console.log("\u2705 Harvest and sell protection hooks installed");
    }, 2e3);
    applyHarvestRuleFn(dependencies);
    applySellBlockThresholdFn(dependencies);
  }
  var protection_default = {
    // Tab UI (Phase 5)
    setupProtectTabHandlers,
    // Status Display (Phase 6)
    updateProtectStatus,
    // Protection Hooks (Phase 7)
    applyHarvestRule,
    applySellBlockThreshold,
    initializeProtectionHooks
  };

  // src/features/crop-highlighting.js
  var crop_highlighting_exports = {};
  __export(crop_highlighting_exports, {
    applyCropHighlighting: () => applyCropHighlighting,
    clearCropHighlighting: () => clearCropHighlighting,
    debugCropHighlighting: () => debugCropHighlighting,
    default: () => crop_highlighting_default,
    initializeCropHighlightingAtoms: () => initializeCropHighlightingAtoms,
    setupAutomaticCropHighlighting: () => setupAutomaticCropHighlighting,
    setupCropHighlightingHandlers: () => setupCropHighlightingHandlers,
    setupCropHighlightingSystem: () => setupCropHighlightingSystem
  });
  var lastHighlightedSpecies = null;
  var cropHighlightInstalled = false;
  function initializeCropHighlightingAtoms(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      hookAtomForTileOverrides = typeof window !== "undefined" && window.hookAtomForTileOverrides,
      debugLog: debugLog3 = console.log,
      debugError: debugError2 = console.error
    } = dependencies;
    if (!targetWindow3.jotaiAtomCache) {
      setTimeout(() => initializeCropHighlightingAtoms(dependencies), 1e3);
      return;
    }
    try {
      if (typeof hookAtomForTileOverrides === "function") {
        hookAtomForTileOverrides(
          "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myDataAtom",
          "gardenInfo"
        );
        hookAtomForTileOverrides(
          "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom",
          "currentCrop"
        );
        debugLog3("CROP_HIGHLIGHT", "Crop highlighting atom hooks initialized");
      }
    } catch (error) {
      debugError2("CROP_HIGHLIGHT", "Failed to initialize crop highlighting atoms", error);
    }
  }
  function clearCropHighlighting(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      productionLog: productionLog3 = console.log,
      productionWarn: productionWarn3 = console.warn,
      queueNotification: queueNotification2 = typeof window !== "undefined" && window.queueNotification,
      debugLog: debugLog3 = console.log,
      debugError: debugError2 = console.error
    } = dependencies;
    try {
      if (typeof targetWindow3.removeAllTileOverrides === "function") {
        targetWindow3.removeAllTileOverrides();
        productionLog3("\u{1F331} Cleared all crop highlighting");
        if (queueNotification2) queueNotification2("\u{1F9F9} Cleared all crop highlighting", false);
        debugLog3("CROP_HIGHLIGHTING", "Cleared all tile overrides");
        return true;
      }
      productionWarn3("\u{1F331} removeAllTileOverrides function not available");
      if (queueNotification2) queueNotification2("\u26A0\uFE0F Cannot clear highlighting - game not fully loaded", false);
      debugLog3("CROP_HIGHLIGHTING", "removeAllTileOverrides function not found in window object");
      return false;
    } catch (error) {
      debugError2("CROP_HIGHLIGHTING", "Failed to clear crop highlighting", error);
      return false;
    }
  }
  function debugCropHighlighting(dependencies = {}) {
    const { targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null, productionLog: productionLog3 = console.log } = dependencies;
    productionLog3("\u{1F50D} CROP HIGHLIGHTING DEBUG:");
    productionLog3("  window.gardenInfo:", !!targetWindow3.gardenInfo);
    productionLog3("  window.currentCrop:", !!targetWindow3.currentCrop);
    productionLog3("  targetWindow.jotaiAtomCache:", !!targetWindow3.jotaiAtomCache);
    if (targetWindow3.gardenInfo?.garden?.tileObjects) {
      const tileObjects = targetWindow3.gardenInfo.garden.tileObjects;
      const tileCount = Array.isArray(tileObjects) ? tileObjects.length : tileObjects instanceof Map ? tileObjects.size : Object.keys(tileObjects).length;
      productionLog3("  Garden tiles available:", tileCount);
      if (Array.isArray(tileObjects) && tileObjects.length > 0) {
        productionLog3("  Sample tile:", tileObjects[0]);
      }
    } else {
      productionLog3("  \u274C No garden tile data available");
    }
    if (targetWindow3.currentCrop && Array.isArray(targetWindow3.currentCrop) && targetWindow3.currentCrop.length > 0) {
      productionLog3("  Current crop species:", targetWindow3.currentCrop[0]?.species);
    } else {
      productionLog3("  \u274C No current crop data available");
    }
    productionLog3("  Available functions:");
    productionLog3("    removeAllTileOverrides:", typeof targetWindow3.removeAllTileOverrides);
    productionLog3("    highlightTilesByMutation:", typeof targetWindow3.highlightTilesByMutation);
    productionLog3("    setTileSpecies:", typeof targetWindow3.setTileSpecies);
  }
  function applyCropHighlighting(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      productionLog: productionLog3 = console.log,
      productionWarn: productionWarn3 = console.warn,
      productionError: productionError2 = console.error,
      queueNotification: queueNotification2 = typeof window !== "undefined" && window.queueNotification,
      debugCropHighlighting: debugFn = debugCropHighlighting
    } = dependencies;
    productionLog3("\u{1F331} Starting crop highlighting...");
    debugFn(dependencies);
    try {
      const highlightSpecies = targetDocument2.querySelector("#highlight-species-select")?.value || null;
      const slotIndex = parseInt(targetDocument2.querySelector("#highlight-slot-input")?.value || "0");
      const hiddenSpecies = targetDocument2.querySelector("#hidden-species-select")?.value || "Carrot";
      const hiddenScale = parseFloat(targetDocument2.querySelector("#hidden-scale-input")?.value || "0.1");
      productionLog3("\u{1F331} Settings:", { highlightSpecies, slotIndex, hiddenSpecies, hiddenScale });
      if (!highlightSpecies) {
        productionWarn3("\u{1F331} No species selected for highlighting");
        if (queueNotification2) queueNotification2("\u26A0\uFE0F Please select a species to highlight first", false);
        return false;
      }
      const hasRemoveOverrides = typeof targetWindow3.removeAllTileOverrides === "function";
      const hasHighlightFunction = typeof targetWindow3.highlightTilesByMutation === "function";
      productionLog3("\u{1F331} Function availability:", {
        removeAllTileOverrides: hasRemoveOverrides,
        highlightTilesByMutation: hasHighlightFunction
      });
      if (!hasHighlightFunction) {
        productionWarn3("\u{1F331} Crop highlighting function not available - game may not be loaded yet");
        if (queueNotification2) {
          queueNotification2("\u26A0\uFE0F Crop highlighting not available - try again when fully loaded", false);
        }
        return false;
      }
      if (hasRemoveOverrides) {
        targetWindow3.removeAllTileOverrides();
        productionLog3("\u{1F331} Cleared previous highlights");
      }
      const config2 = {
        highlightSpecies: [highlightSpecies],
        // Convert to array like working reference
        highlightMutations: [null],
        // Default to no mutation filter
        slotIndex,
        highlightScale: null,
        // Let the system decide
        hiddenSpecies,
        hiddenScale
      };
      productionLog3("\u{1F331} Applying config:", config2);
      try {
        targetWindow3.highlightTilesByMutation(config2);
        productionLog3(`\u2705 Applied crop highlighting for ${highlightSpecies} (slot ${slotIndex})`);
        if (queueNotification2) {
          queueNotification2(`\u{1F331} Highlighted all ${highlightSpecies} crops (slot ${slotIndex})`, false);
        }
        setTimeout(() => {
          productionLog3("\u{1F504} Forcing render update...");
          try {
            globalThis.dispatchEvent?.(new Event("visibilitychange"));
          } catch (e) {
            productionLog3("Could not dispatch visibility change:", e);
          }
        }, 100);
        return true;
      } catch (highlightError) {
        productionError2("\u{1F331} Error during highlighting:", highlightError);
        if (queueNotification2) queueNotification2(`\u274C Crop highlighting failed: ${highlightError.message}`, false);
        return false;
      }
    } catch (error) {
      productionError2("\u274C Failed to apply crop highlighting:", error);
      if (queueNotification2) queueNotification2(`\u274C Crop highlighting system error: ${error.message}`, false);
      return false;
    }
  }
  function setupAutomaticCropHighlighting(dependencies = {}) {
    const { targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null, productionLog: productionLog3 = console.log } = dependencies;
    targetWindow3.addEventListener("keydown", function(e) {
      const active = document.activeElement;
      if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA" || active.isContentEditable)) return;
      if ((e.ctrlKey || e.metaKey) && (e.key === "c" || e.key === "C")) {
        try {
          const cc = targetWindow3.currentCrop;
          targetWindow3.removeAllTileOverrides();
          productionLog3("\u{1F331} Ctrl+C: Cleared previous highlights");
          if (cc && Array.isArray(cc) && cc.length > 0 && cc[0] && cc[0].species) {
            const species = cc[0].species;
            if (lastHighlightedSpecies === species) {
              productionLog3(`\u{1F331} Ctrl+C: Removed highlights (${species} was already highlighted)`);
              lastHighlightedSpecies = null;
            } else {
              setTimeout(() => {
                targetWindow3.highlightTilesByMutation({
                  highlightSpecies: [species],
                  highlightMutations: [null],
                  slotIndex: 0,
                  highlightScale: null,
                  hiddenSpecies: "Carrot",
                  hiddenScale: 0.1
                });
                productionLog3(`\u2705 Ctrl+C: Highlighted current crop: ${species}`);
                lastHighlightedSpecies = species;
              }, 350);
            }
          } else {
            productionLog3("\u{1F331} Ctrl+C: No current crop - highlights cleared");
            lastHighlightedSpecies = null;
          }
          e.preventDefault();
        } catch (err) {
          console.error("\u274C Error handling Ctrl+C highlight action", err);
        }
      }
    });
    productionLog3("\u{1F331} Automatic crop highlighting installed (Ctrl+C)");
  }
  function setupCropHighlightingSystem(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      productionLog: productionLog3 = console.log,
      debugLog: debugLog3 = console.log,
      debugError: debugError2 = console.error
    } = dependencies;
    productionLog3("\u{1F331} [DEBUG] setupCropHighlightingSystem() called - setting up crop highlighting...");
    if (typeof targetWindow3.removeAllTileOverrides !== "function") {
      debugLog3("CROP_HIGHLIGHT", "Crop highlighting utilities not available - they should have been installed earlier");
    } else {
      debugLog3("CROP_HIGHLIGHT", "Crop highlighting utilities confirmed available");
    }
    if (cropHighlightInstalled) {
      debugLog3("CROP_HIGHLIGHT", "Crop highlighting system already installed");
      return;
    }
    function cropHighlightHandler(e) {
      if (e.ctrlKey && e.key === "h") {
        e.preventDefault();
        e.stopPropagation();
        try {
          if (typeof targetWindow3.removeAllTileOverrides === "function") {
            targetWindow3.removeAllTileOverrides();
            debugLog3("CROP_HIGHLIGHT", "Ctrl+H \u2192 cleared all tile highlights");
          } else {
            debugLog3("CROP_HIGHLIGHT", "removeAllTileOverrides function not available");
          }
        } catch (err) {
          debugError2("CROP_HIGHLIGHT", "Failed to clear highlights", err);
        }
      }
    }
    targetWindow3.addEventListener("keydown", cropHighlightHandler, true);
    cropHighlightInstalled = true;
    debugLog3("CROP_HIGHLIGHT", "Ctrl+H crop highlight hotkey installed");
  }
  function setupCropHighlightingHandlers(context = document, dependencies = {}) {
    const {
      applyCropHighlighting: applyFn = applyCropHighlighting,
      clearCropHighlighting: clearFn = clearCropHighlighting
    } = dependencies;
    const applyHighlightingBtn = context.querySelector("#apply-highlighting-btn");
    if (applyHighlightingBtn) {
      applyHighlightingBtn.addEventListener("click", () => {
        applyFn(dependencies);
      });
    }
    const clearHighlightingBtn = context.querySelector("#clear-highlighting-btn");
    if (clearHighlightingBtn) {
      clearHighlightingBtn.addEventListener("click", () => {
        clearFn(dependencies);
      });
    }
  }
  var crop_highlighting_default = {
    // Atom Initialization
    initializeCropHighlightingAtoms,
    // Core Functions (Phase 1)
    clearCropHighlighting,
    debugCropHighlighting,
    applyCropHighlighting,
    // Automatic & Hotkeys (Phase 2)
    setupAutomaticCropHighlighting,
    setupCropHighlightingSystem,
    // Event Handlers (Phase 3)
    setupCropHighlightingHandlers
  };

  // src/features/crop-value.js
  var crop_value_exports = {};
  __export(crop_value_exports, {
    COLOR_MULT: () => COLOR_MULT,
    SPECIES_VALUES: () => SPECIES_VALUES,
    TIME_MULT: () => TIME_MULT,
    WEATHER_MULT: () => WEATHER_MULT,
    WEATHER_TIME_COMBO: () => WEATHER_TIME_COMBO,
    calculateCurrentSlotValue: () => calculateCurrentSlotValue,
    calculateMutationMultiplier: () => calculateMutationMultiplier,
    default: () => crop_value_default,
    getCurrentSlotIndex: () => getCurrentSlotIndex,
    initializeTurtleTimer: () => initializeTurtleTimer,
    insertTurtleEstimate: () => insertTurtleEstimate,
    isValidTooltipElement: () => isValidTooltipElement
  });
  if (typeof window !== "undefined" && typeof window._mgtools_currentSlotIndex === "undefined") {
    window._mgtools_currentSlotIndex = 0;
  }
  var SPECIES_VALUES = {
    Sunflower: 75e4,
    Starweaver: 1e7,
    DawnCelestial: 11e6,
    MoonCelestial: 11e6,
    Lychee: 5e4,
    DragonFruit: 24500,
    PassionFruit: 24500,
    Lemon: 1e4,
    Pepper: 7220,
    Grape: 7085,
    Bamboo: 5e5,
    Cactus: 287e3,
    Mushroom: 16e4,
    BurrosTail: 6e3,
    Lily: 20123,
    Banana: 1750,
    Coconut: 302,
    Echeveria: 5520,
    Pumpkin: 3700,
    Watermelon: 2708,
    Corn: 36,
    Daffodil: 1090,
    Tomato: 27,
    OrangeTulip: 767,
    Apple: 73,
    Blueberry: 23,
    Aloe: 310,
    Strawberry: 14,
    Carrot: 20
  };
  var COLOR_MULT = {
    Gold: 25,
    Rainbow: 50
  };
  var WEATHER_MULT = {
    Wet: 2,
    Chilled: 2,
    Frozen: 10
  };
  var TIME_MULT = {
    Dawnlit: 2,
    Dawnbound: 3,
    Dawncharged: 3,
    // Same as Dawnbound
    Amberlit: 5,
    Ambershine: 5,
    // Internal game name for Amberlit
    Amberbound: 6,
    Ambercharged: 6
    // Same as Amberbound
  };
  var WEATHER_TIME_COMBO = {
    "Wet+Dawnlit": 3,
    "Chilled+Dawnlit": 3,
    "Wet+Amberlit": 6,
    "Chilled+Amberlit": 6,
    "Wet+Ambershine": 6,
    // Internal game name for Amberlit
    "Chilled+Ambershine": 6,
    // Internal game name for Amberlit
    "Frozen+Dawnlit": 11,
    "Frozen+Dawnbound": 12,
    "Frozen+Dawncharged": 12,
    // Same as Dawnbound
    "Frozen+Amberlit": 14,
    "Frozen+Ambershine": 14,
    // Internal game name for Amberlit
    "Frozen+Amberbound": 15,
    "Frozen+Ambercharged": 15
    // Same as Amberbound
  };
  function calculateMutationMultiplier(mutations, dependencies = {}) {
    const {
      COLOR_MULT: colorMult = COLOR_MULT,
      WEATHER_MULT: weatherMult = WEATHER_MULT,
      TIME_MULT: timeMult = TIME_MULT,
      WEATHER_TIME_COMBO: weatherTimeCombo = WEATHER_TIME_COMBO
    } = dependencies;
    if (!mutations || !Array.isArray(mutations)) return 1;
    let color = 1;
    for (const m of mutations) {
      if (m === "Rainbow" && colorMult.Rainbow > color) color = colorMult.Rainbow;
      if (m === "Gold" && colorMult.Gold > color) color = colorMult.Gold;
    }
    let weather = null;
    for (const m of mutations) {
      if (weatherMult[m]) {
        if (!weather || weatherMult[m] > weatherMult[weather]) {
          weather = m;
        }
      }
    }
    let time = null;
    for (const m of mutations) {
      if (timeMult[m]) {
        if (!time || timeMult[m] > timeMult[time]) {
          time = m;
        }
      }
    }
    let wt = 1;
    if (!weather && !time) wt = 1;
    else if (weather && !time) wt = weatherMult[weather];
    else if (!weather && time) wt = timeMult[time];
    else {
      const combo = `${weather}+${time}`;
      wt = weatherTimeCombo[combo] || Math.max(weatherMult[weather], timeMult[time]);
    }
    return Math.round(color * wt);
  }
  function getCurrentSlotIndex(currentCrop, dependencies = {}) {
    const { targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null } = dependencies;
    if (!currentCrop || currentCrop.length <= 1) return 0;
    return targetWindow3._mgtools_currentSlotIndex || 0;
  }
  function calculateCurrentSlotValue(currentCrop, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      SPECIES_VALUES: speciesValues = SPECIES_VALUES,
      calculateMutationMultiplier: calcMult = calculateMutationMultiplier,
      getCurrentSlotIndex: getSlotIndex = getCurrentSlotIndex
    } = dependencies;
    if (!currentCrop || currentCrop.length === 0) return 0;
    const friendBonus = UnifiedState3.atoms.friendBonus || 1;
    const slotIndex = getSlotIndex(currentCrop, dependencies);
    const sortedIndices = UnifiedState3.atoms.sortedSlotIndices || targetWindow3.sortedSlotIndices;
    let actualSlotIndex = slotIndex;
    if (sortedIndices && Array.isArray(sortedIndices) && sortedIndices.length > 0) {
      if (slotIndex < sortedIndices.length) {
        actualSlotIndex = sortedIndices[slotIndex];
        console.log(`\u{1F504} [CROP-VALUE] Using sorted index: position ${slotIndex} \u2192 actual slot ${actualSlotIndex}`);
      }
    }
    console.log(`\u{1F4CA} [CROP-VALUE] Calculating value for slot ${actualSlotIndex}/${currentCrop.length}`, {
      displayIndex: slotIndex,
      actualSlotIndex,
      cropCount: currentCrop.length,
      windowIndex: targetWindow3._mgtools_currentSlotIndex,
      sortedIndices
    });
    if (actualSlotIndex < 0 || actualSlotIndex >= currentCrop.length) {
      console.error(`[CROP-VALUE] Invalid slot index: ${actualSlotIndex} for crop array length: ${currentCrop.length}`);
      targetWindow3._mgtools_currentSlotIndex = 0;
      return 0;
    }
    const slot = currentCrop[actualSlotIndex];
    if (!slot || !slot.species) {
      console.log(`[CROP-VALUE] No species at slot ${actualSlotIndex}`, slot);
      return 0;
    }
    const multiplier = calcMult(slot.mutations, dependencies);
    const speciesVal = speciesValues[slot.species] || 0;
    const scale = slot.targetScale || 1;
    const value = Math.round(multiplier * speciesVal * scale * friendBonus);
    console.log(
      `\u{1F4B0} [CROP-VALUE] Slot ${actualSlotIndex}/${currentCrop.length}: ${slot.species} = ${value.toLocaleString()}`,
      {
        species: slot.species,
        speciesVal,
        multiplier,
        scale,
        friendBonus,
        value
      }
    );
    return value;
  }
  function isValidTooltipElement(element, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState
    } = dependencies;
    if (!element) return false;
    try {
      const rect = element.getBoundingClientRect();
      if (rect.top < 50 && rect.left < 50) {
        return false;
      }
      if (rect.width < 50 || rect.height < 30) {
        return false;
      }
      const viewportWidth = window.innerWidth || targetDocument2.documentElement.clientWidth;
      const viewportHeight = window.innerHeight || targetDocument2.documentElement.clientHeight;
      if (rect.right < 0 || rect.bottom < 0 || rect.left > viewportWidth || rect.top > viewportHeight) {
        return false;
      }
      const hasText = element.textContent && element.textContent.trim().length > 0;
      if (!hasText) {
        return false;
      }
      return true;
    } catch (e) {
      if (UnifiedState3?.data?.settings?.debugMode) {
        console.error("[CROP-VALUE] \u274C Error validating tooltip element:", e);
      }
      return false;
    }
  }
  function insertTurtleEstimate(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      isValidTooltipElement: validateTooltip = isValidTooltipElement,
      getEggExpectations: getEggExpectations3 = targetWindow3?.getEggExpectations,
      estimateUntilLatestCrop: estimateUntilLatestCrop3 = targetWindow3?.estimateUntilLatestCrop,
      getCurrentSlotIndex: getSlotIndex = getCurrentSlotIndex,
      calculateCurrentSlotValue: calcSlotValue = calculateCurrentSlotValue
    } = dependencies;
    const doc = targetDocument2 || document;
    doc.querySelectorAll('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]').forEach((el2) => el2.remove());
    let currentPlantTooltipFlexbox = doc.querySelector(
      "div.QuinoaUI > div.McFlex:nth-of-type(2) > div.McGrid > div.McFlex:nth-of-type(3) > :first-child > :last-child p"
    )?.parentElement;
    if (!currentPlantTooltipFlexbox) {
      const altSelectors = [
        "div.QuinoaUI .McFlex .McGrid",
        '[class*="tooltip"] [class*="flex"]',
        'div[class*="plant"] div[class*="info"]',
        ".McFlex .McGrid .McFlex",
        "div.QuinoaUI div.McFlex div.McGrid"
      ];
      for (const sel of altSelectors) {
        const el2 = doc.querySelector(sel);
        if (el2 && validateTooltip(el2, dependencies)) {
          currentPlantTooltipFlexbox = el2;
          break;
        }
      }
      if (!currentPlantTooltipFlexbox) {
        return;
      }
    }
    if (!validateTooltip(currentPlantTooltipFlexbox, dependencies)) {
      console.warn("[CROP-VALUE] \u26A0\uFE0F Rejected invalid tooltip position - skipping slot value display");
      return;
    }
    let currentCrop = targetWindow3.currentCrop || UnifiedState3.atoms.currentCrop;
    const currentEgg = targetWindow3.currentEgg || UnifiedState3.atoms.currentEgg;
    if (!currentCrop && !currentEgg) {
      const possibleLocations = [
        targetWindow3.gameState?.currentCrop,
        targetWindow3.gameState?.currentEgg,
        targetWindow3.UnifiedState?.atoms?.currentCrop,
        targetWindow3.garden?.currentTile?.crop,
        targetWindow3.playerState?.standingOn?.crop,
        targetWindow3.jotaiAtomCache?.get?.(
          "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom"
        )?.debugValue
      ];
      for (const loc of possibleLocations) {
        if (loc) {
          currentCrop = Array.isArray(loc) ? loc : [loc];
          break;
        }
      }
      if (!currentCrop && !currentEgg && currentPlantTooltipFlexbox) {
        const tooltipText = currentPlantTooltipFlexbox.textContent || "";
        const eggPattern = /(Common|Uncommon|Rare|Legendary|Mythical)\s*Egg/i;
        const eggMatch = tooltipText.match(eggPattern);
        if (eggMatch) {
          const eggSpecies = eggMatch[0].replace(/\s+/g, "");
          currentCrop = [
            {
              species: eggSpecies,
              type: "egg",
              category: "egg",
              isEgg: true
            }
          ];
        } else {
          const cropPatterns = [
            /Carrot/i,
            /Wheat/i,
            /Corn/i,
            /Tomato/i,
            /Potato/i,
            /Pumpkin/i,
            /Watermelon/i,
            /Strawberry/i,
            /Blueberry/i,
            /Rose/i,
            /Tulip/i,
            /Sunflower/i,
            /Daisy/i,
            /Lily/i
          ];
          for (const pattern of cropPatterns) {
            const cropMatch = tooltipText.match(pattern);
            if (cropMatch) {
              currentCrop = [
                {
                  species: cropMatch[0],
                  type: "crop",
                  category: "plant"
                }
              ];
              break;
            }
          }
        }
      }
    }
    const isPlantedEgg1 = currentCrop?.[0]?.species?.endsWith("Egg");
    const isPlantedEgg2 = currentCrop?.[0]?.species?.includes("Egg");
    const isPlantedEgg3 = currentCrop?.[0]?.type === "egg";
    const isPlantedEgg4 = currentCrop?.[0]?.category === "egg";
    const isPlantedEgg = isPlantedEgg1 || isPlantedEgg2 || isPlantedEgg3 || isPlantedEgg4;
    const isEgg = currentEgg || isPlantedEgg;
    if (isEgg) {
      const activePets = targetWindow3.activePets || UnifiedState3.atoms.activePets;
      const eggExpectations = getEggExpectations3(activePets);
      const timeElement2 = [...currentPlantTooltipFlexbox.childNodes].find(
        (el2) => /^\d+h(?: \d+m)?(?: \d+s)?$|^\d+m(?: \d+s)?$|^\d+s$/.test((el2.textContent || "").trim())
      );
      if (!timeElement2) {
        return;
      }
      const timeText = timeElement2.textContent.trim();
      const timeMatch = timeText.match(/(?:(\d+)h)?\s*(?:(\d+)m)?\s*(?:(\d+)s)?/);
      if (!timeMatch) {
        return;
      }
      const hours = parseInt(timeMatch[1] || "0", 10);
      const minutes = parseInt(timeMatch[2] || "0", 10);
      const seconds = parseInt(timeMatch[3] || "0", 10);
      const totalSeconds = hours * 3600 + minutes * 60 + seconds;
      if (totalSeconds <= 0) {
        return;
      }
      if (eggExpectations && eggExpectations.expectedMinutesRemoved > 0) {
        const remainingRealMinutes = totalSeconds / 60;
        const effectiveRate = eggExpectations.expectedMinutesRemoved + 1;
        const boostedRealMinutes = remainingRealMinutes / effectiveRate;
        const boostedTotalSeconds = boostedRealMinutes * 60;
        const boostedHours = Math.floor(boostedTotalSeconds / 3600);
        const boostedMinutes = Math.floor(boostedTotalSeconds % 3600 / 60);
        const boostedSeconds = Math.floor(boostedTotalSeconds % 60);
        const eggEstimateEl = doc.createElement("p");
        eggEstimateEl.dataset.turtletimerEstimate = "true";
        if (boostedHours > 0) {
          eggEstimateEl.textContent = `\u{1F95A} Egg: ${boostedHours}h ${boostedMinutes}m`;
        } else {
          eggEstimateEl.textContent = `\u{1F95A} Egg: ${boostedMinutes}m ${boostedSeconds}s`;
        }
        eggEstimateEl.style.color = "#fbbf24";
        currentPlantTooltipFlexbox.appendChild(eggEstimateEl);
      }
      return;
    }
    if (!currentCrop || currentCrop.length === 0) return;
    const currentSlotIndex = getSlotIndex(currentCrop, dependencies);
    const timeElement = [...currentPlantTooltipFlexbox.childNodes].find(
      (el2) => /^\d+h(?: \d+m)?(?: \d+s)?$|^\d+m(?: \d+s)?$|^\d+s$/.test((el2.textContent || "").trim())
    );
    if (timeElement) {
      const activePets = targetWindow3.activePets || UnifiedState3.atoms.activePets;
      const slotIndex = getSlotIndex(currentCrop, dependencies);
      const sortedIndices = UnifiedState3.atoms.sortedSlotIndices || window.sortedSlotIndices;
      let actualSlotIndex = slotIndex;
      if (sortedIndices && Array.isArray(sortedIndices) && sortedIndices.length > 0 && slotIndex < sortedIndices.length) {
        actualSlotIndex = sortedIndices[slotIndex];
      }
      const estimate = estimateUntilLatestCrop3(currentCrop, activePets, actualSlotIndex);
      if (estimate) {
        const estimateEl = doc.createElement("p");
        estimateEl.dataset.turtletimerEstimate = "true";
        estimateEl.textContent = estimate;
        estimateEl.style.color = "#4ade80";
        currentPlantTooltipFlexbox.appendChild(estimateEl);
      }
    }
    const slotValue = calcSlotValue(currentCrop, dependencies);
    if (slotValue > 0) {
      const slotValueEl = doc.createElement("p");
      slotValueEl.dataset.turtletimerSlotValue = "true";
      slotValueEl.innerHTML = `<img src="https://cdn.discordapp.com/emojis/1425389207525920808.webp?size=96" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 2px; display: inline-block;">` + Number(slotValue).toLocaleString();
      currentPlantTooltipFlexbox.appendChild(slotValueEl);
    }
  }
  function initializeTurtleTimer(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      console: consoleObj = typeof console !== "undefined" ? console : null,
      productionLog: productionLog3 = targetWindow3?.productionLog || (() => {
      }),
      hookAtom: hookAtom3 = targetWindow3?.hookAtom,
      listenToSlotIndexAtom: listenToSlotIndexAtom3 = targetWindow3?.listenToSlotIndexAtom,
      getCropHash: getCropHash3 = targetWindow3?.getCropHash,
      insertTurtleEstimate: insertEstimate = insertTurtleEstimate
    } = dependencies;
    consoleObj.log("\u{1F422}\u{1F422}\u{1F422} [TURTLE-TIMER-START] initializeTurtleTimer() called!");
    productionLog3("\u{1F422} [TURTLE-TIMER] Initializing crop growth estimate...");
    listenToSlotIndexAtom3();
    hookAtom3(
      "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentSortedGrowSlotIndicesAtom",
      "sortedSlotIndices",
      (value) => {
        return value;
      }
    );
    hookAtom3(
      "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom",
      "currentCrop",
      (value) => {
        let cropData = null;
        if (value?.garden?.tileObjects) {
          cropData = value.garden.tileObjects;
        } else if (Array.isArray(value)) {
          cropData = value;
        }
        UnifiedState3.atoms.currentCrop = cropData;
        targetWindow3.currentCrop = cropData;
        const currentHash = getCropHash3(cropData || value);
        if (currentHash !== globalThis.prevCropHash) {
          globalThis.prevCropHash = currentHash;
          requestAnimationFrame(() => insertEstimate(dependencies));
        }
        return value;
      }
    );
    const doc = targetDocument2;
    setInterval(() => {
      let currentCrop = targetWindow3.currentCrop || UnifiedState3.atoms.currentCrop;
      const currentEgg = targetWindow3.currentEgg || UnifiedState3.atoms.currentEgg;
      let manualCrop = null;
      if (!currentCrop) {
        if (!targetWindow3.__foundJotaiStore) {
          const possibleStores = [
            targetWindow3.jotaiStore,
            targetWindow3.__JOTAI_STORE__,
            targetWindow3.store,
            targetWindow3.getDefaultStore?.(),
            targetWindow3.globalStore,
            targetWindow3.__jotaiStore,
            targetWindow3._jotaiStore
          ];
          for (const store of possibleStores) {
            if (store && typeof store.get === "function" && store !== targetWindow3.cookieStore && store !== window.cookieStore && (typeof store.set === "function" || typeof store.sub === "function")) {
              targetWindow3.__foundJotaiStore = store;
              break;
            }
          }
          if (!targetWindow3.__foundJotaiStore) {
            const storeKeys = Object.keys(targetWindow3).filter(
              (k) => k.toLowerCase().includes("store") || k.toLowerCase().includes("jotai")
            );
            for (const key of storeKeys) {
              const val = targetWindow3[key];
              if (val && typeof val === "object" && typeof val.get === "function" && val !== targetWindow3.cookieStore && val !== window.cookieStore && (typeof val.set === "function" || typeof val.sub === "function")) {
                targetWindow3.__foundJotaiStore = val;
                break;
              }
            }
            if (!targetWindow3.__foundJotaiStore && targetWindow3.jotaiAtomCache) {
              const cache = targetWindow3.jotaiAtomCache;
              if (cache.store) {
                targetWindow3.__foundJotaiStore = cache.store;
              } else if (cache.cache && cache.cache.store) {
                targetWindow3.__foundJotaiStore = cache.cache.store;
              }
            }
          }
        }
        const atomCache = targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache;
        if (atomCache && atomCache.get) {
          const cropAtom = atomCache.get(
            "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom"
          );
          if (cropAtom) {
            if (targetWindow3.__foundJotaiStore) {
              try {
                const cropValue = targetWindow3.__foundJotaiStore.get(cropAtom);
                if (cropValue && typeof cropValue.then === "function") {
                  cropValue.then((val) => {
                    targetWindow3.currentCrop = val;
                    UnifiedState3.atoms.currentCrop = val;
                    if (val && !document.querySelector('[data-turtletimer-estimate="true"]')) {
                      insertEstimate(dependencies);
                    }
                  }).catch((e) => {
                  });
                } else {
                  manualCrop = cropValue;
                  targetWindow3.currentCrop = cropValue;
                  UnifiedState3.atoms.currentCrop = cropValue;
                }
              } catch (e) {
              }
            }
            if (!manualCrop && cropAtom.debugValue !== void 0) {
              manualCrop = cropAtom.debugValue;
            }
            if (!manualCrop && typeof cropAtom.read === "function") {
              try {
                const mockGetter = (a) => {
                  if (a === cropAtom && cropAtom.init !== void 0) {
                    return cropAtom.init;
                  }
                  return void 0;
                };
                const directValue = cropAtom.read(mockGetter);
                if (directValue && typeof directValue.then !== "function") {
                  manualCrop = directValue;
                }
              } catch (e) {
              }
            }
          }
        }
      }
      if (manualCrop && !currentCrop) {
        currentCrop = manualCrop;
      }
      const doc2 = targetDocument2 || document;
      const tooltipVisible = doc2.querySelector("div.QuinoaUI > div.McFlex:nth-of-type(2) > div.McGrid");
      if (currentCrop || currentEgg || tooltipVisible) {
        const hasExisting = doc2.querySelector('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]');
        if (!hasExisting) {
          insertEstimate(dependencies);
        }
      }
    }, 1e3);
    const isMovementKeypress = (e) => !e.ctrlKey && !e.shiftKey && ["KeyW", "KeyA", "KeyS", "KeyD", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.code);
    const onMovementKey = (handler) => (e) => {
      if (isMovementKeypress(e)) handler(e);
    };
    doc.addEventListener(
      "keydown",
      onMovementKey(() => {
        doc.querySelectorAll('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]').forEach((el2) => el2.remove());
      })
    );
    doc.addEventListener(
      "keyup",
      onMovementKey(() => {
        insertEstimate(dependencies);
      })
    );
    productionLog3("\u2705 [TURTLE-TIMER] Turtle timer initialized successfully");
  }
  var crop_value_default = {
    // Constants (Phase 1)
    SPECIES_VALUES,
    COLOR_MULT,
    WEATHER_MULT,
    TIME_MULT,
    WEATHER_TIME_COMBO,
    // Multiplier Calculation (Phase 1)
    calculateMutationMultiplier,
    // Value Calculation (Phase 2)
    getCurrentSlotIndex,
    calculateCurrentSlotValue,
    isValidTooltipElement,
    // Turtle Timer & UI Integration (Phase 3)
    insertTurtleEstimate,
    initializeTurtleTimer
  };

  // src/features/auto-favorite.js
  var auto_favorite_exports = {};
  __export(auto_favorite_exports, {
    favoriteMutation: () => favoriteMutation2,
    favoritePetAbility: () => favoritePetAbility2,
    favoriteSpecies: () => favoriteSpecies2,
    initAutoFavorite: () => initAutoFavorite2,
    unfavoriteMutation: () => unfavoriteMutation2,
    unfavoritePetAbility: () => unfavoritePetAbility2,
    unfavoriteSpecies: () => unfavoriteSpecies2
  });
  function initAutoFavorite2({ UnifiedState: UnifiedState3, targetWindow: targetWindow3, productionLog: productionLog3 }) {
    let lastInventoryCount = 0;
    setInterval(() => {
      if (!UnifiedState3.data.settings.autoFavorite.enabled) {
        return;
      }
      const watchedSpecies = UnifiedState3.data.settings.autoFavorite.species || [];
      const watchedMutations = UnifiedState3.data.settings.autoFavorite.mutations || [];
      if (watchedSpecies.length === 0 && watchedMutations.length === 0) {
        return;
      }
      if (!targetWindow3.myData?.inventory?.items) {
        return;
      }
      const currentCount = targetWindow3.myData.inventory.items.length;
      if (currentCount > lastInventoryCount) {
        checkAndFavoriteNewItems2({
          inventory: targetWindow3.myData.inventory,
          UnifiedState: UnifiedState3,
          targetWindow: targetWindow3,
          productionLog: productionLog3
        });
      }
      lastInventoryCount = currentCount;
    }, 2e3);
    productionLog3("\u{1F31F} [AUTO-FAVORITE] System initialized - monitoring inventory changes");
  }
  function checkAndFavoriteNewItems2({ inventory, UnifiedState: UnifiedState3, targetWindow: targetWindow3, productionLog: productionLog3 }) {
    if (!inventory?.items) return;
    if (!UnifiedState3.data.settings.autoFavorite.petAbilities) {
      UnifiedState3.data.settings.autoFavorite.petAbilities = [];
    }
    if (!UnifiedState3.data.settings.autoFavorite.species.length && !UnifiedState3.data.settings.autoFavorite.mutations.length && !UnifiedState3.data.settings.autoFavorite.petAbilities.length)
      return;
    const favoritedIds = new Set(inventory.favoritedItemIds || []);
    const targetSpecies = new Set(UnifiedState3.data.settings.autoFavorite.species);
    const targetMutations = new Set(UnifiedState3.data.settings.autoFavorite.mutations);
    const targetPetAbilities = new Set(UnifiedState3.data.settings.autoFavorite.petAbilities);
    let cropCount = 0;
    let petCount = 0;
    for (const item of inventory.items) {
      if (favoritedIds.has(item.id)) continue;
      if (item.itemType === "Pet") {
        const petMutations = item.mutations || [];
        const hasGoldMutation = petMutations.includes("Gold");
        const hasRainbowMutation = petMutations.includes("Rainbow");
        const petAbilities = item.abilities || [];
        const hasGoldGranterAbility = petAbilities.some((a) => {
          const abilityStr = typeof a === "string" ? a : a?.type || a?.abilityType || "";
          return abilityStr.toLowerCase().includes("gold") && abilityStr.toLowerCase().includes("grant");
        });
        const hasRainbowGranterAbility = petAbilities.some((a) => {
          const abilityStr = typeof a === "string" ? a : a?.type || a?.abilityType || "";
          return abilityStr.toLowerCase().includes("rainbow") && abilityStr.toLowerCase().includes("grant");
        });
        const shouldFavorite = targetPetAbilities.has("Gold Granter") && (hasGoldMutation || hasGoldGranterAbility) || targetPetAbilities.has("Rainbow Granter") && (hasRainbowMutation || hasRainbowGranterAbility);
        if (shouldFavorite) {
          if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
            targetWindow3.MagicCircle_RoomConnection.sendMessage({
              scopePath: ["Room", "Quinoa"],
              type: "ToggleFavoriteItem",
              itemId: item.id
            });
            petCount++;
          }
        }
        continue;
      }
      if (item.itemType !== "Produce") continue;
      if (item.itemType === "Egg" || item.itemType === "Tool") continue;
      if (item.category === "Egg" || item.category === "Tool") continue;
      if (item.species && (item.species.includes("Pet") || item.species.includes("Egg"))) continue;
      const matchesSpecies = targetSpecies.has(item.species);
      const itemMutations = item.mutations || [];
      const matchesMutation = itemMutations.some((mut) => targetMutations.has(mut));
      if (matchesSpecies || matchesMutation) {
        if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
          targetWindow3.MagicCircle_RoomConnection.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: "ToggleFavoriteItem",
            itemId: item.id
          });
          cropCount++;
        }
      }
    }
    if (cropCount > 0) {
      productionLog3(`\u{1F31F} [AUTO-FAVORITE] Auto-favorited ${cropCount} new crops`);
    }
    if (petCount > 0) {
      productionLog3(`\u{1F31F} [AUTO-FAVORITE] Auto-favorited ${petCount} new pets`);
    }
  }
  function favoriteSpecies2(speciesName, { targetWindow: targetWindow3, productionLog: productionLog3 }) {
    if (!targetWindow3.myData?.inventory?.items) {
      productionLog3("\u{1F31F} [AUTO-FAVORITE] No myData available yet - waiting for game to load");
      return;
    }
    const items = targetWindow3.myData.inventory.items;
    const favoritedIds = new Set(targetWindow3.myData.inventory.favoritedItemIds || []);
    let count = 0;
    for (const item of items) {
      if (item.itemType !== "Produce") continue;
      if (item.itemType === "Pet" || item.itemType === "Egg" || item.itemType === "Tool") continue;
      if (item.category === "Pet" || item.category === "Egg" || item.category === "Tool") continue;
      if (item.species && (item.species.includes("Pet") || item.species.includes("Egg"))) continue;
      if (item.species === speciesName && !favoritedIds.has(item.id)) {
        if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
          targetWindow3.MagicCircle_RoomConnection.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: "ToggleFavoriteItem",
            itemId: item.id
          });
          count++;
        }
      }
    }
    if (count > 0) {
      productionLog3(`\u2705 [AUTO-FAVORITE] Favorited ${count} ${speciesName} crops`);
    } else {
      productionLog3(`\u2139\uFE0F [AUTO-FAVORITE] No ${speciesName} crops to favorite (already favorited or none in inventory)`);
    }
  }
  function unfavoriteSpecies2(speciesName, { productionLog: productionLog3 }) {
    productionLog3(
      `\u{1F512} [AUTO-FAVORITE] Checkbox unchecked for ${speciesName} - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
    );
  }
  function favoriteMutation2(mutationName, { targetWindow: targetWindow3, productionLog: productionLog3 }) {
    if (!targetWindow3.myData?.inventory?.items) {
      productionLog3("\u{1F31F} [AUTO-FAVORITE] No myData available yet - waiting for game to load");
      return;
    }
    const items = targetWindow3.myData.inventory.items;
    const favoritedIds = new Set(targetWindow3.myData.inventory.favoritedItemIds || []);
    let count = 0;
    for (const item of items) {
      if (item.itemType !== "Produce") continue;
      if (item.itemType === "Pet" || item.itemType === "Egg" || item.itemType === "Tool") continue;
      if (item.category === "Pet" || item.category === "Egg" || item.category === "Tool") continue;
      if (item.species && (item.species.includes("Pet") || item.species.includes("Egg"))) continue;
      const itemMutations = item.mutations || [];
      if (itemMutations.includes(mutationName) && !favoritedIds.has(item.id)) {
        if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
          targetWindow3.MagicCircle_RoomConnection.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: "ToggleFavoriteItem",
            itemId: item.id
          });
          count++;
        }
      }
    }
    if (count > 0) {
      productionLog3(`\u2705 [AUTO-FAVORITE] Favorited ${count} crops with ${mutationName} mutation`);
    } else {
      productionLog3(
        `\u2139\uFE0F [AUTO-FAVORITE] No crops with ${mutationName} mutation to favorite (already favorited or none in inventory)`
      );
    }
  }
  function unfavoriteMutation2(mutationName, { productionLog: productionLog3 }) {
    productionLog3(
      `\u{1F512} [AUTO-FAVORITE] Checkbox unchecked for ${mutationName} mutation - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
    );
  }
  function favoritePetAbility2(abilityName, { targetWindow: targetWindow3, productionLog: productionLog3 }) {
    if (!targetWindow3.myData?.inventory?.items) {
      productionLog3("\u{1F31F} [AUTO-FAVORITE-PET] No myData available yet - waiting for game to load");
      return;
    }
    productionLog3(`\u{1F50D} [AUTO-FAVORITE-PET] Searching for pets with ${abilityName}...`);
    const items = targetWindow3.myData.inventory.items;
    const favoritedIds = new Set(targetWindow3.myData.inventory.favoritedItemIds || []);
    let count = 0;
    let petsChecked = 0;
    const firstPet = items.find((i) => i.itemType === "Pet");
    if (firstPet) {
      productionLog3("\u{1F43E} [AUTO-FAVORITE-PET-DEBUG] Sample pet structure:", {
        species: firstPet.petSpecies,
        mutations: firstPet.mutations,
        abilities: firstPet.abilities,
        hasAbilitiesArray: Array.isArray(firstPet.abilities),
        hasMutationsArray: Array.isArray(firstPet.mutations)
      });
    }
    for (const item of items) {
      if (item.itemType !== "Pet") continue;
      petsChecked++;
      if (favoritedIds.has(item.id)) continue;
      const petMutations = item.mutations || [];
      const hasGoldMutation = petMutations.includes("Gold");
      const hasRainbowMutation = petMutations.includes("Rainbow");
      const petAbilities = item.abilities || [];
      const hasGoldGranterAbility = petAbilities.some((a) => {
        const abilityStr = typeof a === "string" ? a : a?.type || a?.abilityType || "";
        return abilityStr.toLowerCase().includes("gold") && abilityStr.toLowerCase().includes("grant");
      });
      const hasRainbowGranterAbility = petAbilities.some((a) => {
        const abilityStr = typeof a === "string" ? a : a?.type || a?.abilityType || "";
        return abilityStr.toLowerCase().includes("rainbow") && abilityStr.toLowerCase().includes("grant");
      });
      const shouldFavorite = abilityName === "Gold Granter" && (hasGoldMutation || hasGoldGranterAbility) || abilityName === "Rainbow Granter" && (hasRainbowMutation || hasRainbowGranterAbility);
      if (shouldFavorite) {
        productionLog3(
          `\u2728 [AUTO-FAVORITE-PET] Found matching pet: ${item.petSpecies} (${item.id}) - mutations: [${petMutations.join(", ")}], abilities: ${petAbilities.length}`
        );
        if (targetWindow3.MagicCircle_RoomConnection?.sendMessage) {
          targetWindow3.MagicCircle_RoomConnection.sendMessage({
            scopePath: ["Room", "Quinoa"],
            type: "ToggleFavoriteItem",
            itemId: item.id
          });
          count++;
        }
      }
    }
    productionLog3(`\u2705 [AUTO-FAVORITE-PET] Scanned ${petsChecked} pets, favorited ${count} with ${abilityName}`);
  }
  function unfavoritePetAbility2(abilityName, { productionLog: productionLog3 }) {
    productionLog3(
      `\u{1F512} [AUTO-FAVORITE-PET] Checkbox unchecked for ${abilityName} - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`
    );
  }

  // src/features/value-manager.js
  var value_manager_exports = {};
  __export(value_manager_exports, {
    COLOR_MULT: () => COLOR_MULT2,
    SPECIES_VALUES: () => SPECIES_VALUES2,
    TIME_MULT: () => TIME_MULT2,
    ValueManager: () => ValueManager,
    WEATHER_MULT: () => WEATHER_MULT2,
    WEATHER_TIME_COMBO: () => WEATHER_TIME_COMBO2,
    calculateMutationMultiplier: () => calculateMutationMultiplier2,
    initializeValueManager: () => initializeValueManager,
    updateValues: () => updateValues
  });
  var SPECIES_VALUES2 = {
    Sunflower: 75e4,
    Starweaver: 1e7,
    DawnCelestial: 11e6,
    MoonCelestial: 11e6,
    Lychee: 5e4,
    DragonFruit: 24500,
    PassionFruit: 24500,
    Lemon: 1e4,
    Pepper: 7220,
    Grape: 7085,
    Bamboo: 5e5,
    Cactus: 287e3,
    Mushroom: 16e4,
    BurrosTail: 6e3,
    Lily: 20123,
    Banana: 1750,
    Coconut: 302,
    Echeveria: 5520,
    Pumpkin: 3700,
    Watermelon: 2708,
    Corn: 36,
    Daffodil: 1090,
    Tomato: 27,
    OrangeTulip: 767,
    Apple: 73,
    Blueberry: 23,
    Aloe: 310,
    Strawberry: 14,
    Carrot: 20
  };
  var COLOR_MULT2 = {
    Gold: 25,
    Rainbow: 50
  };
  var WEATHER_MULT2 = {
    Wet: 2,
    Chilled: 2,
    Frozen: 10
  };
  var TIME_MULT2 = {
    Dawnlit: 2,
    Dawnbound: 3,
    Dawncharged: 3,
    // Same as Dawnbound
    Amberlit: 5,
    Ambershine: 5,
    // Internal game name for Amberlit
    Amberbound: 6,
    Ambercharged: 6
    // Same as Amberbound
  };
  var WEATHER_TIME_COMBO2 = {
    "Wet+Dawnlit": 3,
    "Chilled+Dawnlit": 3,
    "Wet+Amberlit": 6,
    "Chilled+Amberlit": 6,
    "Wet+Ambershine": 6,
    // Internal game name for Amberlit
    "Chilled+Ambershine": 6,
    // Internal game name for Amberlit
    "Frozen+Dawnlit": 11,
    "Frozen+Dawnbound": 12,
    "Frozen+Dawncharged": 12,
    // Same as Dawnbound
    "Frozen+Amberlit": 14,
    "Frozen+Ambershine": 14,
    // Internal game name for Amberlit
    "Frozen+Amberbound": 15,
    "Frozen+Ambercharged": 15
    // Same as Amberbound
  };
  function calculateMutationMultiplier2(mutations) {
    if (!mutations || !Array.isArray(mutations)) return 1;
    let color = 1;
    for (const m of mutations) {
      if (m === "Rainbow" && COLOR_MULT2.Rainbow > color) color = COLOR_MULT2.Rainbow;
      if (m === "Gold" && COLOR_MULT2.Gold > color) color = COLOR_MULT2.Gold;
    }
    let weather = null;
    for (const m of mutations) {
      if (WEATHER_MULT2[m]) {
        if (!weather || WEATHER_MULT2[m] > WEATHER_MULT2[weather]) {
          weather = m;
        }
      }
    }
    let time = null;
    for (const m of mutations) {
      if (TIME_MULT2[m]) {
        if (!time || TIME_MULT2[m] > TIME_MULT2[time]) {
          time = m;
        }
      }
    }
    let wt = 1;
    if (!weather && !time) wt = 1;
    else if (weather && !time) wt = WEATHER_MULT2[weather];
    else if (!weather && time) wt = TIME_MULT2[time];
    else {
      const combo = `${weather}+${time}`;
      wt = WEATHER_TIME_COMBO2[combo] || Math.max(WEATHER_MULT2[weather], TIME_MULT2[time]);
    }
    return Math.round(color * wt);
  }
  var ValueManager = class {
    /**
     * Create a ValueManager instance
     *
     * @param {Object} dependencies - Injected dependencies
     * @param {Object} dependencies.UnifiedState - Global state manager
     * @param {Document} dependencies.targetDocument - Target document for MutationObserver
     * @param {Function} dependencies.debugLog - Debug logging function
     * @param {Function} dependencies.debugError - Error logging function
     * @param {Function} dependencies.updateTabContent - Update main tab content
     * @param {Function} dependencies.updatePureOverlayContent - Update pure overlay content
     * @param {Function} dependencies.getValuesTabContent - Get values tab HTML
     * @param {Function} dependencies.refreshSeparateWindowPopouts - Refresh separate windows
     */
    constructor({
      UnifiedState: UnifiedState3,
      targetDocument: targetDocument2,
      debugLog: debugLog3,
      debugError: debugError2,
      updateTabContent,
      updatePureOverlayContent: updatePureOverlayContent2,
      getValuesTabContent: getValuesTabContent2,
      refreshSeparateWindowPopouts: refreshSeparateWindowPopouts2
    }) {
      this.UnifiedState = UnifiedState3;
      this.targetDocument = targetDocument2;
      this.debugLog = debugLog3;
      this.debugError = debugError2;
      this.updateTabContent = updateTabContent;
      this.updatePureOverlayContent = updatePureOverlayContent2;
      this.getValuesTabContent = getValuesTabContent2;
      this.refreshSeparateWindowPopouts = refreshSeparateWindowPopouts2;
      this.cache = {
        inventoryValue: { value: 0, lastUpdate: 0 },
        tileValue: { value: 0, lastUpdate: 0 },
        gardenValue: { value: 0, lastUpdate: 0 }
      };
      this.throttleMs = 100;
      this.retryAttempts = 3;
      this.observer = null;
      this.initializeObserver();
      this.debugLog("VALUE_MANAGER", "ValueManager initialized", { throttleMs: this.throttleMs });
    }
    /**
     * Initialize MutationObserver for automatic cache invalidation
     *
     * Watches for DOM changes related to inventory, garden, and crops
     * to automatically invalidate cached values when game state changes.
     *
     * @returns {void}
     * @private
     */
    initializeObserver() {
      if (typeof MutationObserver !== "undefined") {
        this.observer = new MutationObserver((mutations) => {
          let shouldUpdate = false;
          mutations.forEach((mutation) => {
            if (mutation.target.className && (mutation.target.className.includes("inventory") || mutation.target.className.includes("garden") || mutation.target.className.includes("crop"))) {
              shouldUpdate = true;
            }
          });
          if (shouldUpdate) {
            this.invalidateCache();
            this.debugLog("VALUE_MANAGER", "Game state change detected, invalidating cache");
          }
        });
        this.observer.observe(this.targetDocument.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "data-value"]
        });
      }
    }
    /**
     * Get tile value (current crop being hovered)
     *
     * @param {boolean} forceRefresh - Force recalculation ignoring cache
     * @returns {number} Total value of current tile
     */
    getTileValue(forceRefresh = false) {
      return this.getCachedValue("tileValue", forceRefresh, () => this.calculateTileValue());
    }
    /**
     * Get total inventory value
     *
     * @param {boolean} forceRefresh - Force recalculation ignoring cache
     * @returns {number} Total value of all crops in inventory
     */
    getInventoryValue(forceRefresh = false) {
      return this.getCachedValue("inventoryValue", forceRefresh, () => this.calculateInventoryValue());
    }
    /**
     * Get total garden value (ready-to-harvest crops)
     *
     * @param {boolean} forceRefresh - Force recalculation ignoring cache
     * @returns {number} Total value of all harvestable crops in garden
     */
    getGardenValue(forceRefresh = false) {
      return this.getCachedValue("gardenValue", forceRefresh, () => this.calculateGardenValue());
    }
    /**
     * Get cached value with throttling and retry mechanism
     *
     * @param {string} type - Type of value ('tileValue', 'inventoryValue', 'gardenValue')
     * @param {boolean} forceRefresh - Force recalculation
     * @param {Function} calculator - Function to calculate new value
     * @returns {number} Calculated or cached value
     * @private
     */
    getCachedValue(type, forceRefresh, calculator) {
      const cached = this.cache[type];
      const now = Date.now();
      if (!forceRefresh && cached && now - cached.lastUpdate < this.throttleMs) {
        return cached.value;
      }
      let attempts = 0;
      let value = 0;
      while (attempts < this.retryAttempts) {
        try {
          value = calculator();
          break;
        } catch (error) {
          attempts++;
          this.debugError("VALUE_MANAGER", `Calculation failed for ${type}, attempt ${attempts}`, error);
          if (attempts >= this.retryAttempts) {
            value = cached ? cached.value : 0;
            this.debugLog("VALUE_MANAGER", `Using cached value for ${type} after ${attempts} failures`);
          } else {
            const start = Date.now();
            while (Date.now() - start < 10 * attempts) {
            }
          }
        }
      }
      this.cache[type] = {
        value,
        lastUpdate: now
      };
      return value;
    }
    /**
     * Calculate value of current tile (crop being hovered)
     *
     * @returns {number} Total value of all slots in current tile
     * @private
     */
    calculateTileValue() {
      const currentCrop = this.UnifiedState.atoms.currentCrop;
      const friendBonus = this.UnifiedState.atoms.friendBonus || 1;
      let tileValue = 0;
      if (currentCrop && currentCrop.length) {
        currentCrop.forEach((slot) => {
          if (slot && slot.species) {
            const multiplier = calculateMutationMultiplier2(slot.mutations);
            const speciesVal = SPECIES_VALUES2[slot.species] || 0;
            const scale = slot.targetScale || 1;
            tileValue += Math.round(multiplier * speciesVal * scale * friendBonus);
          }
        });
      }
      return tileValue;
    }
    /**
     * Calculate total inventory value
     *
     * @returns {number} Total value of all produce items in inventory
     * @private
     */
    calculateInventoryValue() {
      const inventory = this.UnifiedState.atoms.inventory;
      const friendBonus = this.UnifiedState.atoms.friendBonus || 1;
      let inventoryValue = 0;
      if (inventory && inventory.items) {
        inventory.items.forEach((item) => {
          if (item.itemType === "Produce" && item.species) {
            const multiplier = calculateMutationMultiplier2(item.mutations);
            const speciesVal = SPECIES_VALUES2[item.species] || 0;
            const scale = item.scale || 1;
            inventoryValue += Math.round(multiplier * speciesVal * scale * friendBonus);
          }
        });
      }
      return inventoryValue;
    }
    /**
     * Calculate total garden value (ready-to-harvest crops only)
     *
     * @returns {number} Total value of all harvestable crops in garden
     * @private
     */
    calculateGardenValue() {
      const myGarden = this.UnifiedState.atoms.myGarden;
      const friendBonus = this.UnifiedState.atoms.friendBonus || 1;
      let gardenValue = 0;
      if (myGarden && myGarden.garden && myGarden.garden.tileObjects) {
        const now = Date.now();
        Object.values(myGarden.garden.tileObjects).forEach((tile) => {
          if (tile.objectType === "plant" && tile.slots) {
            tile.slots.forEach((slot) => {
              if (slot && slot.species && slot.endTime && now >= slot.endTime) {
                const multiplier = calculateMutationMultiplier2(slot.mutations);
                const speciesVal = SPECIES_VALUES2[slot.species] || 0;
                const scale = slot.targetScale || 1;
                gardenValue += Math.round(multiplier * speciesVal * scale * friendBonus);
              }
            });
          }
        });
      }
      return gardenValue;
    }
    /**
     * Update all values and store in UnifiedState
     *
     * Calculates tile, inventory, and garden values and updates UI
     *
     * @param {boolean} forceRefresh - Force recalculation ignoring cache
     * @returns {Object} Object with tileValue, inventoryValue, gardenValue
     */
    updateAllValues(forceRefresh = false) {
      const tileValue = this.getTileValue(forceRefresh);
      const inventoryValue = this.getInventoryValue(forceRefresh);
      const gardenValue = this.getGardenValue(forceRefresh);
      this.UnifiedState.data.tileValue = tileValue;
      this.UnifiedState.data.inventoryValue = inventoryValue;
      this.UnifiedState.data.gardenValue = gardenValue;
      this.updateValueDisplays();
      this.debugLog("VALUE_MANAGER", "All values updated", {
        tileValue,
        inventoryValue,
        gardenValue,
        cached: Object.keys(this.cache).map((k) => `${k}: ${Date.now() - this.cache[k].lastUpdate}ms ago`)
      });
      return { tileValue, inventoryValue, gardenValue };
    }
    /**
     * Update value displays in all UI contexts
     *
     * Updates main tab, overlays, and separate windows showing values
     *
     * @returns {void}
     */
    updateValueDisplays() {
      if (this.UnifiedState.activeTab === "values") {
        this.updateTabContent();
      }
      this.UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
        if (overlay && document.contains(overlay) && tabName === "values") {
          if (overlay.className.includes("mga-overlay-content-only")) {
            this.updatePureOverlayContent(overlay, tabName);
            this.debugLog("VALUE_MANAGER", "Updated pure values overlay");
          } else {
            const overlayContent = overlay.querySelector(".mga-overlay-content > div");
            if (overlayContent) {
              overlayContent.innerHTML = this.getValuesTabContent();
              this.debugLog("VALUE_MANAGER", "Updated legacy values overlay");
            }
          }
        }
      });
      this.UnifiedState.data.popouts.windows.forEach((windowRef, tabName) => {
        if (windowRef && !windowRef.closed && tabName === "values") {
          try {
            const freshContent = this.getValuesTabContent();
            const contentElement = windowRef.document.getElementById("content");
            if (contentElement) {
              contentElement.innerHTML = freshContent;
              if (window.resourceDashboard) {
                window.resourceDashboard.setupDashboardHandlers(windowRef.document);
              }
              this.debugLog("VALUE_MANAGER", "Updated values in separate window");
            }
          } catch (error) {
            this.debugError("VALUE_MANAGER", "Failed to update separate window", error);
          }
        }
      });
    }
    /**
     * Invalidate all cached values
     *
     * Forces next getValue calls to recalculate
     *
     * @returns {void}
     */
    invalidateCache() {
      Object.keys(this.cache).forEach((key) => {
        this.cache[key].lastUpdate = 0;
      });
    }
    /**
     * Get manager status and cache info
     *
     * @returns {Object} Status object with cache info, throttle, and retry settings
     */
    getStatus() {
      const now = Date.now();
      return {
        cache: Object.keys(this.cache).reduce((acc, key) => {
          const cached = this.cache[key];
          acc[key] = {
            value: cached.value,
            age: now - cached.lastUpdate,
            fresh: now - cached.lastUpdate < this.throttleMs
          };
          return acc;
        }, {}),
        throttleMs: this.throttleMs,
        retryAttempts: this.retryAttempts
      };
    }
    /**
     * Destroy the ValueManager and cleanup resources
     *
     * Disconnects MutationObserver and clears cache
     *
     * @returns {void}
     */
    destroy() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
    }
  };
  function initializeValueManager(dependencies) {
    if (!dependencies._globalValueManager) {
      dependencies._globalValueManager = new ValueManager(dependencies);
    }
    return dependencies._globalValueManager;
  }
  function updateValues(dependencies) {
    const valueManager = dependencies._globalValueManager || initializeValueManager(dependencies);
    valueManager.updateAllValues();
    if (dependencies.UnifiedState.activeTab === "values") {
      dependencies.updateTabContent();
    }
    dependencies.UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
      if (overlay && document.contains(overlay) && tabName === "values") {
        if (overlay.className.includes("mga-overlay-content-only")) {
          dependencies.updatePureOverlayContent(overlay, tabName);
        }
      }
    });
    dependencies.refreshSeparateWindowPopouts("values");
    dependencies.debugLog("VALUES_UPDATE", "Values updated and UI refreshed");
  }

  // src/features/timer-manager.js
  var timer_manager_exports = {};
  __export(timer_manager_exports, {
    TimerManager: () => TimerManager,
    getSecondsToNextLunarEvent: () => getSecondsToNextLunarEvent,
    initializeTimerManager: () => initializeTimerManager,
    refreshTimerElementCache: () => refreshTimerElementCache,
    updateTimerDisplay: () => updateTimerDisplay,
    updateTimers: () => updateTimers
  });
  var TimerManager = class {
    /**
     * Create a TimerManager instance
     *
     * @param {object} dependencies - Injected dependencies
     * @param {object} dependencies.UnifiedState - Unified state management object
     * @param {Function} dependencies.MGA_saveJSON - Storage save function
     * @param {Function} dependencies.MGA_loadJSON - Storage load function
     * @param {Function} dependencies.debugLog - Debug logging function
     * @param {Function} dependencies.debugError - Error logging function
     * @param {Window} dependencies.window - Window object for RAF
     */
    constructor(dependencies = {}) {
      const {
        UnifiedState: UnifiedState3,
        MGA_saveJSON: MGA_saveJSON2 = () => {
        },
        MGA_loadJSON: MGA_loadJSON2 = () => ({}),
        debugLog: debugLog3 = console.log.bind(console),
        debugError: debugError2 = console.error.bind(console),
        window: win = typeof window !== "undefined" ? window : null
      } = dependencies;
      this.UnifiedState = UnifiedState3;
      this.MGA_saveJSON = MGA_saveJSON2;
      this.MGA_loadJSON = MGA_loadJSON2;
      this.debugLog = debugLog3;
      this.debugError = debugError2;
      this.window = win;
      this.activeTimers = /* @__PURE__ */ new Map();
      this.isRunning = false;
      this.animationFrameId = null;
      this.lastHeartbeat = Date.now();
      this.heartbeatInterval = 1e3;
      this.frozenThreshold = 3e3;
      if (!this.UnifiedState.data.activeTimers) {
        this.UnifiedState.data.activeTimers = {};
      }
      this.loadPersistedTimers();
      this.startHeartbeat();
      this.debugLog("TIMER_MANAGER", "TimerManager initialized", {
        heartbeatInterval: this.heartbeatInterval,
        frozenThreshold: this.frozenThreshold
      });
    }
    /**
     * Start a new timer
     *
     * @param {string} id - Unique timer identifier
     * @param {Function} callback - Function to call on timer tick
     * @param {number} interval - Timer interval in milliseconds (default: 1000)
     * @returns {object} Timer object
     */
    startTimer(id, callback, interval = 1e3) {
      if (this.activeTimers.has(id)) {
        this.stopTimer(id);
      }
      const timer = {
        id,
        callback,
        interval,
        lastRun: Date.now(),
        running: true,
        frozen: false
      };
      this.activeTimers.set(id, timer);
      this.UnifiedState.data.activeTimers[id] = {
        interval,
        lastRun: timer.lastRun,
        running: true
      };
      this.saveTimerState();
      if (!this.isRunning) {
        this.startMainLoop();
      }
      this.debugLog("TIMER_MANAGER", `Timer started: ${id}`, { interval });
      return timer;
    }
    /**
     * Stop a timer by ID
     *
     * @param {string} id - Timer identifier
     */
    stopTimer(id) {
      if (this.activeTimers.has(id)) {
        this.activeTimers.delete(id);
        delete this.UnifiedState.data.activeTimers[id];
        this.saveTimerState();
        this.debugLog("TIMER_MANAGER", `Timer stopped: ${id}`);
      }
    }
    /**
     * Pause all active timers
     */
    pauseAll() {
      this.activeTimers.forEach((timer, id) => {
        const modifiedTimer = timer;
        modifiedTimer.running = false;
        this.UnifiedState.data.activeTimers[id].running = false;
      });
      this.saveTimerState();
      this.debugLog("TIMER_MANAGER", "All timers paused");
    }
    /**
     * Resume all paused timers
     */
    resumeAll() {
      this.activeTimers.forEach((timer, id) => {
        const modifiedTimer = timer;
        modifiedTimer.running = true;
        modifiedTimer.lastRun = Date.now();
        this.UnifiedState.data.activeTimers[id].running = true;
        this.UnifiedState.data.activeTimers[id].lastRun = modifiedTimer.lastRun;
      });
      this.saveTimerState();
      this.debugLog("TIMER_MANAGER", "All timers resumed");
    }
    /**
     * Start the RAF-based main loop
     */
    startMainLoop() {
      if (this.isRunning) return;
      this.isRunning = true;
      const loop = (currentTime) => {
        if (!this.isRunning || this.activeTimers.size === 0) {
          this.isRunning = false;
          this.animationFrameId = null;
          return;
        }
        this.processTimers(currentTime);
        this.animationFrameId = this.window.requestAnimationFrame(loop);
      };
      this.animationFrameId = this.window.requestAnimationFrame(loop);
      this.debugLog("TIMER_MANAGER", "Main loop started");
    }
    /**
     * Process all active timers
     *
     * @param {number} currentTime - Current timestamp from RAF
     */
    processTimers(currentTime) {
      this.activeTimers.forEach((timer, id) => {
        if (!timer.running) return;
        const elapsed = currentTime - timer.lastRun;
        if (elapsed >= timer.interval) {
          try {
            timer.callback();
            const modifiedTimer = timer;
            modifiedTimer.lastRun = currentTime;
            modifiedTimer.frozen = false;
            this.UnifiedState.data.activeTimers[id].lastRun = modifiedTimer.lastRun;
          } catch (error) {
            this.debugError("TIMER_MANAGER", `Timer callback error for ${id}`, error);
          }
        }
      });
    }
    /**
     * Start heartbeat monitoring for frozen timer detection
     */
    startHeartbeat() {
      const heartbeat = () => {
        const now = Date.now();
        const timeSinceLastBeat = now - this.lastHeartbeat;
        if (this.isRunning && timeSinceLastBeat > this.frozenThreshold) {
          this.debugLog("TIMER_MANAGER", "Heartbeat detected frozen timers, restarting main loop", {
            timeSinceLastBeat
          });
          this.restartMainLoop();
        }
        this.checkForFrozenTimers(now);
        this.lastHeartbeat = now;
        setTimeout(heartbeat, this.heartbeatInterval);
      };
      setTimeout(heartbeat, this.heartbeatInterval);
      this.debugLog("TIMER_MANAGER", "Heartbeat monitor started");
    }
    /**
     * Check for frozen timers
     *
     * @param {number} now - Current timestamp
     */
    checkForFrozenTimers(now) {
      this.activeTimers.forEach((timer, id) => {
        if (!timer.running) return;
        const timeSinceLastRun = now - timer.lastRun;
        const expectedRuns = Math.floor(timeSinceLastRun / timer.interval);
        if (expectedRuns > 2 && !timer.frozen) {
          this.debugLog("TIMER_MANAGER", `Timer appears frozen: ${id}`, {
            timeSinceLastRun,
            expectedRuns,
            interval: timer.interval
          });
          const modifiedTimer = timer;
          modifiedTimer.frozen = true;
          this.restartTimer(id);
        }
      });
    }
    /**
     * Restart a frozen timer
     *
     * @param {string} id - Timer identifier
     */
    restartTimer(id) {
      const timer = this.activeTimers.get(id);
      if (timer) {
        timer.lastRun = Date.now();
        timer.frozen = false;
        this.debugLog("TIMER_MANAGER", `Timer restarted: ${id}`);
      }
    }
    /**
     * Restart the main loop
     */
    restartMainLoop() {
      if (this.animationFrameId) {
        this.window.cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      this.isRunning = false;
      setTimeout(() => this.startMainLoop(), 100);
    }
    /**
     * Save timer state to storage
     */
    saveTimerState() {
      try {
        this.MGA_saveJSON("MGA_timerStates", this.UnifiedState.data.activeTimers);
      } catch (error) {
        this.debugError("TIMER_MANAGER", "Failed to save timer state", error);
      }
    }
    /**
     * Load persisted timers from storage
     */
    loadPersistedTimers() {
      try {
        const saved = this.MGA_loadJSON("MGA_timerStates", {});
        this.UnifiedState.data.activeTimers = { ...saved };
        this.debugLog("TIMER_MANAGER", "Loaded persisted timer states", {
          count: Object.keys(saved).length
        });
      } catch (error) {
        this.debugError("TIMER_MANAGER", "Failed to load persisted timers", error);
      }
    }
    /**
     * Get current timer manager status
     *
     * @returns {object} Status object with timer counts and state
     */
    getStatus() {
      return {
        isRunning: this.isRunning,
        activeCount: this.activeTimers.size,
        frozenCount: Array.from(this.activeTimers.values()).filter((t) => t.frozen).length,
        lastHeartbeat: this.lastHeartbeat
      };
    }
    /**
     * Destroy timer manager and cleanup
     */
    destroy() {
      this.activeTimers.forEach((timer, id) => {
        this.stopTimer(id);
      });
      if (this.animationFrameId) {
        this.window.cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      this.isRunning = false;
      this.activeTimers.clear();
    }
  };
  function initializeTimerManager(dependencies = {}) {
    const timerManager = new TimerManager(dependencies);
    return timerManager;
  }
  function updateTimers(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3,
      getSecondsToNextLunarEvent: getSecondsToNextLunarEvent2 = () => ({ secondsLeft: null }),
      updateTimerDisplay: updateTimerDisplay2 = () => {
      }
    } = dependencies;
    const quinoaData = UnifiedState3.atoms.quinoaData;
    if (quinoaData && quinoaData.shops) {
      UnifiedState3.data.timers.seed = quinoaData.shops.seed && quinoaData.shops.seed.secondsUntilRestock || null;
      UnifiedState3.data.timers.egg = quinoaData.shops.egg && quinoaData.shops.egg.secondsUntilRestock || null;
      UnifiedState3.data.timers.tool = quinoaData.shops.tool && quinoaData.shops.tool.secondsUntilRestock || null;
    }
    const lunarResult = getSecondsToNextLunarEvent2();
    UnifiedState3.data.timers.lunar = lunarResult.secondsLeft;
    updateTimerDisplay2();
  }
  function getSecondsToNextLunarEvent() {
    const eventZone = "America/Chicago";
    const lunarHours = [3, 7, 11, 15, 19, 23];
    const now = /* @__PURE__ */ new Date();
    const centralTime = new Date(now.toLocaleString("en-US", { timeZone: eventZone }));
    const currentHour = centralTime.getHours();
    const currentMin = centralTime.getMinutes();
    const currentSec = centralTime.getSeconds();
    let nextEventHour = null;
    for (let i = 0; i < lunarHours.length; i += 1) {
      const eventHour = lunarHours[i];
      if (eventHour > currentHour || eventHour === currentHour && currentMin === 0 && currentSec === 0) {
        nextEventHour = eventHour;
        break;
      }
    }
    if (nextEventHour === null) {
      nextEventHour = lunarHours[0];
    }
    const nextEvent = new Date(centralTime);
    nextEvent.setHours(nextEventHour, 0, 0, 0);
    if (nextEvent <= centralTime) {
      nextEvent.setDate(nextEvent.getDate() + 1);
    }
    const secondsLeft = Math.max(0, Math.floor((nextEvent.getTime() - centralTime.getTime()) / 1e3));
    return {
      secondsLeft,
      // Precise calculation without manual adjustment
      eventDateLocal: nextEvent
    };
  }
  function refreshTimerElementCache(dependencies = {}) {
    const {
      cachedTimerElements,
      UnifiedState: UnifiedState3,
      document: doc = typeof document !== "undefined" ? document : null,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null
    } = dependencies;
    const timerIds = ["timer-seed", "timer-egg", "timer-tool", "timer-lunar"];
    timerIds.forEach((id) => {
      const elements = [];
      const mainEl = doc.getElementById(id);
      if (mainEl) elements.push(mainEl);
      UnifiedState3.data.popouts.overlays.forEach((overlay) => {
        if (overlay && doc.contains(overlay)) {
          const overlayEl = overlay.querySelector(`#${id}`);
          if (overlayEl) elements.push(overlayEl);
        }
      });
      try {
        const targetEls = targetDocument2.querySelectorAll(`#${id}`);
        targetEls.forEach((el2) => {
          if (!elements.includes(el2)) elements.push(el2);
        });
      } catch (e) {
      }
      cachedTimerElements[id] = elements;
    });
  }
  function updateTimerDisplay(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3,
      cachedTimerElements,
      lastTimerElementCacheTime = 0,
      TIMER_ELEMENT_CACHE_DURATION = 5e3,
      document: doc = typeof document !== "undefined" ? document : null,
      refreshTimerElementCache: refreshCacheFn = () => {
      }
    } = dependencies;
    const formatTime = (seconds) => {
      if (seconds == null) return "--:--";
      const s = Math.max(0, Math.floor(seconds));
      const m = Math.floor(s / 60);
      const ss = s % 60;
      return `${m}:${String(ss).padStart(2, "0")}`;
    };
    const formatTimeHoursMinutes = (seconds) => {
      if (seconds == null) return "--:--";
      const totalMinutes = Math.floor(seconds / 60);
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      return `${minutes}m`;
    };
    const now = Date.now();
    let newCacheTime = lastTimerElementCacheTime;
    if (lastTimerElementCacheTime === 0 || now - lastTimerElementCacheTime > TIMER_ELEMENT_CACHE_DURATION) {
      refreshCacheFn();
      newCacheTime = now;
    }
    const updateTimerElement = (id, value) => {
      const formatter = id === "timer-lunar" ? formatTimeHoursMinutes : formatTime;
      const formattedValue = formatter(value);
      const elements = cachedTimerElements[id] || [];
      if (elements.length === 0) {
        const el2 = doc.getElementById(id);
        if (el2) {
          el2.textContent = formattedValue;
        }
        return;
      }
      elements.forEach((el2) => {
        if (doc.contains(el2)) {
          el2.textContent = formattedValue;
        }
      });
    };
    updateTimerElement("timer-seed", UnifiedState3.data.timers.seed);
    updateTimerElement("timer-egg", UnifiedState3.data.timers.egg);
    updateTimerElement("timer-tool", UnifiedState3.data.timers.tool);
    updateTimerElement("timer-lunar", UnifiedState3.data.timers.lunar);
    return newCacheTime;
  }

  // src/features/turtle-timer.js
  var turtle_timer_exports = {};
  __export(turtle_timer_exports, {
    calculateCurrentSlotValue: () => calculateCurrentSlotValue2,
    estimateUntilLatestCrop: () => estimateUntilLatestCrop2,
    getAbilityExpectations: () => getAbilityExpectations2,
    getCropHash: () => getCropHash2,
    getCurrentSlotIndex: () => getCurrentSlotIndex2,
    getEggExpectations: () => getEggExpectations2,
    getGrowthExpectations: () => getGrowthExpectations2,
    getTurtleExpectations: () => getTurtleExpectations2,
    initializeTurtleTimer: () => initializeTurtleTimer2,
    insertTurtleEstimate: () => insertTurtleEstimate2,
    isValidTooltipElement: () => isValidTooltipElement2
  });
  function getCropHash2(crop) {
    try {
      return JSON.stringify(crop);
    } catch (e) {
      return `__ref_changed__${Date.now()}`;
    }
  }
  function getTurtleExpectations2(activePets, dependencies = {}) {
    const { UnifiedState: UnifiedState3, logDebug: logDebug2 = console.log.bind(console) } = dependencies;
    if (UnifiedState3?.data?.settings?.debugMode) {
      logDebug2("TURTLE", "Checking active pets:", {
        petsCount: activePets?.length || 0,
        pets: (activePets || []).map((p) => ({
          species: p?.petSpecies,
          hunger: p?.hunger,
          abilities: p?.abilities
        }))
      });
    }
    const turtles = (activePets || []).filter(
      (p) => p && p.petSpecies === "Turtle" && p.hunger > 0 && p.abilities?.some(
        (a) => a === "Plant Growth Boost II" || a === "PlantGrowthBoostII" || a === "Plant Growth Boost 2" || typeof a === "string" && a.toLowerCase().includes("plant") && a.toLowerCase().includes("growth") && (a.includes("II") || a.includes("2"))
      )
    );
    if (UnifiedState3?.data?.settings?.debugMode) {
      logDebug2("TURTLE", "Filtered turtles:", {
        turtleCount: turtles.length,
        turtles: turtles.map((t) => ({
          species: t.petSpecies,
          hunger: t.hunger,
          abilities: t.abilities,
          xp: t.xp,
          targetScale: t.targetScale
        }))
      });
    }
    let expectedMinutesRemoved = 0;
    turtles.forEach((p) => {
      const xpComponent = Math.min(Math.floor((p.xp || 0) / (100 * 3600) * 30), 30);
      const scaleComponent = Math.floor(((p.targetScale || 1) - 1) / (2.5 - 1) * 20 + 80) - 30;
      const base = xpComponent + scaleComponent;
      const minutesRemoved = base / 100 * 5 * 60 * (1 - (1 - 0.27 * base / 100) ** (1 / 60));
      if (UnifiedState3?.data?.settings?.debugMode) {
        logDebug2("TURTLE", "Turtle calculation:", {
          xp: p.xp,
          targetScale: p.targetScale,
          xpComponent,
          scaleComponent,
          base,
          minutesRemoved
        });
      }
      expectedMinutesRemoved += minutesRemoved;
    });
    if (UnifiedState3?.data?.settings?.debugMode) {
      logDebug2("TURTLE", "Total expected minutes removed:", expectedMinutesRemoved);
    }
    return {
      expectedMinutesRemoved
    };
  }
  function estimateUntilLatestCrop2(currentCrop, activePets, slotIndex = null, dependencies = {}) {
    const { getTurtleExpectations: getTurtleExp = getTurtleExpectations2, logError: logError2 = console.error.bind(console) } = dependencies;
    try {
      if (!currentCrop || currentCrop.length === 0) return null;
      if (!activePets || activePets.length === 0) return null;
      const turtleExpectations = getTurtleExp(activePets, dependencies);
      if (!turtleExpectations || turtleExpectations.expectedMinutesRemoved === 0) {
        return null;
      }
      const now = Date.now();
      let targetEndTime;
      if (slotIndex !== null && slotIndex >= 0 && slotIndex < currentCrop.length) {
        targetEndTime = currentCrop[slotIndex]?.endTime || 0;
      } else {
        targetEndTime = Math.max(...currentCrop.map((c) => c.endTime || 0));
      }
      if (targetEndTime <= now) return null;
      const remainingRealMinutes = (targetEndTime - now) / (1e3 * 60);
      const { expectedMinutesRemoved } = turtleExpectations;
      const effectiveRate = expectedMinutesRemoved + 1;
      const expectedRealMinutes = remainingRealMinutes / effectiveRate;
      const hours = Math.floor(expectedRealMinutes / 60);
      const minutes = Math.floor(expectedRealMinutes % 60);
      return `${hours}h ${minutes}m`;
    } catch (error) {
      logError2("TURTLE", "ERROR in estimateUntilLatestCrop:", error);
      return null;
    }
  }
  function getAbilityExpectations2(activePets, abilityName, minutesPerBase = 5, odds = 0.27) {
    const pets = (activePets || []).filter((p) => p && p.hunger > 0 && p.abilities?.some((a) => a === abilityName));
    let expectedMinutesRemoved = 0;
    pets.forEach((p) => {
      const base = Math.min(Math.floor((p.xp || 0) / (100 * 3600) * 30), 30) + Math.floor(((p.targetScale || 1) - 1) / (2.5 - 1) * 20 + 80) - 30;
      expectedMinutesRemoved += base / 100 * minutesPerBase * 60 * (1 - (1 - odds * base / 100) ** (1 / 60));
    });
    return {
      expectedMinutesRemoved
    };
  }
  function getEggExpectations2(activePets) {
    return getAbilityExpectations2(activePets, "EggGrowthBoostII", 10, 0.24);
  }
  function getGrowthExpectations2(activePets) {
    return getAbilityExpectations2(activePets, "PlantGrowthBoostII", 5, 0.27);
  }
  function isValidTooltipElement2(element, dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      document: doc = typeof document !== "undefined" ? document : null,
      window: win = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3
    } = dependencies;
    if (!element) return false;
    try {
      const rect = element.getBoundingClientRect();
      if (rect.top < 50 && rect.left < 50) {
        return false;
      }
      if (rect.width < 50 || rect.height < 30) {
        return false;
      }
      const viewportDoc = targetDocument2 || doc;
      const viewportWidth = win.innerWidth || viewportDoc.documentElement.clientWidth;
      const viewportHeight = win.innerHeight || viewportDoc.documentElement.clientHeight;
      if (rect.right < 0 || rect.bottom < 0 || rect.left > viewportWidth || rect.top > viewportHeight) {
        return false;
      }
      const hasText = element.textContent && element.textContent.trim().length > 0;
      if (!hasText) {
        return false;
      }
      return true;
    } catch (e) {
      if (UnifiedState3?.data?.settings?.debugMode) {
        console.error("[CROP-VALUE] \u274C Error validating tooltip element:", e);
      }
      return false;
    }
  }
  function getCurrentSlotIndex2(currentCrop, dependencies = {}) {
    const { window: win = typeof window !== "undefined" ? window : null } = dependencies;
    if (!currentCrop || currentCrop.length <= 1) return 0;
    if (typeof win._mgtools_currentSlotIndex === "undefined") {
      win._mgtools_currentSlotIndex = 0;
    }
    return win._mgtools_currentSlotIndex || 0;
  }
  function calculateCurrentSlotValue2(currentCrop, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3,
      window: win = typeof window !== "undefined" ? window : null,
      calculateMutationMultiplier: calculateMutationMultiplier3 = () => 1,
      speciesValues = {},
      getCurrentSlotIndex: getSlotIdx = getCurrentSlotIndex2
    } = dependencies;
    if (!currentCrop || currentCrop.length === 0) return 0;
    const friendBonus = UnifiedState3.atoms.friendBonus || 1;
    const slotIndex = getSlotIdx(currentCrop, dependencies);
    const sortedIndices = UnifiedState3.atoms.sortedSlotIndices || win.sortedSlotIndices;
    let actualSlotIndex = slotIndex;
    if (sortedIndices && Array.isArray(sortedIndices) && sortedIndices.length > 0) {
      if (slotIndex < sortedIndices.length) {
        actualSlotIndex = sortedIndices[slotIndex];
        console.log(`\u{1F504} [CROP-VALUE] Using sorted index: position ${slotIndex} \u2192 actual slot ${actualSlotIndex}`);
      }
    }
    console.log(`\u{1F4CA} [CROP-VALUE] Calculating value for slot ${actualSlotIndex}/${currentCrop.length}`, {
      displayIndex: slotIndex,
      actualSlotIndex,
      cropCount: currentCrop.length,
      windowIndex: win._mgtools_currentSlotIndex,
      sortedIndices
    });
    if (actualSlotIndex < 0 || actualSlotIndex >= currentCrop.length) {
      console.error(`[CROP-VALUE] Invalid slot index: ${actualSlotIndex} for crop array length: ${currentCrop.length}`);
      win._mgtools_currentSlotIndex = 0;
      return 0;
    }
    const slot = currentCrop[actualSlotIndex];
    if (!slot || !slot.species) {
      console.log(`[CROP-VALUE] No species at slot ${actualSlotIndex}`, slot);
      return 0;
    }
    const multiplier = calculateMutationMultiplier3(slot.mutations);
    const speciesVal = speciesValues[slot.species] || 0;
    const scale = slot.targetScale || 1;
    const value = Math.round(multiplier * speciesVal * scale * friendBonus);
    console.log(
      `\u{1F4B0} [CROP-VALUE] Slot ${actualSlotIndex}/${currentCrop.length}: ${slot.species} = ${value.toLocaleString()}`,
      {
        species: slot.species,
        speciesVal,
        multiplier,
        scale,
        friendBonus,
        value
      }
    );
    return value;
  }
  function insertTurtleEstimate2(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3,
      isValidTooltipElement: isValidTooltip = isValidTooltipElement2,
      getEggExpectations: getEggExp = getEggExpectations2,
      estimateUntilLatestCrop: estimateUntil = estimateUntilLatestCrop2,
      getCurrentSlotIndex: getSlotIdx = getCurrentSlotIndex2,
      calculateCurrentSlotValue: calcSlotValue = calculateCurrentSlotValue2
    } = dependencies;
    const doc = targetDocument2;
    doc.querySelectorAll('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]').forEach((el2) => el2.remove());
    let currentPlantTooltipFlexbox = doc.querySelector(
      "div.QuinoaUI > div.McFlex:nth-of-type(2) > div.McGrid > div.McFlex:nth-of-type(3) > :first-child > :last-child p"
    )?.parentElement;
    if (!currentPlantTooltipFlexbox) {
      const altSelectors = [
        "div.QuinoaUI .McFlex .McGrid",
        '[class*="tooltip"] [class*="flex"]',
        'div[class*="plant"] div[class*="info"]',
        ".McFlex .McGrid .McFlex",
        "div.QuinoaUI div.McFlex div.McGrid"
      ];
      for (let i = 0; i < altSelectors.length; i += 1) {
        const sel = altSelectors[i];
        const el2 = doc.querySelector(sel);
        if (el2 && isValidTooltip(el2, dependencies)) {
          currentPlantTooltipFlexbox = el2;
          break;
        }
      }
      if (!currentPlantTooltipFlexbox) {
        return;
      }
    }
    if (!isValidTooltip(currentPlantTooltipFlexbox, dependencies)) {
      console.warn("[CROP-VALUE] \u26A0\uFE0F Rejected invalid tooltip position - skipping slot value display");
      return;
    }
    let currentCrop = targetWindow3.currentCrop || UnifiedState3.atoms.currentCrop;
    const currentEgg = targetWindow3.currentEgg || UnifiedState3.atoms.currentEgg;
    if (!currentCrop && !currentEgg) {
      const possibleLocations = [
        targetWindow3.gameState?.currentCrop,
        targetWindow3.gameState?.currentEgg,
        targetWindow3.UnifiedState?.atoms?.currentCrop,
        targetWindow3.garden?.currentTile?.crop,
        targetWindow3.playerState?.standingOn?.crop,
        targetWindow3.jotaiAtomCache?.get?.(
          "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom"
        )?.debugValue
      ];
      for (let i = 0; i < possibleLocations.length; i += 1) {
        const loc = possibleLocations[i];
        if (loc) {
          currentCrop = Array.isArray(loc) ? loc : [loc];
          break;
        }
      }
      if (!currentCrop && !currentEgg && currentPlantTooltipFlexbox) {
        const tooltipText = currentPlantTooltipFlexbox.textContent || "";
        const eggPattern = /(Common|Uncommon|Rare|Legendary|Mythical)\s*Egg/i;
        const eggMatch = tooltipText.match(eggPattern);
        if (eggMatch) {
          const eggSpecies = eggMatch[0].replace(/\s+/g, "");
          currentCrop = [{ species: eggSpecies, type: "egg", category: "egg", isEgg: true }];
        } else {
          const cropPatterns = [
            /Carrot/i,
            /Wheat/i,
            /Corn/i,
            /Tomato/i,
            /Potato/i,
            /Pumpkin/i,
            /Watermelon/i,
            /Strawberry/i,
            /Blueberry/i,
            /Rose/i,
            /Tulip/i,
            /Sunflower/i,
            /Daisy/i,
            /Lily/i
          ];
          for (let i = 0; i < cropPatterns.length; i += 1) {
            const pattern = cropPatterns[i];
            const cropMatch = tooltipText.match(pattern);
            if (cropMatch) {
              currentCrop = [{ species: cropMatch[0], type: "crop", category: "plant" }];
              break;
            }
          }
        }
      }
    }
    const isPlantedEgg1 = currentCrop?.[0]?.species?.endsWith("Egg");
    const isPlantedEgg2 = currentCrop?.[0]?.species?.includes("Egg");
    const isPlantedEgg3 = currentCrop?.[0]?.type === "egg";
    const isPlantedEgg4 = currentCrop?.[0]?.category === "egg";
    const isPlantedEgg = isPlantedEgg1 || isPlantedEgg2 || isPlantedEgg3 || isPlantedEgg4;
    const isEgg = currentEgg || isPlantedEgg;
    if (isEgg) {
      const activePets = targetWindow3.activePets || UnifiedState3.atoms.activePets;
      const eggExpectations = getEggExp(activePets);
      const timeElement2 = [...currentPlantTooltipFlexbox.childNodes].find(
        (el2) => /^\d+h(?: \d+m)?(?: \d+s)?$|^\d+m(?: \d+s)?$|^\d+s$/.test((el2.textContent || "").trim())
      );
      if (!timeElement2) return;
      const timeText = timeElement2.textContent.trim();
      const timeMatch = timeText.match(/(?:(\d+)h)?\s*(?:(\d+)m)?\s*(?:(\d+)s)?/);
      if (!timeMatch) return;
      const hours = parseInt(timeMatch[1] || "0", 10);
      const minutes = parseInt(timeMatch[2] || "0", 10);
      const seconds = parseInt(timeMatch[3] || "0", 10);
      const totalSeconds = hours * 3600 + minutes * 60 + seconds;
      if (totalSeconds <= 0) return;
      if (eggExpectations && eggExpectations.expectedMinutesRemoved > 0) {
        const remainingRealMinutes = totalSeconds / 60;
        const effectiveRate = eggExpectations.expectedMinutesRemoved + 1;
        const boostedRealMinutes = remainingRealMinutes / effectiveRate;
        const boostedTotalSeconds = boostedRealMinutes * 60;
        const boostedHours = Math.floor(boostedTotalSeconds / 3600);
        const boostedMinutes = Math.floor(boostedTotalSeconds % 3600 / 60);
        const boostedSeconds = Math.floor(boostedTotalSeconds % 60);
        const eggEstimateEl = doc.createElement("p");
        eggEstimateEl.dataset.turtletimerEstimate = "true";
        if (boostedHours > 0) {
          eggEstimateEl.textContent = `\u{1F95A} Egg: ${boostedHours}h ${boostedMinutes}m`;
        } else {
          eggEstimateEl.textContent = `\u{1F95A} Egg: ${boostedMinutes}m ${boostedSeconds}s`;
        }
        eggEstimateEl.style.color = "#fbbf24";
        currentPlantTooltipFlexbox.appendChild(eggEstimateEl);
      }
      return;
    }
    if (!currentCrop || currentCrop.length === 0) return;
    const timeElement = [...currentPlantTooltipFlexbox.childNodes].find(
      (el2) => /^\d+h(?: \d+m)?(?: \d+s)?$|^\d+m(?: \d+s)?$|^\d+s$/.test((el2.textContent || "").trim())
    );
    if (timeElement) {
      const activePets = targetWindow3.activePets || UnifiedState3.atoms.activePets;
      const slotIndex = getSlotIdx(currentCrop, dependencies);
      const sortedIndices = UnifiedState3.atoms.sortedSlotIndices || targetWindow3.sortedSlotIndices;
      let actualSlotIndex = slotIndex;
      if (sortedIndices && Array.isArray(sortedIndices) && sortedIndices.length > 0 && slotIndex < sortedIndices.length) {
        actualSlotIndex = sortedIndices[slotIndex];
      }
      const estimate = estimateUntil(currentCrop, activePets, actualSlotIndex, dependencies);
      if (estimate) {
        const estimateEl = doc.createElement("p");
        estimateEl.dataset.turtletimerEstimate = "true";
        estimateEl.textContent = estimate;
        estimateEl.style.color = "#4ade80";
        currentPlantTooltipFlexbox.appendChild(estimateEl);
      }
    }
    const slotValue = calcSlotValue(currentCrop, dependencies);
    if (slotValue > 0) {
      const slotValueEl = doc.createElement("p");
      slotValueEl.dataset.turtletimerSlotValue = "true";
      slotValueEl.innerHTML = `<img src="https://cdn.discordapp.com/emojis/1425389207525920808.webp?size=96" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 2px; display: inline-block;">` + Number(slotValue).toLocaleString();
      currentPlantTooltipFlexbox.appendChild(slotValueEl);
    }
  }
  function initializeTurtleTimer2(dependencies = {}) {
    const {
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      window: win = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3,
      productionLog: productionLog3 = console.log.bind(console),
      hookAtom: hookAtom3 = () => {
      },
      listenToSlotIndexAtom: listenToSlotIndexAtom3 = () => {
      },
      getCropHash: getHash = getCropHash2,
      insertTurtleEstimate: insertEstimate = insertTurtleEstimate2,
      requestAnimationFrame: raf = typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : setTimeout
    } = dependencies;
    console.log("\u{1F422}\u{1F422}\u{1F422} [TURTLE-TIMER-START] initializeTurtleTimer() called!");
    productionLog3("\u{1F422} [TURTLE-TIMER] Initializing crop growth estimate...");
    if (typeof win._mgtools_currentSlotIndex === "undefined") {
      win._mgtools_currentSlotIndex = 0;
    }
    listenToSlotIndexAtom3();
    hookAtom3(
      "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentSortedGrowSlotIndicesAtom",
      "sortedSlotIndices",
      (value) => value
    );
    hookAtom3(
      "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom",
      "currentCrop",
      (value) => {
        let cropData = null;
        if (value?.garden?.tileObjects) {
          cropData = value.garden.tileObjects;
        } else if (Array.isArray(value)) {
          cropData = value;
        }
        UnifiedState3.atoms.currentCrop = cropData;
        targetWindow3.currentCrop = cropData;
        const currentHash = getHash(cropData || value);
        if (currentHash !== win.prevCropHash) {
          win.prevCropHash = currentHash;
          raf(() => insertEstimate(dependencies));
        }
        return value;
      }
    );
    const doc = targetDocument2;
    setInterval(() => {
      let currentCrop = targetWindow3.currentCrop || UnifiedState3.atoms.currentCrop;
      const currentEgg = targetWindow3.currentEgg || UnifiedState3.atoms.currentEgg;
      let manualCrop = null;
      if (!currentCrop) {
        if (!targetWindow3.__foundJotaiStore) {
          const possibleStores = [
            targetWindow3.jotaiStore,
            targetWindow3.__JOTAI_STORE__,
            targetWindow3.store,
            targetWindow3.getDefaultStore?.(),
            targetWindow3.globalStore,
            targetWindow3.__jotaiStore,
            targetWindow3._jotaiStore
          ];
          for (let i = 0; i < possibleStores.length; i += 1) {
            const store = possibleStores[i];
            if (store && typeof store.get === "function" && store !== targetWindow3.cookieStore && store !== win.cookieStore && (typeof store.set === "function" || typeof store.sub === "function")) {
              targetWindow3.__foundJotaiStore = store;
              break;
            }
          }
          if (!targetWindow3.__foundJotaiStore) {
            const storeKeys = Object.keys(targetWindow3).filter(
              (k) => k.toLowerCase().includes("store") || k.toLowerCase().includes("jotai")
            );
            for (let i = 0; i < storeKeys.length; i += 1) {
              const key = storeKeys[i];
              const val = targetWindow3[key];
              if (val && typeof val === "object" && typeof val.get === "function" && val !== targetWindow3.cookieStore && val !== win.cookieStore && (typeof val.set === "function" || typeof val.sub === "function")) {
                targetWindow3.__foundJotaiStore = val;
                break;
              }
            }
            if (!targetWindow3.__foundJotaiStore && targetWindow3.jotaiAtomCache) {
              const cache = targetWindow3.jotaiAtomCache;
              if (cache.store) {
                targetWindow3.__foundJotaiStore = cache.store;
              } else if (cache.cache && cache.cache.store) {
                targetWindow3.__foundJotaiStore = cache.cache.store;
              }
            }
          }
        }
        const atomCache = targetWindow3.jotaiAtomCache?.cache || targetWindow3.jotaiAtomCache;
        if (atomCache && atomCache.get) {
          const cropAtom = atomCache.get(
            "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom"
          );
          if (cropAtom) {
            if (targetWindow3.__foundJotaiStore) {
              try {
                const cropValue = targetWindow3.__foundJotaiStore.get(cropAtom);
                if (cropValue && typeof cropValue.then === "function") {
                  cropValue.then((val) => {
                    targetWindow3.currentCrop = val;
                    UnifiedState3.atoms.currentCrop = val;
                    if (val && !doc.querySelector('[data-turtletimer-estimate="true"]')) {
                      insertEstimate(dependencies);
                    }
                  }).catch(() => {
                  });
                } else {
                  manualCrop = cropValue;
                  targetWindow3.currentCrop = cropValue;
                  UnifiedState3.atoms.currentCrop = cropValue;
                }
              } catch (e) {
              }
            }
            if (!manualCrop && cropAtom.debugValue !== void 0) {
              manualCrop = cropAtom.debugValue;
            }
            if (!manualCrop && typeof cropAtom.read === "function") {
              try {
                const mockGetter = (a) => {
                  if (a === cropAtom && cropAtom.init !== void 0) {
                    return cropAtom.init;
                  }
                  return void 0;
                };
                const directValue = cropAtom.read(mockGetter);
                if (directValue && typeof directValue.then !== "function") {
                  manualCrop = directValue;
                }
              } catch (e) {
              }
            }
          }
        }
      }
      if (manualCrop && !currentCrop) {
        currentCrop = manualCrop;
      }
      const tooltipVisible = doc.querySelector("div.QuinoaUI > div.McFlex:nth-of-type(2) > div.McGrid");
      if (currentCrop || currentEgg || tooltipVisible) {
        const hasExisting = doc.querySelector('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]');
        if (!hasExisting) {
          insertEstimate(dependencies);
        }
      }
    }, 1e3);
    const isMovementKeypress = (e) => !e.ctrlKey && !e.shiftKey && ["KeyW", "KeyA", "KeyS", "KeyD", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.code);
    const onMovementKey = (handler) => (e) => {
      if (isMovementKeypress(e)) handler(e);
    };
    doc.addEventListener(
      "keydown",
      onMovementKey(() => {
        doc.querySelectorAll('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]').forEach((el2) => el2.remove());
      })
    );
    doc.addEventListener(
      "keyup",
      onMovementKey(() => {
        insertEstimate(dependencies);
      })
    );
    productionLog3("\u2705 [TURTLE-TIMER] Turtle timer initialized successfully");
    const debugCropDetectionFunc = function debugCropDetection() {
      console.log("=== MANUAL CROP DETECTION DEBUG ===");
      const atomCache = win.jotaiAtomCache?.cache || win.jotaiAtomCache;
      console.log("atomCache exists:", !!atomCache);
      if (atomCache && atomCache.get) {
        console.log("Atom cache entries count:", atomCache.size || "unknown");
        try {
          const allKeys = Array.from(atomCache.keys ? atomCache.keys() : []);
          console.log("Total atoms:", allKeys.length);
          const cropAtoms = allKeys.filter(
            (k) => k.includes("Crop") || k.includes("crop") || k.includes("Grow") || k.includes("Egg")
          );
          console.log("Crop-related atoms:", cropAtoms);
          const atom = atomCache.get(
            "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom"
          );
          console.log("Current crop atom:", atom);
          if (atom) {
            console.log("Atom properties:", Object.keys(atom));
            console.log("Atom.debugValue:", atom.debugValue);
            console.log("Atom.init:", atom.init);
            const tw = win;
            if (tw.__foundJotaiStore) {
              console.log("Found store, trying to read...");
              try {
                const val = tw.__foundJotaiStore.get(atom);
                console.log("\u2705 Store.get(atom) returned:", val);
              } catch (e) {
                console.log("\u274C Error reading from store:", e);
              }
            } else {
              console.log("\u26A0\uFE0F No Jotai store found yet");
            }
          }
        } catch (e) {
          console.log("Error exploring atoms:", e);
        }
      }
      console.log("Calling insertTurtleEstimate()...");
      if (typeof insertEstimate === "function") {
        insertEstimate(dependencies);
      } else {
        console.log("\u274C insertTurtleEstimate not available in this context");
      }
    };
    try {
      win.debugCropDetection = debugCropDetectionFunc;
      targetWindow3.debugCropDetection = debugCropDetectionFunc;
      console.log("\u{1F4A1} TIP: Run window.debugCropDetection() in console to debug crop detection");
      console.log("\u{1F4A1} Available in: window, targetWindow");
    } catch (e) {
      console.log("\u26A0\uFE0F Could not attach debugCropDetection:", e);
    }
  }

  // src/features/room-manager.js
  var room_manager_exports = {};
  __export(room_manager_exports, {
    DEFAULT_ROOMS: () => DEFAULT_ROOMS,
    DISCORD_PLAY_ROOMS: () => DISCORD_PLAY_ROOMS,
    FIREBASE_CONFIG: () => FIREBASE_CONFIG,
    REPORT_INTERVAL: () => REPORT_INTERVAL,
    buildRoomApiUrl: () => buildRoomApiUrl,
    createRoomRegistry: () => createRoomRegistry,
    getActualPlayerCount: () => getActualPlayerCount,
    getCurrentRoomCode: () => getCurrentRoomCode,
    getReporterId: () => getReporterId,
    initializeFirebase: () => initializeFirebase,
    isDiscordEnvironment: () => isDiscordEnvironment,
    requestRoomEndpoint: () => requestRoomEndpoint
  });
  var FIREBASE_CONFIG = {
    apiKey: "AIzaSyBfFW74PLBfLIpYj5dakmKar2wRpLu1ZOA",
    authDomain: "mg-rooms.firebaseapp.com",
    databaseURL: "https://mg-rooms-default-rtdb.firebaseio.com",
    projectId: "mg-rooms",
    storageBucket: "mg-rooms.firebasestorage.app",
    messagingSenderId: "175773159635",
    appId: "1:175773159635:web:6676c5a625c3fe1da74426"
  };
  var REPORT_INTERVAL = 5e3;
  var DEFAULT_ROOMS = [
    "MG1",
    "MG2",
    "MG3",
    "MG4",
    "MG5",
    "MG6",
    "MG7",
    "MG8",
    "MG9",
    "MG10",
    "MG11",
    "MG12",
    "MG13",
    "MG14",
    "MG15",
    "SLAY"
  ];
  var DISCORD_PLAY_ROOMS = [];
  function createRoomRegistry(dependencies = {}) {
    const { UnifiedState: UnifiedState3 } = dependencies;
    return {
      // Discord rooms from Garlic Bread's Server and Magic Circle Discord
      discord: [
        // Garlic Bread's Server (play1-play10 - NO HYPHEN)
        { id: "i-1425232387037462538-gc-1399110335469977781-1411124424676999308", name: "play1", category: "discord" },
        { id: "i-1426213334721757305-gc-1399110335469977781-1411801827674030191", name: "play2", category: "discord" },
        { id: "i-1426696111514456277-gc-1399110335469977781-1411801899489034471", name: "play3", category: "discord" },
        { id: "i-1425131188074319992-gc-1399110335469977781-1411801931373875240", name: "play4", category: "discord" },
        { id: "i-1426523715059056691-gc-1399110335469977781-1411801958616141864", name: "play5", category: "discord" },
        { id: "i-1426962425999130785-gc-1399110335469977781-1411801990345916496", name: "play6", category: "discord" },
        { id: "i-1426782888900296754-gc-1399110335469977781-1411802027255660644", name: "play7", category: "discord" },
        { id: "i-1426963026216751124-gc-1399110335469977781-1411802063876128980", name: "play8", category: "discord" },
        { id: "i-1426736748104515747-gc-1399110335469977781-1411802098533666837", name: "play9", category: "discord" },
        { id: "i-1426972080355807252-gc-1399110335469977781-1411802136911548467", name: "play10", category: "discord" },
        // Magic Circle Numbered Rooms (play-2 through play-50 - WITH HYPHEN)
        { id: "i-1416705483108257912-gc-808935495543160852-1389438720427425894", name: "play-2", category: "discord" },
        { id: "i-1414738624276205699-gc-808935495543160852-1389979453957996705", name: "play-3", category: "discord" },
        { id: "i-1426270545699405844-gc-808935495543160852-1389979475336233000", name: "play-4", category: "discord" },
        { id: "i-1424918072380231760-gc-808935495543160852-1391350549944733768", name: "play-5", category: "discord" },
        { id: "i-1424940435679477782-gc-808935495543160852-1391629723687452802", name: "play-6", category: "discord" },
        { id: "i-1414738652449345536-gc-808935495543160852-1392897701087019028", name: "play-7", category: "discord" },
        { id: "i-1426340656351150221-gc-808935495543160852-1417928182505672877", name: "play-8", category: "discord" },
        { id: "i-1426648328271167558-gc-808935495543160852-1392928961679331541", name: "play-9", category: "discord" },
        { id: "i-1424650709747499109-gc-808935495543160852-1394338319411970198", name: "play-10", category: "discord" },
        { id: "i-1421249275131859125-gc-808935495543160852-1394338344753959032", name: "play-11", category: "discord" },
        { id: "i-1417583142918950943-gc-808935495543160852-1394338361631703181", name: "play-12", category: "discord" },
        { id: "i-1426272039320158390-gc-808935495543160852-1394714064575271032", name: "play-13", category: "discord" },
        { id: "i-1421215237289545901-gc-808935495543160852-1394714079448399962", name: "play-14", category: "discord" },
        { id: "i-1426260441730125874-gc-808935495543160852-1394714101065974021", name: "play-15", category: "discord" },
        { id: "i-1425314797603520553-gc-808935495543160852-1394714159857270936", name: "play-16", category: "discord" },
        { id: "i-1422642064910319697-gc-808935495543160852-1395445292664488088", name: "play-17", category: "discord" },
        { id: "i-1425331756999118868-gc-808935495543160852-1395445357495718081", name: "play-18", category: "discord" },
        { id: "i-1426661481679945920-gc-808935495543160852-1421303964225372294", name: "play-19", category: "discord" },
        { id: "i-1425346474035646574-gc-808935495543160852-1395445408737788064", name: "play-20", category: "discord" },
        { id: "i-1426272183986163772-gc-808935495543160852-1406700719272104188", name: "play-21", category: "discord" },
        { id: "i-1418751419091124374-gc-808935495543160852-1413559836976873672", name: "play-22", category: "discord" },
        { id: "i-1426656896491978895-gc-808935495543160852-1414650590323277904", name: "play-23", category: "discord" },
        { id: "i-1424941680062369792-gc-808935495543160852-1414650614415102163", name: "play-24", category: "discord" },
        { id: "i-1426340142351781950-gc-808935495543160852-1414650635642732564", name: "play-25", category: "discord" },
        { id: "i-1426361682346901595-gc-808935495543160852-1415547820177625139", name: "play-26", category: "discord" },
        { id: "i-1426942108480180385-gc-808935495543160852-1415547932303687690", name: "play-27", category: "discord" },
        { id: "i-1425073932637048884-gc-808935495543160852-1415547947315236864", name: "play-28", category: "discord" },
        { id: "i-1426290019294908498-gc-808935495543160852-1415550373145350183", name: "play-29", category: "discord" },
        { id: "i-1425336873709998170-gc-808935495543160852-1420055125409661008", name: "play-30", category: "discord" },
        { id: "i-1426645924557361315-gc-808935495543160852-1415737760005755021", name: "play-31", category: "discord" },
        { id: "i-1426363145806418082-gc-808935495543160852-1415737783116628101", name: "play-32", category: "discord" },
        { id: "i-1424670769790586900-gc-808935495543160852-1415737800992751696", name: "play-33", category: "discord" },
        { id: "i-1426648937850474538-gc-808935495543160852-1415737817056940203", name: "play-34", category: "discord" },
        { id: "i-1426634638595592222-gc-808935495543160852-1415737832332329112", name: "play-35", category: "discord" },
        { id: "i-1426636340619116576-gc-808935495543160852-1415737848279335024", name: "play-36", category: "discord" },
        { id: "i-1426633119934582926-gc-808935495543160852-1415737865761194066", name: "play-37", category: "discord" },
        { id: "i-1426691900710322276-gc-808935495543160852-1415737879208001689", name: "play-38", category: "discord" },
        { id: "i-1426659673783930890-gc-808935495543160852-1415737894144053428", name: "play-39", category: "discord" },
        { id: "i-1421247473728622632-gc-808935495543160852-1415737913324605450", name: "play-40", category: "discord" },
        { id: "i-1426432879709392917-gc-808935495543160852-1426432790832087211", name: "play-41", category: "discord" },
        { id: "i-1426433582888648848-gc-808935495543160852-1426433415455965305", name: "play-42", category: "discord" },
        { id: "i-1426434402606387240-gc-808935495543160852-1426434222825930814", name: "play-43", category: "discord" },
        { id: "i-1426434430360227840-gc-808935495543160852-1426434241947893902", name: "play-44", category: "discord" },
        { id: "i-1426434453651193888-gc-808935495543160852-1426434265268097025", name: "play-45", category: "discord" },
        { id: "i-1426434474119397456-gc-808935495543160852-1426434292162101278", name: "play-46", category: "discord" },
        { id: "i-1426434494306455603-gc-808935495543160852-1426434306888171530", name: "play-47", category: "discord" },
        { id: "i-1426434520390832228-gc-808935495543160852-1426434330770804898", name: "play-48", category: "discord" },
        { id: "i-1426434545942659085-gc-808935495543160852-1426434349049577553", name: "play-49", category: "discord" },
        { id: "i-1426434571775381634-gc-808935495543160852-1426434382196904006", name: "play-50", category: "discord" },
        // Magic Circle Country/Regional Rooms
        { id: "i-1426792268613816442-gc-808935495543160852-1413592763617775657", name: "play-\u{1F1E7}\u{1F1E9}", category: "discord" },
        { id: "i-1426912200731131945-gc-808935495543160852-1413628673810239550", name: "play-\u{1F1E7}\u{1F1F7}", category: "discord" },
        { id: "i-1426725151986286703-gc-808935495543160852-1413627931644661800", name: "play-\u{1F1E8}\u{1F1E6}", category: "discord" },
        { id: "i-1426827100626751498-gc-808935495543160852-1413586163511328839", name: "play-\u{1F1E9}\u{1F1EA}", category: "discord" },
        { id: "i-1426830750170484746-gc-808935495543160852-1413586384098427002", name: "play-\u{1F1EA}\u{1F1F8}", category: "discord" },
        { id: "i-1426946558137597963-gc-808935495543160852-1413589376025235508", name: "play-\u{1F1EB}\u{1F1EE}", category: "discord" },
        { id: "i-1426458931898617916-gc-808935495543160852-1413592562136252417", name: "play-\u{1F1EB}\u{1F1F7}", category: "discord" },
        { id: "i-1426814239305240627-gc-808935495543160852-1413586233791086745", name: "play-\u{1F1EC}\u{1F1E7}", category: "discord" },
        { id: "i-1426946909162967225-gc-808935495543160852-1414314377615642904", name: "play-\u{1F1EE}\u{1F1E9}", category: "discord" },
        { id: "i-1426491363075031082-gc-808935495543160852-1413618707871301712", name: "play-\u{1F1EE}\u{1F1F9}", category: "discord" },
        { id: "i-1424645601508851743-gc-808935495543160852-1413590129213309089", name: "play-\u{1F1EF}\u{1F1F5}", category: "discord" },
        { id: "i-1419121202450141266-gc-808935495543160852-1415708269762187294", name: "play-\u{1F1F0}\u{1F1F7}", category: "discord" },
        { id: "i-1426943939231092838-gc-808935495543160852-1413590246691569794", name: "play-\u{1F1F2}\u{1F1F3}", category: "discord" },
        { id: "i-1426972888908566672-gc-808935495543160852-1413622408766689373", name: "play-\u{1F1F2}\u{1F1FD}", category: "discord" },
        { id: "i-1424661883863953488-gc-808935495543160852-1413628856426635264", name: "play-\u{1F1F3}\u{1F1F1}", category: "discord" },
        { id: "i-1426816652437721092-gc-808935495543160852-1413628948064219236", name: "play-\u{1F1F5}\u{1F1ED}", category: "discord" },
        { id: "i-1426957485669175436-gc-808935495543160852-1413630205695512607", name: "play-\u{1F1F5}\u{1F1F1}", category: "discord" },
        { id: "i-1426901797056778311-gc-808935495543160852-1413630342379880468", name: "play-\u{1F1F5}\u{1F1F9}", category: "discord" },
        { id: "i-1426887346990665869-gc-808935495543160852-1413630567003844619", name: "play-\u{1F1F7}\u{1F1F4}", category: "discord" },
        { id: "i-1426939853031968799-gc-808935495543160852-1413630623656435742", name: "play-\u{1F1F7}\u{1F1FA}", category: "discord" },
        { id: "i-1421302686969557062-gc-808935495543160852-1413630845351010336", name: "play-\u{1F1F8}\u{1F1EA}", category: "discord" },
        { id: "i-1426974695889502248-gc-808935495543160852-1413593072447705118", name: "play-\u{1F1F9}\u{1F1ED}", category: "discord" },
        { id: "i-1426925686738731140-gc-808935495543160852-1413630992336257034", name: "play-\u{1F1F9}\u{1F1F7}", category: "discord" },
        { id: "i-1426975329226395671-gc-808935495543160852-1413631114369695744", name: "play-\u{1F1FA}\u{1F1E6}", category: "discord" },
        { id: "i-1426868636468084817-gc-808935495543160852-1413586285082361857", name: "play-\u{1F1FA}\u{1F1F8}", category: "discord" },
        { id: "i-1426956652857069662-gc-808935495543160852-1413631297003737108", name: "play-\u{1F1FB}\u{1F1F3}", category: "discord" },
        // Magic Circle Special Rooms
        {
          id: "i-1424646014697267220-gc-808935495543160852-1417643699050270741",
          name: "play-qu\xE9bec",
          category: "discord"
        },
        { id: "i-1424646193404747847-gc-808935495543160852-1389442193931571271", name: "play", category: "discord" }
      ],
      // Magic Circle public rooms
      magicCircle: [
        { id: "MG1", name: "MG1", category: "public" },
        { id: "MG2", name: "MG2", category: "public" },
        { id: "MG3", name: "MG3", category: "public" },
        { id: "MG4", name: "MG4", category: "public" },
        { id: "MG5", name: "MG5", category: "public" },
        { id: "MG6", name: "MG6", category: "public" },
        { id: "MG7", name: "MG7", category: "public" },
        { id: "MG8", name: "MG8", category: "public" },
        { id: "MG9", name: "MG9", category: "public" },
        { id: "MG10", name: "MG10", category: "public" },
        { id: "MG11", name: "MG11", category: "public" },
        { id: "MG12", name: "MG12", category: "public" },
        { id: "MG13", name: "MG13", category: "public" },
        { id: "MG14", name: "MG14", category: "public" },
        { id: "MG15", name: "MG15", category: "public" },
        { id: "SLAY", name: "SLAY", category: "special" }
      ],
      /**
       * Get all rooms (discord + MG + custom)
       * @returns {Array} Combined array of all room objects
       */
      getAllRooms() {
        const custom = (UnifiedState3.data.customRooms || []).filter((code) => !this.discord.some((r) => r.id === code) && !this.magicCircle.some((r) => r.id === code)).map((code) => ({ id: code, name: code, category: "custom" }));
        return [...this.discord, ...this.magicCircle, ...custom];
      },
      /**
       * Get combined MG + custom rooms
       * @returns {Array} Combined array of Magic Circle and custom room objects
       */
      getMGAndCustomRooms() {
        const custom = (UnifiedState3.data.customRooms || []).filter((code) => !this.discord.some((r) => r.id === code) && !this.magicCircle.some((r) => r.id === code)).map((code) => ({ id: code, name: code, category: "custom" }));
        return [...this.magicCircle, ...custom];
      }
    };
  }
  function isDiscordEnvironment(dependencies = {}) {
    const {
      window: win = typeof window !== "undefined" ? window : null,
      UnifiedState: UnifiedState3,
      productionLog: productionLog3 = console.log.bind(console)
    } = dependencies;
    try {
      const isIframe = win.location !== win.parent.location;
      const isDiscordHost = win.location.host.includes("discordsays.com") || win.location.host.endsWith(".discordsays.com");
      const isDiscordActivity = isIframe || isDiscordHost;
      if (UnifiedState3?.data?.settings?.debugMode) {
        productionLog3("[Discord Detection]", {
          isIframe,
          isDiscordHost,
          isDiscordActivity,
          host: win.location.host
        });
      }
      return isDiscordActivity;
    } catch (err) {
      console.error("Failed to detect Discord environment:", err);
      return false;
    }
  }
  function getCurrentRoomCode(dependencies = {}) {
    const { window: win = typeof window !== "undefined" ? window : null } = dependencies;
    try {
      const match = win.location.pathname.match(/\/r\/([^/]+)/);
      return match ? match[1].toUpperCase() : null;
    } catch (err) {
      console.error("Failed to get room code:", err);
      return null;
    }
  }
  function getActualPlayerCount(dependencies = {}) {
    const { targetWindow: targetWindow3, UnifiedState: UnifiedState3 } = dependencies;
    try {
      const roomState = targetWindow3.MagicCircle_RoomConnection?.lastRoomStateJsonable;
      if (!roomState?.child?.data?.userSlots) {
        if (UnifiedState3.data.settings.roomDebugMode) {
          console.log("[Room Status] No userSlots data available", {
            hasRoomConnection: !!targetWindow3.MagicCircle_RoomConnection,
            hasRoomState: !!roomState,
            hasChild: !!roomState?.child,
            hasData: !!roomState?.child?.data
          });
        }
        return null;
      }
      const userSlots = roomState.child.data.userSlots;
      const count = userSlots.filter((slot) => slot !== null && slot !== void 0).length;
      if (UnifiedState3.data.settings.roomDebugMode) {
        console.log("[Room Status] Player count:", count, "userSlots:", userSlots);
      }
      return count;
    } catch (err) {
      console.error("[Room Status] Failed to get player count:", err);
      return null;
    }
  }
  function getReporterId(dependencies = {}) {
    const { UnifiedState: UnifiedState3, crypto: cryptoApi = typeof crypto !== "undefined" ? crypto : null } = dependencies;
    if (!UnifiedState3.data.roomStatus.reporterId) {
      if (cryptoApi && cryptoApi.randomUUID) {
        UnifiedState3.data.roomStatus.reporterId = cryptoApi.randomUUID();
      } else {
        UnifiedState3.data.roomStatus.reporterId = "reporter_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
      }
    }
    return UnifiedState3.data.roomStatus.reporterId;
  }
  function buildRoomApiUrl(roomIdOrCode, endpoint = "info", dependencies = {}) {
    const { location: loc = typeof location !== "undefined" ? location : null } = dependencies;
    return `${loc.origin}/api/rooms/${encodeURIComponent(roomIdOrCode)}/${endpoint}`;
  }
  async function requestRoomEndpoint(roomIdOrCode, options = {}, dependencies = {}) {
    const {
      Network: Network2,
      location: loc,
      AbortController: AbortCtrl = typeof AbortController !== "undefined" ? AbortController : null,
      setTimeout: setTimeoutFn = typeof setTimeout !== "undefined" ? setTimeout : null,
      clearTimeout: clearTimeoutFn = typeof clearTimeout !== "undefined" ? clearTimeout : null
    } = dependencies;
    const endpoint = options.endpoint ?? "info";
    const url = buildRoomApiUrl(roomIdOrCode, endpoint, { location: loc });
    const timeoutMs = options.timeoutMs ?? 1e4;
    const controller = new AbortCtrl();
    const timeout = setTimeoutFn(() => controller.abort(), timeoutMs);
    try {
      const res = await Network2.fetch(url, {
        method: "GET",
        credentials: "include",
        signal: controller.signal
      });
      const body = await res.text();
      const parsed = res.ok ? JSON.parse(body) : void 0;
      return { status: res.status, ok: res.ok, body, parsed };
    } catch (err) {
      throw new Error(`Room endpoint fetch failed: ${err.message}`);
    } finally {
      clearTimeoutFn(timeout);
    }
  }
  async function initializeFirebase(dependencies = {}) {
    const {
      RoomRegistry,
      UnifiedState: UnifiedState3,
      requestRoomEndpoint: requestEndpoint,
      getReporterId: getReporter,
      productionLog: productionLog3 = console.log.bind(console),
      setInterval: setIntervalFn = typeof setInterval !== "undefined" ? setInterval : null,
      clearInterval: clearIntervalFn = typeof clearInterval !== "undefined" ? clearInterval : null
    } = dependencies;
    try {
      const firebase = {
        __useInfo: true,
        getDatabase() {
          return {};
        },
        ref(_db, path) {
          return { path };
        },
        onValue(_refObj, callback) {
          let abort = false;
          const fetchInfo = async (room) => {
            try {
              const response = await requestEndpoint(room, { endpoint: "info", timeoutMs: 1e4 }, dependencies);
              if (!response.ok) throw new Error(`HTTP ${response.status}`);
              const payload = response.parsed;
              const players = typeof payload?.numPlayers === "number" ? payload.numPlayers : 0;
              const count = Math.max(0, Math.min(6, Math.floor(players)));
              return { count, lastUpdate: Date.now(), reporter: getReporter(dependencies) };
            } catch (err) {
              if (UnifiedState3.data.settings?.roomDebugMode) {
                console.warn(`[Room API] Failed to fetch ${room}:`, err.message);
              }
              return { count: 0, lastUpdate: Date.now(), reporter: getReporter(dependencies) };
            }
          };
          async function tick() {
            if (abort) return;
            const out = {};
            for (const rc of UnifiedState3.data.customRooms) {
              out[rc] = await fetchInfo(rc);
            }
            if (RoomRegistry && RoomRegistry.discord) {
              for (const room of RoomRegistry.discord) {
                out[room.id] = await fetchInfo(room.id);
              }
            }
            const snapshot = { val: () => out };
            try {
              callback(snapshot);
            } catch (e) {
              console.error("rooms onValue cb error", e);
            }
          }
          tick();
          const iv = setIntervalFn(tick, 5e3);
          return function unsubscribe() {
            abort = true;
            clearIntervalFn(iv);
          };
        },
        set() {
        },
        onDisconnect() {
          return { remove() {
          } };
        }
      };
      productionLog3("\u2705 /info rooms mode enabled (Firebase stubbed)");
      return firebase;
    } catch (err) {
      console.error("\u274C initializeFirebase (/info) failed", err);
      return null;
    }
  }

  // src/features/version-checker.js
  var version_checker_exports = {};
  __export(version_checker_exports, {
    checkVersion: () => checkVersion,
    compareVersions: () => compareVersions2
  });
  function compareVersions2(v1, v2, dependencies = {}) {
    const parts1 = v1.split(".").map(Number);
    const parts2 = v2.split(".").map(Number);
    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const part1 = parts1[i] || 0;
      const part2 = parts2[i] || 0;
      if (part1 > part2) return 1;
      if (part1 < part2) return -1;
    }
    return 0;
  }
  async function checkVersion(indicatorElement, dependencies = {}) {
    const {
      CURRENT_VERSION: CURRENT_VERSION2 = "1.0.0",
      IS_LIVE_BETA: IS_LIVE_BETA2 = false,
      STABLE_DOWNLOAD_URL: STABLE_DOWNLOAD_URL2 = "https://github.com/Myke247/MGTools/raw/main/MGTools.user.js",
      BETA_DOWNLOAD_URL: BETA_DOWNLOAD_URL2 = "https://github.com/Myke247/MGTools/raw/Live-Beta/MGTools.user.js",
      isDiscordPage = false,
      window: win = typeof window !== "undefined" ? window : null,
      console: con = typeof console !== "undefined" ? console : null
    } = dependencies;
    if (!win || !indicatorElement) return;
    if (isDiscordPage) {
      const branchLabel = IS_LIVE_BETA2 ? "BETA" : "STABLE";
      indicatorElement.style.color = IS_LIVE_BETA2 ? "#ff9500" : "#00ff00";
      const tooltipLines = [
        `CURRENT VERSION: v${CURRENT_VERSION2} (${branchLabel})`,
        `STATUS: Version check disabled on Discord`,
        "",
        "Shift+Click: Install Stable",
        "Shift+Alt+Click: Install Beta"
      ];
      indicatorElement.title = tooltipLines.join("\n");
      indicatorElement.style.cursor = "pointer";
      indicatorElement.addEventListener("click", (e) => {
        e.stopPropagation();
        if (e.shiftKey && e.altKey) {
          win.open(BETA_DOWNLOAD_URL2, "_blank");
        } else if (e.shiftKey) {
          win.open(STABLE_DOWNLOAD_URL2, "_blank");
        }
      });
      return;
    }
    const cacheBust = `?t=${Date.now()}`;
    async function fetchVersion(branch) {
      const urls = [
        `https://raw.githubusercontent.com/Myke247/MGTools/${branch}/MGTools.user.js${cacheBust}`,
        `https://api.github.com/repos/Myke247/MGTools/contents/MGTools.user.js`
      ];
      for (const url of urls) {
        try {
          const isGitHubAPI = url.includes("api.github.com");
          const response = await win.fetch(url, {
            method: "GET",
            cache: "no-cache",
            headers: isGitHubAPI ? { Accept: "application/vnd.github.v3.raw" } : {}
          });
          if (response.ok) {
            const text = await response.text();
            const match = text.match(/@version\s+([\d.]+)/);
            if (match) return match[1];
          }
        } catch (e) {
          continue;
        }
      }
      return null;
    }
    try {
      const [stableVersion, betaVersion] = await Promise.all([fetchVersion("main"), fetchVersion("Live-Beta")]);
      if (!stableVersion && !betaVersion) {
        const branchLabel2 = IS_LIVE_BETA2 ? "BETA" : "STABLE";
        indicatorElement.style.color = IS_LIVE_BETA2 ? "#ff9500" : "#ffa500";
        const tooltipLines2 = [
          `CURRENT VERSION: v${CURRENT_VERSION2} (${branchLabel2})`,
          `STATUS: Version check failed`,
          "",
          "Click: Retry",
          "Shift+Click: Install Stable",
          "Shift+Alt+Click: Install Beta"
        ];
        indicatorElement.title = tooltipLines2.join("\n");
        indicatorElement.style.cursor = "pointer";
        const newIndicator2 = indicatorElement.cloneNode(true);
        indicatorElement.parentNode.replaceChild(newIndicator2, indicatorElement);
        newIndicator2.addEventListener("click", (e) => {
          e.stopPropagation();
          if (e.shiftKey && e.altKey) {
            win.open(BETA_DOWNLOAD_URL2, "_blank");
          } else if (e.shiftKey) {
            win.open(STABLE_DOWNLOAD_URL2, "_blank");
          } else {
            newIndicator2.style.color = "#888";
            newIndicator2.title = "Checking for updates...";
            checkVersion(newIndicator2, dependencies);
          }
        });
        return;
      }
      const relevantVersion = IS_LIVE_BETA2 ? betaVersion : stableVersion;
      const versionComparison = compareVersions2(CURRENT_VERSION2, relevantVersion);
      let color;
      let statusMsg;
      const branchLabel = IS_LIVE_BETA2 ? "BETA" : "STABLE";
      if (IS_LIVE_BETA2) {
        if (versionComparison === 0) {
          color = "#ff9500";
          statusMsg = "UP TO DATE";
        } else if (versionComparison > 0) {
          color = "#ffff00";
          statusMsg = "DEV VERSION";
        } else {
          color = "#ff00ff";
          statusMsg = "UPDATE AVAILABLE";
        }
      } else {
        if (versionComparison === 0) {
          color = "#00ff00";
          statusMsg = "UP TO DATE";
        } else if (versionComparison > 0) {
          color = "#90ee90";
          statusMsg = "DEV VERSION";
        } else {
          color = "#ff0000";
          statusMsg = "UPDATE AVAILABLE";
        }
      }
      const tooltipLines = [
        `CURRENT VERSION: v${CURRENT_VERSION2} (${branchLabel})`,
        `STATUS: ${statusMsg}`,
        "",
        `GitHub Versions:`,
        IS_LIVE_BETA2 ? `  Your Branch (Beta): v${betaVersion || "Loading..."}` : `  Your Branch (Stable): v${stableVersion || "Loading..."}`,
        IS_LIVE_BETA2 ? `  Other Branch (Stable): v${stableVersion || "Loading..."}` : `  Other Branch (Beta): v${betaVersion || "Loading..."}`,
        "",
        "Click: Recheck",
        "Shift+Click: Install Stable",
        "Shift+Alt+Click: Install Beta"
      ];
      indicatorElement.style.color = color;
      indicatorElement.title = tooltipLines.join("\n");
      indicatorElement.style.cursor = "pointer";
      const newIndicator = indicatorElement.cloneNode(true);
      indicatorElement.parentNode.replaceChild(newIndicator, indicatorElement);
      newIndicator.addEventListener("click", (e) => {
        e.stopPropagation();
        if (e.shiftKey && e.altKey) {
          win.open(BETA_DOWNLOAD_URL2, "_blank");
        } else if (e.shiftKey) {
          win.open(STABLE_DOWNLOAD_URL2, "_blank");
        } else {
          newIndicator.style.color = "#888";
          newIndicator.title = `v${CURRENT_VERSION2} - Checking for updates...`;
          checkVersion(newIndicator, dependencies);
        }
      });
    } catch (e) {
      const branchLabel = IS_LIVE_BETA2 ? "BETA" : "STABLE";
      indicatorElement.style.color = IS_LIVE_BETA2 ? "#ff9500" : "#ffa500";
      const tooltipLines = [
        `CURRENT VERSION: v${CURRENT_VERSION2} (${branchLabel})`,
        `STATUS: Version check failed`,
        "",
        "Click: Retry",
        "Shift+Click: Install Stable",
        "Shift+Alt+Click: Install Beta"
      ];
      indicatorElement.title = tooltipLines.join("\n");
      indicatorElement.style.cursor = "pointer";
      const newIndicator = indicatorElement.cloneNode(true);
      indicatorElement.parentNode.replaceChild(newIndicator, indicatorElement);
      newIndicator.addEventListener("click", (e2) => {
        e2.stopPropagation();
        if (e2.shiftKey && e2.altKey) {
          win.open(BETA_DOWNLOAD_URL2, "_blank");
        } else if (e2.shiftKey) {
          win.open(STABLE_DOWNLOAD_URL2, "_blank");
        } else {
          newIndicator.style.color = "#888";
          newIndicator.title = "Checking for updates...";
          checkVersion(newIndicator, dependencies);
        }
      });
      if (con) {
        con.log("[VERSION CHECK] Error:", e);
      }
    }
  }

  // src/features/mgtp-overlay.js
  var mgtp_overlay_exports = {};
  __export(mgtp_overlay_exports, {
    initializeMGTPOverlay: () => initializeMGTPOverlay
  });
  function initializeMGTPOverlay(dependencies = {}) {
    const {
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" ? window : null,
      unsafeWindow: unsafeWin = typeof unsafeWindow !== "undefined" ? unsafeWindow : null,
      CompatibilityMode: CompatibilityMode2,
      logInfo: logInfo3 = console.log,
      logWarn: logWarn3 = console.warn,
      logDebug: logDebug2 = console.log,
      productionLog: productionLog3 = console.log,
      productionWarn: productionWarn3 = console.warn,
      productionError: productionError2 = console.error,
      GM_setValue: gmSetValue = typeof GM_setValue !== "undefined" ? GM_setValue : null,
      GM_getValue: gmGetValue = typeof GM_getValue !== "undefined" ? GM_getValue : null,
      GM_xmlhttpRequest: gmXhr = typeof GM_xmlhttpRequest !== "undefined" ? GM_xmlhttpRequest : null
    } = dependencies;
    if (!targetDocument2 || !targetWindow3) {
      productionWarn3("[MGTP] Cannot initialize - missing document or window");
      return;
    }
    const d = targetDocument2;
    const rootHost = d.createElement("div");
    rootHost.id = "mgtp-overlay-root";
    rootHost.style.cssText = "position:fixed;left:0;top:0;width:0;height:0;z-index:2147483646;pointer-events:none;";
    const shadow = rootHost.attachShadow({ mode: "open" });
    const style = d.createElement("style");
    style.textContent = `
      .wrap{position:absolute;transform:translate(-50%,-100%); background:transparent; pointer-events:none; font-family: system-ui, sans-serif;}
      .line{display:block; white-space:nowrap; text-shadow:0 1px 1px rgba(0,0,0,.6); font-weight:700; text-align:center;}
      .estimate{font-size:13px; color:#70ff70;}
      .slot{font-size:14px; color:#ffd24d;}
      .hidden{display:none;}
    `;
    const wrap = d.createElement("div");
    wrap.className = "wrap hidden";
    const est = d.createElement("div");
    est.className = "line estimate";
    const slot = d.createElement("div");
    slot.className = "line slot";
    wrap.appendChild(est);
    wrap.appendChild(slot);
    shadow.appendChild(style);
    shadow.appendChild(wrap);
    d.documentElement.appendChild(rootHost);
    function placeAtRect(rect) {
      wrap.style.left = rect.left + rect.width / 2 + "px";
      wrap.style.top = rect.top + 2 + "px";
    }
    function visible(v) {
      wrap.classList.toggle("hidden", !v);
    }
    function bestAnchorFrom(el2) {
      try {
        if (el2 && el2.getBoundingClientRect) return el2.getBoundingClientRect();
      } catch (e) {
      }
      const cand = d.querySelectorAll(
        '[role="tooltip"], [data-popper-placement], .chakra-tooltip, .chakra-tooltip__popper'
      );
      let best = null, bestArea = -1;
      cand.forEach((e) => {
        const r = e.getBoundingClientRect();
        if (r.width > 0 && r.height > 0) {
          if (e.closest('[data-panel="pet-stats"], .pet-panel, [data-sidebar]')) return;
          const area = r.width * r.height;
          if (area > bestArea) {
            bestArea = area;
            best = r;
          }
        }
      });
      if (best) return best;
      return { left: innerWidth / 2 - 1, top: innerHeight / 2 - 1, width: 2, height: 2 };
    }
    targetWindow3.MGTP_slotOverlay = {
      update({ estimateText, slotValueText, anchorElement } = {}) {
        const hasEst = !!(estimateText && String(estimateText).trim());
        const hasSlot = !!(slotValueText && String(slotValueText).trim());
        est.textContent = hasEst ? String(estimateText) : "";
        slot.textContent = hasSlot ? String(slotValueText) : "";
        if (!hasEst && !hasSlot) {
          visible(false);
          return;
        }
        const r = bestAnchorFrom(anchorElement);
        placeAtRect(r);
        visible(true);
      },
      hide() {
        visible(false);
      }
    };
    const CLEAR_FLAG = "MGA_logs_manually_cleared";
    const SESSION_FLAG = "MGA_logs_clear_session";
    function clearFlagIfNeededOnAdd() {
      if (localStorage.getItem(CLEAR_FLAG) === "true") {
        try {
          localStorage.removeItem(CLEAR_FLAG);
        } catch (e) {
        }
      }
      if (localStorage.getItem(SESSION_FLAG)) {
        try {
          localStorage.removeItem(SESSION_FLAG);
        } catch (e) {
        }
      }
    }
    function wrapLogsArray2(arr) {
      let arrLocal = arr;
      if (!Array.isArray(arrLocal)) arrLocal = [];
      const seen = /* @__PURE__ */ new Set();
      const fp = (l) => {
        const t = l && l.abilityType || "", p = l && l.petName || "";
        const ts = String(l && l.timestamp || 0);
        let h = 2166136261 >>> 0, s = t + "|" + p + "|" + ts;
        for (let i = 0; i < s.length; i++) {
          h ^= s.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return (h >>> 0).toString(36);
      };
      const dedupePush = (item) => {
        const id = item.id || fp(item);
        if (seen.has(id)) return 0;
        seen.add(id);
        arrLocal.push({ ...item, id });
        return 1;
      };
      for (const it of arrLocal) {
        seen.add(it.id || fp(it));
      }
      return new Proxy(arrLocal, {
        get(target, prop, recv) {
          if (["push", "unshift", "splice", "concat"].includes(prop)) {
            return function(...args) {
              let added = 0;
              if (prop === "push" || prop === "unshift") {
                for (const it of args) {
                  added += dedupePush(it);
                }
                if (added > 0) clearFlagIfNeededOnAdd();
                return target.length;
              }
              if (prop === "splice") {
                if (args.length > 2) {
                  const start = args[0] >>> 0, del = args[1] >>> 0, newItems = args.slice(2);
                  const before = target.slice(0, start);
                  const after = target.slice(start + del);
                  const rebuilt = wrapLogsArray2(before);
                  for (const it of newItems) {
                    dedupePush.call({ arr: rebuilt }, it);
                  }
                  for (const it of after) {
                    dedupePush.call({ arr: rebuilt }, it);
                  }
                  while (target.length) target.pop();
                  for (const it of rebuilt) target.push(it);
                  clearFlagIfNeededOnAdd();
                  return [];
                }
              }
              return Array.prototype[prop].apply(target, args);
            };
          }
          return Reflect.get(target, prop, recv);
        },
        set(target, key, val) {
          if (!isNaN(key)) {
            const added = dedupePush(val);
            if (added > 0) clearFlagIfNeededOnAdd();
            return true;
          }
          return Reflect.set(target, key, val);
        }
      });
    }
    (function waitUnified() {
      const us = targetWindow3.UnifiedState && targetWindow3.UnifiedState.data;
      if (us) {
        if (!us.petAbilityLogs || !us.petAbilityLogs.__proxied) {
          us.petAbilityLogs = wrapLogsArray2(us.petAbilityLogs || []);
          Object.defineProperty(us.petAbilityLogs, "__proxied", { value: true });
        }
        d.addEventListener(
          "click",
          function(e) {
            const tgt = e.target;
            if (tgt && tgt.id === "clear-ability-logs") {
              e.preventDefault();
              e.stopImmediatePropagation();
              try {
                us.petAbilityLogs.length = 0;
                if (gmSetValue) {
                  gmSetValue("MGA_petAbilityLogs", JSON.stringify([]));
                }
                localStorage.setItem("MGA_petAbilityLogs", JSON.stringify([]));
                localStorage.setItem(CLEAR_FLAG, "true");
                const archKeys = ["MGA_petAbilityLogs_archive"];
                archKeys.forEach((k) => {
                  try {
                    if (gmSetValue) gmSetValue(k, JSON.stringify([]));
                  } catch (err) {
                  }
                  try {
                    localStorage.removeItem(k);
                  } catch (err) {
                  }
                });
                if (targetWindow3.updateAbilityLogDisplay) {
                  try {
                    targetWindow3.updateAbilityLogDisplay(targetDocument2);
                  } catch (err) {
                  }
                }
              } catch (err) {
                console.error("[MGTP] clear logs failed", err);
              }
            }
          },
          true
        );
        return;
      }
      setTimeout(waitUnified, 200);
    })();
    function rerenderRoomsUI() {
      try {
        if (typeof getRoomStatusTabContent !== "function") {
          return;
        }
        const candidates = targetDocument2.querySelectorAll('[data-tab="rooms"], .mga-tab-content, .mga-overlay-content');
        let updated = false;
        candidates.forEach((c, idx) => {
          const list = c.querySelector("#room-status-list");
          const isRoomsTab = c.getAttribute && c.getAttribute("data-tab") === "rooms";
          if (list || isRoomsTab) {
            const html = getRoomStatusTabContent();
            c.innerHTML = html;
            if (typeof setupRoomJoinButtons === "function") {
              setupRoomJoinButtons();
              setupRoomsTabButtons();
            }
            updated = true;
          }
        });
      } catch (e) {
        if (typeof logDebug2 === "function") {
          logDebug2("ROOMS-UI", "\u274C Render error:", e);
        }
      }
    }
    (function roomsInfo() {
      const isUserscript2 = typeof unsafeWin !== "undefined" && unsafeWin !== null;
      const correctWindow = isUserscript2 ? unsafeWin : targetWindow3;
      const globalScope = correctWindow;
      const getApiBase = globalScope.getGameApiBaseUrl || (() => location.origin);
      const apiBase = getApiBase();
      const API_V1 = (name) => `${apiBase}/api/rooms/${encodeURIComponent(name)}/info`;
      const TRACKED = correctWindow.UnifiedState?.data?.customRooms || correctWindow.TRACKED_ROOMS || ["MG1", "MG2", "MG3", "MG4", "MG5", "MG6", "MG7", "MG8", "MG9", "MG10", "SLAY"];
      let extra = /* @__PURE__ */ new Set();
      const counts = {};
      const roomIdToName = {};
      function parsePlayerCount2(data) {
        if (!data) return 0;
        const count = data?.numPlayers ?? data?.players?.online ?? data?.players?.count ?? data?.online ?? data?.count ?? data?.playerCount ?? 0;
        return Math.max(0, Number(count) || 0);
      }
      async function fetchWithFetch(url, name) {
        const r = await fetch(url, {
          method: "GET",
          credentials: "include",
          headers: { Accept: "application/json" },
          signal: AbortSignal.timeout(1e4)
        });
        if (!r.ok) {
          throw new Error(`HTTP ${r.status}`);
        }
        const data = await r.json();
        return data;
      }
      async function fetchWithGM(url, name) {
        return new Promise((resolve, reject) => {
          if (!gmXhr) {
            reject(new Error("GM_xmlhttpRequest not available"));
            return;
          }
          gmXhr({
            method: "GET",
            url,
            headers: { Accept: "application/json" },
            timeout: 1e4,
            onload: (response) => {
              if (response.status >= 200 && response.status < 300) {
                try {
                  const data = JSON.parse(response.responseText);
                  resolve(data);
                } catch (e) {
                  reject(new Error(`Parse error: ${e.message}`));
                }
              } else {
                reject(new Error(`HTTP ${response.status}`));
              }
            },
            onerror: (error) => reject(new Error("Network error")),
            ontimeout: () => reject(new Error("Timeout"))
          });
        });
      }
      async function fetchOne(roomIdOrName) {
        const roomDebugMode = correctWindow.UnifiedState?.data?.settings?.roomDebugMode;
        const isDiscordRoom = roomIdOrName.includes("i-") && roomIdOrName.includes("-gc-");
        try {
          let data = null;
          try {
            const url1 = API_V1(roomIdOrName);
            data = await fetchWithFetch(url1, roomIdOrName);
            if (roomDebugMode) {
              console.log(`[ROOMS] \u2705 Fetch succeeded for ${roomIdOrName}:`, data);
            }
          } catch (e1) {
            try {
              const url1 = API_V1(roomIdOrName);
              if (roomDebugMode) {
                console.log(`[ROOMS] \u{1F504} Retrying ${roomIdOrName} with GM_xmlhttpRequest`);
              }
              data = await fetchWithGM(url1, roomIdOrName);
              if (roomDebugMode) {
                console.log(`[ROOMS] \u2705 GM fetch succeeded for ${roomIdOrName}:`, data);
              }
            } catch (e2) {
              if (roomDebugMode) {
                console.warn(`[ROOMS] \u274C Failed to fetch ${roomIdOrName}:`, e1.message);
              }
              throw new Error(`All methods failed for ${roomIdOrName}`);
            }
          }
          const online = parsePlayerCount2(data);
          let storageKey;
          if (isDiscordRoom && roomIdToName[roomIdOrName]) {
            storageKey = roomIdToName[roomIdOrName].toUpperCase();
            if (roomDebugMode && online > 0) {
              console.log(`[ROOMS] \u{1F4CA} Discord room ${roomIdToName[roomIdOrName]}: ${online} players`);
            }
          } else {
            storageKey = roomIdOrName.toUpperCase();
            if (roomDebugMode && online > 0) {
              console.log(`[ROOMS] \u{1F4CA} ${roomIdOrName}: ${online} players`);
            }
          }
          counts[storageKey] = online;
        } catch (e) {
          let storageKey;
          if (isDiscordRoom && roomIdToName[roomIdOrName]) {
            storageKey = roomIdToName[roomIdOrName].toUpperCase();
          } else {
            storageKey = roomIdOrName.toUpperCase();
          }
          counts[storageKey] = 0;
          if (roomDebugMode) {
            console.warn(
              `[ROOMS] \u26A0\uFE0F ${isDiscordRoom ? "Discord room" : "Room"} ${roomIdOrName.substring(0, 30)}... failed:`,
              e.message
            );
          }
        }
      }
      let lastTickWhenHidden = 0;
      let cachedRoomsUIVisible = null;
      let lastUICheckTime = 0;
      async function tick() {
        const roomDebugMode = correctWindow.UnifiedState?.data?.settings?.roomDebugMode;
        const now = Date.now();
        if (!cachedRoomsUIVisible || now - lastUICheckTime > 5e3) {
          cachedRoomsUIVisible = targetDocument2.querySelector('.mga-sidebar[data-visible="true"] [data-tab="rooms"]') || targetDocument2.querySelector("#room-status-list") || targetDocument2.querySelector('[data-mga-popout="rooms"]');
          lastUICheckTime = now;
        }
        const roomsUIVisible = cachedRoomsUIVisible;
        if (!roomsUIVisible) {
          const now2 = Date.now();
          if (lastTickWhenHidden > 0 && now2 - lastTickWhenHidden < 3e4) {
            if (roomDebugMode) {
              const secondsSinceLastPoll = Math.floor((now2 - lastTickWhenHidden) / 1e3);
              console.log(`[ROOMS] \u23F8\uFE0F Skipping tick - UI hidden (last poll ${secondsSinceLastPoll}s ago)`);
            }
            return;
          }
          lastTickWhenHidden = now2;
          if (roomDebugMode) {
            console.log("[ROOMS] \u{1F504} Polling while UI hidden (30s interval)");
          }
        } else {
          lastTickWhenHidden = 0;
        }
        const discordRoomIds = typeof correctWindow.RoomRegistry !== "undefined" && correctWindow.RoomRegistry?.discord ? correctWindow.RoomRegistry.discord.map((r) => r.id) : [];
        if (correctWindow.RoomRegistry?.discord && Object.keys(roomIdToName).length === 0) {
          correctWindow.RoomRegistry.discord.forEach((room) => {
            roomIdToName[room.id] = room.name;
          });
          if (roomDebugMode) {
            console.log("[ROOMS] \u{1F5FA}\uFE0F Built Discord room lookup map:", Object.keys(roomIdToName).length, "rooms");
          }
        }
        const names = [...TRACKED, ...extra, ...discordRoomIds];
        if (roomDebugMode) {
          console.log(
            `[ROOMS] \u{1F504} Tick running: ${names.length} total rooms (${TRACKED.length} MG/Custom, ${discordRoomIds.length} Discord)`
          );
        }
        try {
          const BATCH_SIZE = 10;
          const BATCH_DELAY = 200;
          for (let i = 0; i < names.length; i += BATCH_SIZE) {
            const batch = names.slice(i, i + BATCH_SIZE);
            await Promise.all(batch.map(fetchOne));
            if (i + BATCH_SIZE < names.length) {
              await new Promise((resolve) => setTimeout(resolve, BATCH_DELAY));
            }
          }
          if (roomDebugMode) {
            const discordKeys = Object.keys(counts).filter((k) => k.startsWith("PLAY"));
            if (discordKeys.length > 0) {
              console.log(
                "[ROOMS] \u{1F4DD} Sample Discord room counts:",
                discordKeys.slice(0, 5).map((k) => `${k}:${counts[k]}`).join(", ")
              );
            }
          }
        } catch (e) {
          console.error("[ROOMS] \u274C Tick error:", e);
        }
        if (typeof correctWindow.UnifiedState !== "undefined" && correctWindow.UnifiedState?.data) {
          correctWindow.UnifiedState.data.roomStatus = correctWindow.UnifiedState.data.roomStatus || {};
          correctWindow.UnifiedState.data.roomStatus.counts = { ...counts };
          if (typeof targetWindow3.MGA_saveJSON === "function") {
            targetWindow3.MGA_saveJSON("MGA_roomStatus", correctWindow.UnifiedState.data.roomStatus);
          }
          if (roomDebugMode) {
            console.log(`[ROOMS] \u2705 Updated ${Object.keys(counts).length} room counts in UnifiedState`);
          }
          if (typeof targetWindow3.refreshSeparateWindowPopouts === "function") {
            try {
              targetWindow3.refreshSeparateWindowPopouts("rooms");
            } catch (err) {
            }
          }
          try {
            rerenderRoomsUI();
            targetDocument2.querySelectorAll('.mga-tab-item[data-tab="rooms"]').forEach((tab) => tab.click());
          } catch (err) {
          }
          const list = targetDocument2.getElementById("room-status-list");
          if (list) {
            if (typeof targetWindow3.updateRoomStatusUI === "function") {
              targetWindow3.updateRoomStatusUI();
            } else {
              list.querySelectorAll(".room-row").forEach((row) => {
                const code = (row.getAttribute("data-room") || "").toUpperCase();
                const span = row.querySelector(".room-count");
                if (span && code) {
                  span.textContent = String(counts[code] ?? targetWindow3.UnifiedState.data.roomStatus.counts[code] ?? 0);
                }
              });
            }
          }
        }
      }
      const obs = new MutationObserver(() => {
        const inp = targetDocument2.getElementById("room-search-input");
        if (inp && !inp.__mgtpBound) {
          inp.__mgtpBound = true;
          inp.addEventListener("input", () => {
            const q = (inp.value || "").trim().toUpperCase();
            extra = new Set(
              q ? q.split(",").map((s) => s.trim()).filter(Boolean) : []
            );
          });
        }
      });
      const observeRoomSearch = () => {
        const sidebar = targetDocument2.getElementById("mgh-sidebar") || targetDocument2.querySelector(".mga-sidebar");
        const targetElement = sidebar || targetDocument2.documentElement;
        obs.observe(targetElement, {
          subtree: true,
          childList: true,
          // OPTIMIZATION: Only watch childList changes, ignore attributes/characterData
          attributes: false,
          characterData: false
        });
        if (!sidebar) {
          setTimeout(() => {
            obs.disconnect();
            observeRoomSearch();
          }, 1e3);
        }
      };
      observeRoomSearch();
      function startPollingWhenReady() {
        const hasUnifiedState = typeof correctWindow.UnifiedState !== "undefined" && correctWindow.UnifiedState?.data;
        const hasRoomRegistry = typeof correctWindow.RoomRegistry !== "undefined" && correctWindow.RoomRegistry?.discord;
        if (hasUnifiedState && hasRoomRegistry) {
          setTimeout(tick, 1e3);
          setInterval(tick, 1e4);
        } else {
          setTimeout(startPollingWhenReady, 500);
        }
      }
      startPollingWhenReady();
      correctWindow.testDiscordRoomFetch = async function(roomId) {
        const testId = roomId || "i-1425232387037462538-gc-1399110335469977781-1411124424676999308";
        const url = `${apiBase}/api/rooms/${encodeURIComponent(testId)}/info`;
        console.log("[ROOMS TEST] Testing:", testId.substring(0, 40) + "...");
        console.log("[ROOMS TEST] URL:", url);
        try {
          const response = await fetch(url, {
            method: "GET",
            credentials: "include",
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            const text = await response.text();
            console.error("[ROOMS TEST] \u274C HTTP", response.status, "-", text);
            return;
          }
          const data = await response.json();
          console.log("[ROOMS TEST] \u2705 Success! Players:", data.numPlayers ?? "NOT FOUND", "| Full data:", data);
        } catch (e) {
          console.error("[ROOMS TEST] \u274C Fetch failed:", e);
        }
      };
    })();
    (function enhancedSocketReconnect() {
      const Native = targetWindow3.WebSocket;
      if (!Native || Native.__mgtoolsPatched) return;
      let attempts = 0;
      const MAX_ATTEMPTS = 6;
      let reconnectTimer = null;
      let userNotified = false;
      const isDiscord = /discord|overlay|electron/i.test(navigator.userAgent) || !!(targetWindow3.DiscordNative || targetWindow3.__discordApp);
      const isIframe = targetWindow3 !== targetWindow3.top;
      const isMobile = /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      if (CompatibilityMode2 && CompatibilityMode2.flags && CompatibilityMode2.flags.wsReconnectWhenHidden) {
        try {
          const originalDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, "hidden") || Object.getOwnPropertyDescriptor(targetDocument2, "hidden");
          if (originalDescriptor && originalDescriptor.get) {
            Object.defineProperty(targetDocument2, "hidden", {
              get: function() {
                return false;
              },
              configurable: true
            });
            logInfo3("COMPAT-WS", "Overrode document.hidden to enable reconnection in hidden state");
          }
          const originalVisibilityDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, "visibilityState") || Object.getOwnPropertyDescriptor(targetDocument2, "visibilityState");
          if (originalVisibilityDescriptor && originalVisibilityDescriptor.get) {
            Object.defineProperty(targetDocument2, "visibilityState", {
              get: function() {
                return "visible";
              },
              configurable: true
            });
          }
        } catch (e) {
          logWarn3("COMPAT-WS", "Failed to override document.hidden", e);
        }
      }
      const style2 = targetDocument2.createElement("style");
      style2.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(400px); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(400px); opacity: 0; }
            }
        `;
      targetDocument2.head.appendChild(style2);
      function showReconnectToast(attemptNum, maxAttempts, nextWait) {
        let toast2 = targetDocument2.getElementById("mga-reconnect-toast");
        const toastHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 24px;">\u{1F504}</div>
                    <div>
                        <div style="font-weight: 600; margin-bottom: 4px;">Connection Lost</div>
                        <div style="font-size: 12px; opacity: 0.9;">
                            Reconnecting... (${attemptNum}/${maxAttempts})
                            <br>Next attempt in ${Math.round(nextWait / 1e3)}s
                        </div>
                    </div>
                </div>
            `;
        if (!toast2) {
          toast2 = targetDocument2.createElement("div");
          toast2.id = "mga-reconnect-toast";
          toast2.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                    background: linear-gradient(135deg, rgba(59, 130, 246, 0.95), rgba(37, 99, 235, 0.95));
                    color: white; padding: 16px 24px; border-radius: 12px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    font-size: 14px; font-weight: 500; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                    animation: slideInRight 0.3s ease-out; max-width: 320px; pointer-events: auto;
                `;
          targetDocument2.body.appendChild(toast2);
        }
        toast2.innerHTML = toastHTML;
        userNotified = true;
        setTimeout(() => {
          if (toast2 && toast2.parentNode) {
            toast2.style.animation = "slideOutRight 0.3s ease-out";
            setTimeout(() => toast2.remove(), 300);
          }
        }, 5e3);
      }
      function showFailureToast() {
        const failToast = targetDocument2.createElement("div");
        failToast.id = "mga-reconnect-fail-toast";
        failToast.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                background: linear-gradient(135deg, rgba(220, 38, 38, 0.95), rgba(185, 28, 28, 0.95));
                color: white; padding: 16px 24px; border-radius: 12px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                font-size: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); max-width: 320px;
            `;
        failToast.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">\u26A0\uFE0F Connection Failed</div>
                <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                    Unable to reconnect after ${MAX_ATTEMPTS} attempts
                </div>
                <button onclick="location.reload()" style="
                    background: white; color: #dc2626; border: none; padding: 8px 16px;
                    border-radius: 6px; cursor: pointer; font-weight: 600; width: 100%; font-size: 13px;
                ">Reload Page</button>
            `;
        targetDocument2.body.appendChild(failToast);
      }
      function scheduleReload(code, wasClean, reason) {
        if (code === 4710 || /version.?expired/i.test(reason || "")) {
          productionLog3("[WebSocket] Version expired detected (code 4710) - auto-refreshing in 5 seconds");
          let countdown = 5;
          const updateToast = targetDocument2.createElement("div");
          updateToast.id = "mga-update-toast";
          updateToast.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
                    color: white; padding: 16px 24px; border-radius: 12px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    font-size: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                    animation: slideInRight 0.3s ease-out; max-width: 320px;
                `;
          updateToast.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 24px;">\u{1F3AE}</div>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 4px;">Game Update Available</div>
                            <div style="font-size: 12px; opacity: 0.9;">
                                Refreshing in <span id="mga-countdown">${countdown}</span>s...
                            </div>
                        </div>
                    </div>
                `;
          targetDocument2.body.appendChild(updateToast);
          const countdownInterval = setInterval(() => {
            countdown--;
            const countdownEl = targetDocument2.getElementById("mga-countdown");
            if (countdownEl) {
              countdownEl.textContent = countdown;
            }
            if (countdown <= 0) {
              clearInterval(countdownInterval);
            }
          }, 1e3);
          setTimeout(() => {
            productionLog3("[WebSocket] Auto-refreshing for game update...");
            targetWindow3.location.reload();
          }, 5e3);
          return;
        }
        if (wasClean && code !== 1006 && !/update/i.test(reason || "")) {
          productionLog3("[WebSocket] Clean close detected - no reconnect needed");
          return;
        }
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        if (attempts >= MAX_ATTEMPTS) {
          productionWarn3(`[WebSocket] Max reconnect attempts (${MAX_ATTEMPTS}) reached - manual refresh required`);
          showFailureToast();
          return;
        }
        const wait = Math.min(1e3 * Math.pow(2, attempts), 15e3);
        attempts++;
        productionLog3(
          `[WebSocket] Reconnect attempt ${attempts}/${MAX_ATTEMPTS} in ${wait}ms (code: ${code}, reason: "${reason || "none"}")`
        );
        showReconnectToast(attempts, MAX_ATTEMPTS, wait);
        reconnectTimer = setTimeout(() => {
          try {
            const u = new URL(location.href);
            u.searchParams.set("_mgtp", Date.now().toString());
            if (isDiscord && isIframe) {
              try {
                targetWindow3.parent.location.reload();
              } catch (e) {
                location.replace(u.toString());
              }
            } else if (isMobile) {
              location.href = u.toString();
            } else {
              location.replace(u.toString());
            }
          } catch (e) {
            productionError2("[WebSocket] Reload failed:", e);
            location.href = location.href + "?_t=" + Date.now();
          }
        }, wait);
      }
      targetWindow3.WebSocket = function(url, protocols) {
        const ws = new Native(url, protocols);
        ws.addEventListener("open", () => {
          productionLog3("[WebSocket] Connection established successfully");
          attempts = 0;
          userNotified = false;
          const toast2 = targetDocument2.getElementById("mga-reconnect-toast");
          if (toast2) toast2.remove();
        });
        ws.addEventListener("close", (e) => {
          productionLog3(`[WebSocket] Closed - Code: ${e.code}, Clean: ${e.wasClean}, Reason: "${e.reason || "none"}"`);
          scheduleReload(e.code, e.wasClean, e.reason);
        });
        ws.addEventListener("error", (e) => {
          productionError2("[WebSocket] Error detected:", e);
        });
        return ws;
      };
      Object.setPrototypeOf(targetWindow3.WebSocket, Native);
      targetWindow3.WebSocket.prototype = Native.prototype;
      targetWindow3.WebSocket.__mgtoolsPatched = true;
      targetWindow3.addEventListener("online", () => {
        productionLog3("[Network] Back online - reducing reconnect attempt counter");
        attempts = Math.max(0, attempts - 2);
        const toast2 = targetDocument2.getElementById("mga-reconnect-toast");
        if (toast2) toast2.remove();
      });
      targetWindow3.addEventListener("offline", () => {
        productionWarn3("[Network] Offline detected - pausing reconnection attempts");
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        const toast2 = targetDocument2.getElementById("mga-reconnect-toast");
        if (toast2) {
          toast2.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 24px;">\u{1F4E1}</div>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 4px;">Network Offline</div>
                            <div style="font-size: 12px; opacity: 0.9;">
                                Reconnection paused<br>Waiting for network...
                            </div>
                        </div>
                    </div>
                `;
        }
      });
      productionLog3("\u2705 [WebSocket] Enhanced auto-reconnect system initialized (max attempts: " + MAX_ATTEMPTS + ")");
    })();
    (function() {
      let updateDetected = false;
      function checkForGameUpdatePopup() {
        if (updateDetected) return false;
        const popup = targetDocument2.querySelector('section.chakra-modal__content[role="alertdialog"]');
        if (!popup) return false;
        if (popup.closest(".mga-overlay, .mgh-sidebar, .mgh-dock, .mga-popout")) {
          return false;
        }
        const header = popup.querySelector("header.chakra-modal__header");
        if (header && /game update available/i.test(header.textContent)) {
          updateDetected = true;
          productionLog3("[DOM] Game update popup detected - attempting auto-click CONTINUE button");
          const continueBtn = popup.querySelector("button");
          if (continueBtn && /continue/i.test(continueBtn.textContent)) {
            productionLog3("[DOM] Clicking CONTINUE button...");
            continueBtn.click();
            setTimeout(() => {
              productionLog3("[DOM] CONTINUE clicked - triggering refresh");
              targetWindow3.location.reload();
            }, 500);
          } else {
            productionLog3("[DOM] CONTINUE button not found - proceeding with immediate refresh");
            targetWindow3.location.reload();
          }
          return true;
        }
        return false;
      }
      const observer = new MutationObserver(() => {
        if (!updateDetected) {
          checkForGameUpdatePopup();
        }
      });
      observer.observe(targetDocument2.body, { childList: true, subtree: true });
      setInterval(checkForGameUpdatePopup, 1e4);
      productionLog3("\u2705 [DOM] Game update popup monitor initialized");
    })();
    const LOG_MAIN = "MGA_petAbilityLogs";
    const LOG_ARCH = "MGA_petAbilityLogs_archive";
    const FLAG = "MGA_logs_manually_cleared";
    function gmGet(k, d2 = null) {
      try {
        const raw = gmGetValue ? gmGetValue(k, null) : null;
        if (raw == null) return d2;
        return typeof raw === "string" ? JSON.parse(raw) : raw;
      } catch (e) {
        return d2;
      }
    }
    function gmSet(k, v) {
      try {
        if (gmSetValue) gmSetValue(k, JSON.stringify(v));
      } catch (e) {
      }
    }
    try {
      const _get = Storage.prototype.getItem;
      if (!_get.__mgtoolsPatched) {
        Storage.prototype.getItem = function(k) {
          if ((k === LOG_MAIN || k === LOG_ARCH) && localStorage.getItem(FLAG) === "true") return "[]";
          return _get.apply(this, arguments);
        };
        Storage.prototype.getItem.__mgtoolsPatched = true;
      }
    } catch (e) {
    }
    try {
      if (gmGetValue && !gmGetValue.__mgtoolsPatched) {
        const _gm = gmGetValue;
        targetWindow3.GM_getValue = function(k, d2) {
          if ((k === LOG_MAIN || k === LOG_ARCH) && localStorage.getItem(FLAG) === "true") return "[]";
          return _gm.apply(this, arguments);
        };
        targetWindow3.GM_getValue.__mgtoolsPatched = true;
      }
    } catch (e) {
    }
    try {
      if (gmSetValue && !gmSetValue.__mgtoolsPatched) {
        const _gm = gmSetValue;
        targetWindow3.GM_setValue = function(k, v) {
          if (k === LOG_MAIN) {
            try {
              const arr = Array.isArray(v) ? v : typeof v === "string" ? JSON.parse(v) : [];
              if (arr && arr.length) localStorage.removeItem(FLAG);
            } catch (err) {
            }
          }
          return _gm.apply(this, arguments);
        };
        targetWindow3.GM_setValue.__mgtoolsPatched = true;
      }
    } catch (e) {
    }
    function hardClear() {
      try {
        localStorage.setItem(FLAG, "true");
        gmSet(LOG_MAIN, []);
        gmSet(LOG_ARCH, []);
        try {
          localStorage.removeItem(LOG_MAIN);
          localStorage.removeItem(LOG_ARCH);
        } catch (e) {
        }
        if (targetWindow3.UnifiedState?.data) targetWindow3.UnifiedState.data.petAbilityLogs = [];
        if (Array.isArray(targetWindow3.petAbilityLogs)) targetWindow3.petAbilityLogs.length = 0;
      } catch (e) {
        console.error("[MGTools] hardClear logs failed", e);
      }
    }
    targetWindow3.MGTOOLS_hardClearAbilityLogs = hardClear;
    targetDocument2.addEventListener(
      "click",
      (ev) => {
        const t = ev.target && ev.target.closest(
          '#clear-ability-logs,[data-role="clear-ability-logs"],[data-action="clear-ability-logs"],[data-mga-clear-logs],#mga-clear-logs'
        );
        if (t) {
          hardClear();
        }
      },
      true
    );
    productionLog3("\u2705 [MGTP] Overlay system initialized successfully");
  }

  // src/features/abilities/abilities-data.js
  var abilities_data_exports = {};
  __export(abilities_data_exports, {
    KNOWN_ABILITY_TYPES: () => KNOWN_ABILITY_TYPES3,
    categorizeAbility: () => categorizeAbility2,
    categorizeAbilityToFilterKey: () => categorizeAbilityToFilterKey2,
    isKnownAbilityType: () => isKnownAbilityType3,
    normalizeAbilityName: () => normalizeAbilityName3
  });
  var KNOWN_ABILITY_TYPES3 = [
    // XP Boosts
    "XP Boost I",
    "XP Boost II",
    "XP Boost III",
    "Hatch XP Boost I",
    "Hatch XP Boost II",
    // Crop Size Boosts
    "Crop Size Boost I",
    "Crop Size Boost II",
    // Selling
    "Sell Boost I",
    "Sell Boost II",
    "Sell Boost III",
    "Coin Finder I",
    "Coin Finder II",
    // Harvesting
    "Harvesting",
    "Auto Harvest",
    // Growth Speed
    "Plant Growth Boost I",
    "Plant Growth Boost II",
    "Plant Growth Boost III",
    "Egg Growth Boost I",
    "Egg Growth Boost II",
    // Seeds
    "Seed Finder I",
    "Seed Finder II",
    "Special Mutations",
    // Other
    "Hunger Boost I",
    "Hunger Boost II",
    "Max Strength Boost I",
    "Max Strength Boost II"
  ];
  function normalizeAbilityName3(name, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      logDebug: logDebug2 = typeof window !== "undefined" && window.logDebug ? window.logDebug : () => {
      }
    } = dependencies;
    if (!name || typeof name !== "string") return name;
    const normalized = name.replace(/([a-z])III$/i, "$1 III").replace(/([a-z])II$/i, "$1 II").replace(/([a-z])I$/i, "$1 I").replace(/produce\s*scale\s*boost/gi, "Crop Size Boost").trim();
    if (normalized !== name && UnifiedState3?.data?.settings?.debugMode) {
      logDebug2("ABILITY-LOGS", `\u{1F4DD} Normalized ability name: "${name}" \u2192 "${normalized}"`);
    }
    return normalized;
  }
  function isKnownAbilityType3(abilityType) {
    if (!abilityType) return false;
    return KNOWN_ABILITY_TYPES3.includes(abilityType);
  }
  function categorizeAbility2(abilityType) {
    const cleanType = (abilityType || "").toLowerCase();
    if (cleanType.includes("xp") && cleanType.includes("boost")) {
      return "xp-boost";
    }
    if (cleanType.includes("hatch") && cleanType.includes("xp")) {
      return "xp-boost";
    }
    if (cleanType.includes("crop") && (cleanType.includes("size") || cleanType.includes("scale"))) {
      return "crop-size-boost";
    }
    if (cleanType.includes("sell") && cleanType.includes("boost")) {
      return "selling";
    }
    if (cleanType.includes("refund")) {
      return "selling";
    }
    if (cleanType.includes("double") && cleanType.includes("harvest")) {
      return "harvesting";
    }
    if (cleanType.includes("growth") && cleanType.includes("boost")) {
      return "growth-speed";
    }
    if (cleanType.includes("plant") && cleanType.includes("growth")) {
      return "growth-speed";
    }
    if (cleanType.includes("egg") && cleanType.includes("growth")) {
      return "growth-speed";
    }
    if (cleanType.includes("rainbow") || cleanType.includes("gold")) {
      return "special-mutations";
    }
    return "other";
  }
  function categorizeAbilityToFilterKey2(abilityType, dependencies = {}) {
    const { MGA_AbilityCache: MGA_AbilityCache2 = typeof window !== "undefined" && window.MGA_AbilityCache } = dependencies;
    if (MGA_AbilityCache2 && MGA_AbilityCache2.categories.has(abilityType)) {
      return MGA_AbilityCache2.categories.get(abilityType);
    }
    const cleanType = (abilityType || "").toLowerCase();
    let category = "other";
    if (cleanType.includes("xp") && cleanType.includes("boost")) category = "xpBoost";
    else if (cleanType.includes("hatch") && cleanType.includes("xp")) category = "xpBoost";
    else if (cleanType.includes("crop") && (cleanType.includes("size") || cleanType.includes("scale")))
      category = "cropSizeBoost";
    else if (cleanType.includes("sell") && cleanType.includes("boost")) category = "selling";
    else if (cleanType.includes("refund")) category = "selling";
    else if (cleanType.includes("double") && cleanType.includes("harvest")) category = "harvesting";
    else if (cleanType.includes("growth") && cleanType.includes("boost")) category = "growthSpeed";
    else if (cleanType.includes("rainbow") || cleanType.includes("gold")) category = "specialMutations";
    if (MGA_AbilityCache2) {
      MGA_AbilityCache2.categories.set(abilityType, category);
    }
    return category;
  }

  // src/features/abilities/abilities-utils.js
  var abilities_utils_exports = {};
  __export(abilities_utils_exports, {
    formatLogData: () => formatLogData2,
    formatRelativeTime: () => formatRelativeTime2,
    getAbilityExpectations: () => getAbilityExpectations3,
    getAllUniqueAbilities: () => getAllUniqueAbilities2,
    getAllUniquePets: () => getAllUniquePets2,
    shouldLogAbility: () => shouldLogAbility2
  });
  function formatRelativeTime2(timestamp, dependencies = {}) {
    const {
      Date: DateClass = typeof Date !== "undefined" ? Date : null,
      Math: MathClass = typeof Math !== "undefined" ? Math : null
    } = dependencies;
    const now = DateClass.now();
    const diff = now - timestamp;
    if (diff < 6e4) {
      const seconds = MathClass.floor(diff / 1e3);
      return `${seconds}s ago`;
    } else if (diff < 36e5) {
      const minutes = MathClass.floor(diff / 6e4);
      return `${minutes}m ago`;
    } else if (diff < 864e5) {
      const hours = MathClass.floor(diff / 36e5);
      return `${hours}h ago`;
    } else {
      return new DateClass(timestamp).toLocaleDateString();
    }
  }
  function formatLogData2(data) {
    if (!data || typeof data !== "object") return "";
    const formatted = Object.entries(data).filter(([_key, value]) => value !== null && value !== void 0).map(([key, value]) => `${key}: ${value}`).join(", ");
    return formatted.length > 60 ? formatted.substring(0, 60) + "..." : formatted;
  }
  function getAllUniquePets2(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const pets = /* @__PURE__ */ new Set();
    (UnifiedState3?.data?.petAbilityLogs || []).forEach((log) => {
      if (log.petName && log.petName !== "Test Pet") {
        pets.add(log.petName);
      }
    });
    return Array.from(pets).sort();
  }
  function getAllUniqueAbilities2(dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    const abilities = /* @__PURE__ */ new Set();
    (UnifiedState3?.data?.petAbilityLogs || []).forEach((log) => {
      if (log.abilityType) {
        abilities.add(log.abilityType);
      }
    });
    return Array.from(abilities).sort();
  }
  function shouldLogAbility2(abilityType, petName = null, dependencies = {}) {
    const { UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState } = dependencies;
    if (abilityType && (abilityType.includes("ProduceMutationBoost") || abilityType.includes("PetMutationBoost"))) {
      return false;
    }
    const mode = UnifiedState3?.data?.filterMode || "categories";
    if (mode === "custom") {
      return UnifiedState3?.data?.customMode?.selectedAbilities?.[abilityType] || false;
    }
    if (mode === "byPet") {
      if (!petName) return false;
      return UnifiedState3?.data?.petFilters?.selectedPets?.[petName] || false;
    }
    const category = categorizeAbilityToFilterKey2(abilityType);
    return UnifiedState3?.data?.abilityFilters?.[category] || false;
  }
  function getAbilityExpectations3(activePets, abilityName, minutesPerBase = 5, odds = 0.27, dependencies = {}) {
    const { Math: MathClass = typeof Math !== "undefined" ? Math : null } = dependencies;
    const pets = (activePets || []).filter((p) => p && p.hunger > 0 && p.abilities?.some((a) => a === abilityName));
    let expectedMinutesRemoved = 0;
    pets.forEach((p) => {
      const base = MathClass.min(MathClass.floor((p.xp || 0) / (100 * 3600) * 30), 30) + MathClass.floor(((p.targetScale || 1) - 1) / (2.5 - 1) * 20 + 80) - 30;
      expectedMinutesRemoved += base / 100 * minutesPerBase * 60 * (1 - MathClass.pow(1 - odds * base / 100, 1 / 60));
    });
    return {
      expectedMinutesRemoved
    };
  }

  // src/features/abilities/abilities-display.js
  var abilities_display_exports = {};
  __export(abilities_display_exports, {
    MGA_AbilityCache: () => MGA_AbilityCache,
    initCacheClearInterval: () => initCacheClearInterval,
    populateFilterModeContent: () => populateFilterModeContent,
    populateIndividualAbilities: () => populateIndividualAbilities2,
    populatePetSpeciesList: () => populatePetSpeciesList2,
    selectAllFilters: () => selectAllFilters2,
    selectNoneFilters: () => selectNoneFilters2,
    switchFilterMode: () => switchFilterMode,
    updateAbilityLogDisplay: () => updateAbilityLogDisplay2,
    updateAllAbilityLogDisplays: () => updateAllAbilityLogDisplays2,
    updateAllLogVisibility: () => updateAllLogVisibility2,
    updateLogVisibility: () => updateLogVisibility2
  });
  var MGA_AbilityCache = {
    categories: /* @__PURE__ */ new Map(),
    timestamps: /* @__PURE__ */ new Map(),
    normalizedNames: /* @__PURE__ */ new Map(),
    lastTimestampUpdate: 0
  };
  function initCacheClearInterval(dependencies = {}) {
    const {
      setInterval: setIntervalFn = typeof setInterval !== "undefined" ? setInterval : null,
      Date: DateClass = typeof Date !== "undefined" ? Date : null
    } = dependencies;
    if (!setIntervalFn) return null;
    return setIntervalFn(() => {
      MGA_AbilityCache.timestamps.clear();
      MGA_AbilityCache.lastTimestampUpdate = DateClass.now();
    }, 6e4);
  }
  function formatTimestamp2(timestamp, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      Date: DateClass = typeof Date !== "undefined" ? Date : null
    } = dependencies;
    const useDetailedTimestamps = UnifiedState3?.data?.settings?.detailedTimestamps;
    if (useDetailedTimestamps) {
      const date = new DateClass(timestamp);
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      const seconds = String(date.getSeconds()).padStart(2, "0");
      return `${hours}:${minutes}:${seconds}`;
    }
    return formatRelativeTime2(timestamp, dependencies);
  }
  function updateAbilityLogDisplay2(context = null, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_getAllLogs: MGA_getAllLogs2 = typeof window !== "undefined" && window.MGA_getAllLogs,
      shouldLogAbility: shouldLogAbility3 = typeof window !== "undefined" && window.shouldLogAbility,
      debugLog: debugLog3 = typeof window !== "undefined" && window.debugLog ? window.debugLog : () => {
      },
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      CONFIG: CONFIG2 = typeof window !== "undefined" && window.CONFIG,
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      } },
      Date: DateClass = typeof Date !== "undefined" ? Date : null
    } = dependencies;
    const ctx = context || targetDocument2;
    const abilityLogs = ctx.querySelector("#ability-logs");
    if (!abilityLogs) {
      debugLog3("ABILITY_LOGS", "No ability logs element found in context", {
        isDocument: ctx === targetDocument2,
        className: ctx.className || "unknown"
      });
      return;
    }
    const isOverlay = ctx.classList?.contains("mga-overlay-content-only");
    const isDragInProgress = ctx.getAttribute?.("data-dragging") === "true";
    if (isOverlay && isDragInProgress) {
      debugLog3("ABILITY_LOGS", "Skipping content update during drag operation", {
        overlayId: ctx.id
      });
      return;
    }
    const logs = MGA_getAllLogs2 ? MGA_getAllLogs2() : UnifiedState3?.data?.petAbilityLogs || [];
    const filteredLogs = logs.filter((log) => {
      return shouldLogAbility3 ? shouldLogAbility3(log.abilityType, log.petName) : true;
    });
    debugLog3("ABILITY_LOGS", "Updating ability log display", {
      totalLogs: logs.length,
      filteredLogs: filteredLogs.length,
      filterMode: UnifiedState3?.data?.filterMode
    });
    if (CONFIG2?.DEBUG?.FLAGS?.FIX_VALIDATION) {
      consoleFn.log("[FIX_ABILITY_LOGS] Update called:", {
        totalLogs: logs.length,
        filteredLogs: filteredLogs.length,
        filterMode: UnifiedState3?.data?.filterMode,
        elementFound: !!abilityLogs,
        contextType: ctx === targetDocument2 ? "document" : "overlay"
      });
    }
    const htmlParts = [];
    filteredLogs.forEach((_log, index) => {
      const log = filteredLogs[index];
      const category = categorizeAbilityToFilterKey2(log.abilityType);
      const categoryData = {
        xpBoost: { icon: "\u{1F4AB}", color: "#4a9eff", label: "XP Boost" },
        cropSizeBoost: { icon: "\u{1F4C8}", color: "#10b981", label: "Crop Size" },
        selling: { icon: "\u{1F4B0}", color: "#f59e0b", label: "Selling" },
        harvesting: { icon: "\u{1F33E}", color: "#84cc16", label: "Harvesting" },
        growthSpeed: { icon: "\u{1F422}", color: "#06b6d4", label: "Growth Speed" },
        specialMutations: { icon: "\u{1F308}\u2728", color: "#8b5cf6", label: "Special" },
        other: { icon: "\u{1F527}", color: "#6b7280", label: "Other" }
      };
      const catData = categoryData[category] || categoryData.other;
      const formattedTime = formatTimestamp2(log.timestamp, dependencies);
      const isRecent = DateClass.now() - log.timestamp < 1e4;
      const displayAbilityName = normalizeAbilityName3(log.abilityType);
      htmlParts.push(`
              <div class="mga-log-item ${isRecent ? "mga-log-recent" : ""}" data-category="${category}" data-ability-type="${log.abilityType}" data-pet-name="${log.petName}" style="--category-color: ${catData.color}">
                  <div class="mga-log-header">
                      <span class="mga-log-icon">${catData.icon}</span>
                      <span class="mga-log-meta">
                          <span class="mga-log-pet" style="color: ${catData.color}; font-weight: 600;">${log.petName}</span>
                          <span class="mga-log-time">${formattedTime}</span>
                      </span>
                  </div>
                  <div class="mga-log-ability">${displayAbilityName}</div>
                  ${log.data && Object.keys(log.data).length > 0 ? `<div class="mga-log-details">${formatLogData2(log.data)}</div>` : ""}
              </div>
          `);
    });
    const fragment = targetDocument2.createDocumentFragment();
    const tempContainer = targetDocument2.createElement("div");
    if (htmlParts.length === 0) {
      const mode = UnifiedState3?.data?.filterMode || "categories";
      const modeText = mode === "categories" ? "category filters" : mode === "byPet" ? "pet filters" : "custom filters";
      tempContainer.innerHTML = `<div class="mga-log-empty">
              <div style="color: #888; text-align: center; padding: 20px;">
                  <div style="font-size: 24px; margin-bottom: 8px;">\u{1F4CB}</div>
                  <div>No abilities match the current ${modeText}</div>
                  <div style="font-size: 11px; margin-top: 4px; opacity: 0.7;">Try adjusting your filter settings</div>
              </div>
          </div>`;
    } else {
      tempContainer.innerHTML = htmlParts.join("");
      setTimeout(() => {
        if (abilityLogs.scrollHeight > abilityLogs.clientHeight) {
          abilityLogs.scrollTop = 0;
        }
      }, 100);
    }
    while (tempContainer.firstChild) {
      fragment.appendChild(tempContainer.firstChild);
    }
    abilityLogs.innerHTML = "";
    abilityLogs.appendChild(fragment);
    if (!ctx.querySelector("#mga-log-styles")) {
      const logStyles = targetDocument2.createElement("style");
      logStyles.id = "mga-log-styles";
      logStyles.textContent = `
              .mga-log-item {
                  margin: 4px 0;
                  padding: 8px;
                  border-radius: 4px;
                  background: rgba(255, 255, 255, 0.02);
                  border-left: 2px solid var(--category-color, #6b7280);
                  transition: all 0.2s ease;
                  font-size: 11px;
                  line-height: 1.3;
              }

              .mga-log-item:hover {
                  background: rgba(255, 255, 255, 0.05);
                  transform: translateX(2px);
              }

              .mga-log-recent {
                  background: rgba(74, 158, 255, 0.30);
                  border-color: #4a9eff;
                  box-shadow: 0 0 8px rgba(74, 158, 255, 0.3);
                  animation: mgaLogPulse 2s ease-out;
              }

              @keyframes mgaLogPulse {
                  0% { box-shadow: 0 0 8px rgba(74, 158, 255, 0.6); }
                  100% { box-shadow: 0 0 8px rgba(74, 158, 255, 0.3); }
              }

              .mga-log-header {
                  display: flex;
                  align-items: center;
                  gap: 6px;
                  margin-bottom: 2px;
              }

              .mga-log-icon {
                  font-size: 14px;
              }

              .mga-log-meta {
                  display: flex;
                  gap: 8px;
                  align-items: center;
                  flex: 1;
              }

              .mga-log-pet {
                  font-weight: 600;
              }

              .mga-log-time {
                  color: #999;
                  font-size: 10px;
              }

              .mga-log-ability {
                  margin-left: 20px;
                  color: #ddd;
              }

              .mga-log-details {
                  margin-left: 20px;
                  font-size: 10px;
                  color: #999;
                  margin-top: 2px;
              }
          `;
      ctx.appendChild(logStyles);
    }
  }
  function updateAllAbilityLogDisplays2(force = false, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      lastLogCount = typeof window !== "undefined" && window.lastLogCount,
      debugLog: debugLog3 = typeof window !== "undefined" && window.debugLog ? window.debugLog : () => {
      },
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      CONFIG: CONFIG2 = typeof window !== "undefined" && window.CONFIG,
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      } }
    } = dependencies;
    const currentLogCount = UnifiedState3?.data?.petAbilityLogs?.length || 0;
    if (CONFIG2?.DEBUG?.FLAGS?.FIX_VALIDATION) {
      consoleFn.log("[FIX_ABILITY_LOGS] Update called:", {
        force,
        currentLogCount,
        lastLogCount,
        willUpdate: force || currentLogCount !== lastLogCount,
        petAbilityLogsExists: !!UnifiedState3?.data?.petAbilityLogs
      });
    }
    if (!force && currentLogCount === lastLogCount) {
      debugLog3("ABILITY_LOGS", "Skipping update - no new logs");
      return;
    }
    if (typeof window !== "undefined" && window.lastLogCount !== void 0) {
      window.lastLogCount = currentLogCount;
    }
    debugLog3("ABILITY_LOGS", "Updating ability logs across all contexts");
    updateAbilityLogDisplay2(targetDocument2, dependencies);
    const allOverlays = targetDocument2.querySelectorAll(".mga-overlay-content-only, .mga-overlay, .mgh-popout");
    allOverlays.forEach((overlay) => {
      if (overlay.offsetParent === null) return;
      if (overlay.querySelector("#ability-logs")) {
        updateAbilityLogDisplay2(overlay, dependencies);
        debugLog3("ABILITY_LOGS", "Updated overlay/widget ability logs", {
          overlayId: overlay.id || overlay.className
        });
      }
    });
  }
  function updateLogVisibility2(context = null, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      debugLog: debugLog3 = typeof window !== "undefined" && window.debugLog ? window.debugLog : () => {
      }
    } = dependencies;
    const ctx = context || (typeof document !== "undefined" ? document : null);
    const abilityLogs = ctx.querySelector("#ability-logs");
    if (!abilityLogs) return;
    const filterMode = UnifiedState3?.data?.filterMode || "categories";
    const logItems = abilityLogs.querySelectorAll(".mga-log-item");
    debugLog3("ABILITY_LOGS", "Updating log visibility via CSS", {
      filterMode,
      totalItems: logItems.length
    });
    logItems.forEach((item) => {
      let shouldShow = false;
      if (filterMode === "categories") {
        const category = item.dataset.category;
        shouldShow = UnifiedState3?.data?.abilityFilters?.[category] || false;
      } else if (filterMode === "byPet") {
        const petName = item.dataset.petName;
        shouldShow = UnifiedState3?.data?.petFilters?.selectedPets?.[petName] || false;
      } else if (filterMode === "custom") {
        const abilityType = item.dataset.abilityType;
        shouldShow = UnifiedState3?.data?.customMode?.selectedAbilities?.[abilityType] || false;
      }
      item.style.display = shouldShow ? "" : "none";
    });
  }
  function updateAllLogVisibility2(dependencies = {}) {
    const {
      debugLog: debugLog3 = typeof window !== "undefined" && window.debugLog ? window.debugLog : () => {
      },
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null
    } = dependencies;
    debugLog3("ABILITY_LOGS", "Updating log visibility across all contexts");
    updateLogVisibility2(targetDocument2, dependencies);
    const allOverlays = targetDocument2.querySelectorAll(".mga-overlay-content-only, .mga-overlay");
    allOverlays.forEach((overlay) => {
      if (overlay.offsetParent === null) return;
      if (overlay.querySelector("#ability-logs")) {
        updateLogVisibility2(overlay, dependencies);
      }
    });
  }
  function switchFilterMode(mode, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      document: doc = typeof document !== "undefined" ? document : null
    } = dependencies;
    if (UnifiedState3) {
      UnifiedState3.data.filterMode = mode;
    }
    if (MGA_saveJSON2) {
      MGA_saveJSON2("MGA_filterMode", mode);
    }
    targetDocument2.querySelectorAll('[id^="filter-mode-"]').forEach((btn) => btn.classList.remove("active"));
    const modeId = mode === "byPet" ? "bypet" : mode;
    doc.getElementById(`filter-mode-${modeId}`)?.classList.add("active");
    const descriptions = {
      categories: "\u{1F4C2} Filter by ability categories",
      byPet: "\u{1F43E} Filter by pet species",
      custom: "\u2699\uFE0F Filter by individual abilities"
    };
    const descEl = doc.getElementById("filter-mode-description");
    if (descEl) descEl.textContent = descriptions[mode] || "";
    const categoryFilters = doc.getElementById("category-filters");
    const petFilters = doc.getElementById("pet-filters");
    const customFilters = doc.getElementById("custom-filters");
    if (categoryFilters) categoryFilters.style.display = mode === "categories" ? "grid" : "none";
    if (petFilters) petFilters.style.display = mode === "byPet" ? "block" : "none";
    if (customFilters) customFilters.style.display = mode === "custom" ? "block" : "none";
    populateFilterModeContent(mode, dependencies);
    updateAllLogVisibility2(dependencies);
  }
  function populateFilterModeContent(mode, dependencies = {}) {
    if (mode === "byPet") {
      populatePetSpeciesList2(dependencies);
    } else if (mode === "custom") {
      populateIndividualAbilities2(dependencies);
    }
  }
  function populatePetSpeciesList2(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      document: doc = typeof document !== "undefined" ? document : null
    } = dependencies;
    const container = doc.getElementById("pet-species-list");
    if (!container) return;
    const pets = getAllUniquePets2(dependencies);
    container.innerHTML = "";
    if (pets.length === 0) {
      container.innerHTML = '<div style="color: #888; text-align: center;">No pet species found in logs</div>';
      return;
    }
    pets.forEach((pet) => {
      const label = targetDocument2.createElement("label");
      label.className = "mga-checkbox-group";
      label.style.display = "block";
      label.style.marginBottom = "4px";
      const checkbox = targetDocument2.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "mga-checkbox";
      checkbox.checked = UnifiedState3?.data?.petFilters?.selectedPets?.[pet] || false;
      checkbox.addEventListener("change", (e) => {
        if (UnifiedState3?.data?.petFilters?.selectedPets) {
          UnifiedState3.data.petFilters.selectedPets[pet] = e.target.checked;
        }
        if (MGA_saveJSON2) {
          MGA_saveJSON2("MGA_petFilters", UnifiedState3?.data?.petFilters);
        }
        updateAllLogVisibility2(dependencies);
      });
      const span = targetDocument2.createElement("span");
      span.className = "mga-label";
      span.textContent = ` ${pet}`;
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }
  function populateIndividualAbilities2(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null,
      document: doc = typeof document !== "undefined" ? document : null
    } = dependencies;
    const container = doc.getElementById("individual-abilities-list");
    if (!container) return;
    const abilities = getAllUniqueAbilities2(dependencies);
    container.innerHTML = "";
    if (abilities.length === 0) {
      container.innerHTML = '<div style="color: #888; text-align: center;">No individual abilities found in logs</div>';
      return;
    }
    abilities.forEach((ability) => {
      const label = targetDocument2.createElement("label");
      label.className = "mga-checkbox-group";
      label.style.display = "block";
      label.style.marginBottom = "4px";
      const checkbox = targetDocument2.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "mga-checkbox";
      checkbox.checked = UnifiedState3?.data?.customMode?.selectedAbilities?.[ability] || false;
      checkbox.addEventListener("change", (e) => {
        if (UnifiedState3?.data?.customMode?.selectedAbilities) {
          UnifiedState3.data.customMode.selectedAbilities[ability] = e.target.checked;
        }
        if (MGA_saveJSON2) {
          MGA_saveJSON2("MGA_customMode", UnifiedState3?.data?.customMode);
        }
        updateAllLogVisibility2(dependencies);
      });
      const span = targetDocument2.createElement("span");
      span.className = "mga-label";
      span.textContent = ` ${normalizeAbilityName3(ability, dependencies)}`;
      label.appendChild(checkbox);
      label.appendChild(span);
      container.appendChild(label);
    });
  }
  function selectAllFilters2(mode, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null
    } = dependencies;
    if (mode === "categories") {
      Object.keys(UnifiedState3?.data?.abilityFilters || {}).forEach((key) => {
        if (UnifiedState3?.data?.abilityFilters) {
          UnifiedState3.data.abilityFilters[key] = true;
        }
        const checkbox = targetDocument2.querySelector(`[data-filter="${key}"]`);
        if (checkbox) checkbox.checked = true;
      });
      if (MGA_saveJSON2) {
        MGA_saveJSON2("MGA_abilityFilters", UnifiedState3?.data?.abilityFilters);
      }
    } else if (mode === "byPet") {
      const pets = getAllUniquePets2(dependencies);
      pets.forEach((pet) => {
        if (UnifiedState3?.data?.petFilters?.selectedPets) {
          UnifiedState3.data.petFilters.selectedPets[pet] = true;
        }
      });
      if (MGA_saveJSON2) {
        MGA_saveJSON2("MGA_petFilters", UnifiedState3?.data?.petFilters);
      }
      populatePetSpeciesList2(dependencies);
    } else if (mode === "custom") {
      const abilities = getAllUniqueAbilities2(dependencies);
      abilities.forEach((ability) => {
        if (UnifiedState3?.data?.customMode?.selectedAbilities) {
          UnifiedState3.data.customMode.selectedAbilities[ability] = true;
        }
      });
      if (MGA_saveJSON2) {
        MGA_saveJSON2("MGA_customMode", UnifiedState3?.data?.customMode);
      }
      populateIndividualAbilities2(dependencies);
    }
    updateAllLogVisibility2(dependencies);
  }
  function selectNoneFilters2(mode, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      targetDocument: targetDocument2 = typeof document !== "undefined" ? document : null
    } = dependencies;
    if (mode === "categories") {
      Object.keys(UnifiedState3?.data?.abilityFilters || {}).forEach((key) => {
        if (UnifiedState3?.data?.abilityFilters) {
          UnifiedState3.data.abilityFilters[key] = false;
        }
        const checkbox = targetDocument2.querySelector(`[data-filter="${key}"]`);
        if (checkbox) checkbox.checked = false;
      });
      if (MGA_saveJSON2) {
        MGA_saveJSON2("MGA_abilityFilters", UnifiedState3?.data?.abilityFilters);
      }
    } else if (mode === "byPet") {
      if (UnifiedState3?.data?.petFilters) {
        UnifiedState3.data.petFilters.selectedPets = {};
      }
      if (MGA_saveJSON2) {
        MGA_saveJSON2("MGA_petFilters", UnifiedState3?.data?.petFilters);
      }
      populatePetSpeciesList2(dependencies);
    } else if (mode === "custom") {
      if (UnifiedState3?.data?.customMode) {
        UnifiedState3.data.customMode.selectedAbilities = {};
      }
      if (MGA_saveJSON2) {
        MGA_saveJSON2("MGA_customMode", UnifiedState3?.data?.customMode);
      }
      populateIndividualAbilities2(dependencies);
    }
    updateAllLogVisibility2(dependencies);
  }

  // src/features/abilities/abilities-handlers.js
  var abilities_handlers_exports = {};
  __export(abilities_handlers_exports, {
    setupAbilitiesTabHandlers: () => setupAbilitiesTabHandlers2
  });
  function setupAbilitiesTabHandlers2(context = null, dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      MGA_saveJSON: MGA_saveJSON2 = typeof window !== "undefined" && window.MGA_saveJSON,
      MGA_loadJSON: MGA_loadJSON2 = typeof window !== "undefined" && window.MGA_loadJSON,
      debugLog: debugLog3 = typeof window !== "undefined" && window.debugLog ? window.debugLog : () => {
      },
      logDebug: logDebug2 = typeof window !== "undefined" && window.logDebug ? window.logDebug : () => {
      },
      logWarn: logWarn3 = typeof window !== "undefined" && window.logWarn ? window.logWarn : () => {
      },
      productionLog: productionLog3 = typeof window !== "undefined" && window.productionLog ? window.productionLog : () => {
      },
      productionWarn: productionWarn3 = typeof window !== "undefined" && window.productionWarn ? window.productionWarn : () => {
      },
      updateTabContent = typeof window !== "undefined" && window.updateTabContent,
      showNotificationToast: showNotificationToast2 = typeof window !== "undefined" && window.showNotificationToast,
      exportAbilityLogs: exportAbilityLogs2 = typeof window !== "undefined" && window.exportAbilityLogs,
      MGA_diagnoseAbilityLogStorage: MGA_diagnoseAbilityLogStorage2 = typeof window !== "undefined" && window.MGA_diagnoseAbilityLogStorage,
      GM_getValue: GM_getValue2,
      // Passed via dependencies - no default to avoid circular reference
      GM_setValue: GM_setValue2,
      // Passed via dependencies - no default to avoid circular reference
      window: win = typeof window !== "undefined" ? window : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" && window.targetWindow ? window.targetWindow : null,
      localStorage: storage = typeof localStorage !== "undefined" ? localStorage : null,
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      } },
      Date: DateClass = typeof Date !== "undefined" ? Date : null,
      setTimeout: setTimeoutFn = typeof setTimeout !== "undefined" ? setTimeout : null
    } = dependencies;
    const ctx = context || (typeof document !== "undefined" ? document : null);
    debugLog3("ABILITY_LOGS", "Setting up abilities tab handlers with context", {
      isDocument: ctx === (typeof document !== "undefined" ? document : null),
      className: ctx.className || "document"
    });
    const categoriesBtn = ctx.querySelector("#filter-mode-categories");
    const byPetBtn = ctx.querySelector("#filter-mode-bypet");
    const customBtn = ctx.querySelector("#filter-mode-custom");
    if (categoriesBtn && !categoriesBtn.hasAttribute("data-handler-setup")) {
      categoriesBtn.setAttribute("data-handler-setup", "true");
      categoriesBtn.addEventListener("click", () => switchFilterMode("categories", dependencies));
    }
    if (byPetBtn && !byPetBtn.hasAttribute("data-handler-setup")) {
      byPetBtn.setAttribute("data-handler-setup", "true");
      byPetBtn.addEventListener("click", () => switchFilterMode("byPet", dependencies));
    }
    if (customBtn && !customBtn.hasAttribute("data-handler-setup")) {
      customBtn.setAttribute("data-handler-setup", "true");
      customBtn.addEventListener("click", () => switchFilterMode("custom", dependencies));
    }
    const selectAllBtn = ctx.querySelector("#select-all-filters");
    const selectNoneBtn = ctx.querySelector("#select-none-filters");
    if (selectAllBtn && !selectAllBtn.hasAttribute("data-handler-setup")) {
      selectAllBtn.setAttribute("data-handler-setup", "true");
      selectAllBtn.addEventListener("click", () => {
        const mode = UnifiedState3?.data?.filterMode || "categories";
        selectAllFilters2(mode, dependencies);
      });
    }
    if (selectNoneBtn && !selectNoneBtn.hasAttribute("data-handler-setup")) {
      selectNoneBtn.setAttribute("data-handler-setup", "true");
      selectNoneBtn.addEventListener("click", () => {
        const mode = UnifiedState3?.data?.filterMode || "categories";
        selectNoneFilters2(mode, dependencies);
      });
    }
    ctx.querySelectorAll("#category-filters .mga-checkbox[data-filter]").forEach((checkbox) => {
      if (!checkbox.hasAttribute("data-handler-setup")) {
        checkbox.setAttribute("data-handler-setup", "true");
        checkbox.addEventListener("change", (e) => {
          const filterKey = e.target.dataset.filter;
          if (UnifiedState3?.data?.abilityFilters) {
            UnifiedState3.data.abilityFilters[filterKey] = e.target.checked;
          }
          if (MGA_saveJSON2) {
            MGA_saveJSON2("MGA_abilityFilters", UnifiedState3?.data?.abilityFilters);
          }
          updateAllLogVisibility2(dependencies);
          debugLog3("ABILITY_LOGS", `Filter ${filterKey} changed to ${e.target.checked}, updated visibility via CSS`);
        });
      }
    });
    const clearLogsBtn = ctx.querySelector("#clear-logs-btn");
    if (clearLogsBtn && !clearLogsBtn.hasAttribute("data-handler-setup")) {
      clearLogsBtn.setAttribute("data-handler-setup", "true");
      clearLogsBtn.addEventListener("click", () => {
        logDebug2("ABILITY-LOGS", "Starting comprehensive ability log clear...");
        const beforeClear = {
          memory: UnifiedState3?.data?.petAbilityLogs?.length || 0,
          gmMain: (() => {
            try {
              const v = GM_getValue2 ? GM_getValue2("MGA_petAbilityLogs", null) : null;
              return v ? JSON.parse(v).length : 0;
            } catch (_e) {
              return 0;
            }
          })(),
          gmArchive: (() => {
            try {
              const v = GM_getValue2 ? GM_getValue2("MGA_petAbilityLogs_archive", null) : null;
              return v ? JSON.parse(v).length : 0;
            } catch (_e) {
              return 0;
            }
          })(),
          lsMain: (() => {
            try {
              const v = win?.localStorage?.getItem("MGA_petAbilityLogs");
              return v ? JSON.parse(v).length : 0;
            } catch (_e) {
              return 0;
            }
          })(),
          lsArchive: (() => {
            try {
              const v = win?.localStorage?.getItem("MGA_petAbilityLogs_archive");
              return v ? JSON.parse(v).length : 0;
            } catch (_e) {
              return 0;
            }
          })()
        };
        logDebug2("ABILITY-LOGS", "\u{1F4CA} BEFORE CLEAR - Log counts:", beforeClear);
        if (UnifiedState3?.data?.petAbilityLogs?.length > 0) {
          logDebug2("ABILITY-LOGS", "\u{1F4CB} Current logs in memory:");
          UnifiedState3.data.petAbilityLogs.forEach((log, i) => {
            logDebug2(
              "ABILITY-LOGS",
              `  ${i + 1}. ${log.abilityType} - ${log.petName} - ${new DateClass(log.timestamp).toLocaleString()}`
            );
          });
        }
        if (UnifiedState3?.data) {
          UnifiedState3.data.petAbilityLogs = [];
        }
        logDebug2("ABILITY-LOGS", "  \u2713 Cleared UnifiedState memory");
        if (MGA_saveJSON2) {
          MGA_saveJSON2("MGA_petAbilityLogs", []);
          MGA_saveJSON2("MGA_petAbilityLogs_archive", []);
        }
        logDebug2("ABILITY-LOGS", "  \u2713 Cleared GM storage (main + archive)");
        try {
          win?.localStorage?.removeItem("MGA_petAbilityLogs");
          win?.localStorage?.removeItem("MGA_petAbilityLogs_archive");
          logDebug2("ABILITY-LOGS", "  \u2713 Cleared window.localStorage");
        } catch (e) {
          logWarn3("ABILITY-LOGS", "  \u26A0\uFE0F Could not clear window.localStorage:", e.message);
        }
        try {
          if (targetWindow3 && targetWindow3 !== win) {
            targetWindow3.localStorage?.removeItem("MGA_petAbilityLogs");
            targetWindow3.localStorage?.removeItem("MGA_petAbilityLogs_archive");
            logDebug2("ABILITY-LOGS", "  \u2713 Cleared targetWindow.localStorage");
          }
        } catch (e) {
          logWarn3("ABILITY-LOGS", "  \u26A0\uFE0F Could not clear targetWindow.localStorage:", e.message);
        }
        try {
          if (typeof win?.petAbilityLogs !== "undefined") {
            win.petAbilityLogs = [];
            logDebug2("ABILITY-LOGS", "  \u2713 Cleared window.petAbilityLogs compatibility array");
          }
        } catch (e) {
          logWarn3("ABILITY-LOGS", "  \u26A0\uFE0F Could not clear compatibility array:", e.message);
        }
        const clearTimestamp = DateClass.now();
        storage?.setItem("MGA_logs_manually_cleared", clearTimestamp.toString());
        storage?.setItem("MGA_logs_clear_session", clearTimestamp.toString());
        try {
          if (GM_setValue2) {
            GM_setValue2("MGA_logs_manually_cleared", clearTimestamp.toString());
          }
        } catch (e) {
          logWarn3("ABILITY-LOGS", "  \u26A0\uFE0F Could not set GM clear flag:", e.message);
        }
        logDebug2("ABILITY-LOGS", "  \u2713 Set manual clear flags (session + GM + timestamp)");
        const verifyMain = MGA_loadJSON2 ? MGA_loadJSON2("MGA_petAbilityLogs", null) : null;
        const verifyArchive = MGA_loadJSON2 ? MGA_loadJSON2("MGA_petAbilityLogs_archive", null) : null;
        const verifyLS = win?.localStorage?.getItem("MGA_petAbilityLogs");
        const verifyCompat = typeof win?.petAbilityLogs !== "undefined" ? win.petAbilityLogs?.length : "N/A";
        const afterClear = {
          memory: UnifiedState3?.data?.petAbilityLogs?.length || 0,
          gmMain: verifyMain?.length || 0,
          gmArchive: verifyArchive?.length || 0,
          lsMain: verifyLS ? (() => {
            try {
              return JSON.parse(verifyLS).length;
            } catch (_e) {
              return "parse-error";
            }
          })() : 0,
          lsArchive: (() => {
            try {
              const v = win?.localStorage?.getItem("MGA_petAbilityLogs_archive");
              return v ? JSON.parse(v).length : 0;
            } catch (_e) {
              return 0;
            }
          })(),
          compatArray: verifyCompat
        };
        logDebug2("ABILITY-LOGS", "\u{1F4CA} AFTER CLEAR - Log counts:", afterClear);
        logDebug2("ABILITY-LOGS", "\u{1F4CA} COMPARISON:", {
          before: beforeClear,
          after: afterClear,
          clearedFlag: storage?.getItem("MGA_logs_manually_cleared")
        });
        const totalRemaining = Object.values(afterClear).reduce(
          (sum, val) => sum + (typeof val === "number" ? val : 0),
          0
        );
        if (totalRemaining > 0) {
          productionWarn3(`\u26A0\uFE0F [ABILITIES] ${totalRemaining} log(s) persist after clear!`);
          logDebug2("ABILITY-LOGS", "\u{1F50D} Logs that persisted - check these sources:", afterClear);
          if (verifyMain && verifyMain.length > 0) {
            logDebug2("ABILITY-LOGS", "\u274C PERSISTENT LOGS IN GM STORAGE:");
            verifyMain.forEach((log, i) => {
              logDebug2(
                "ABILITY-LOGS",
                `  ${i + 1}. ${log.abilityType} - ${log.petName} - ${new DateClass(log.timestamp).toLocaleString()}`
              );
            });
          }
        } else {
          productionLog3("\u2705 [ABILITIES] Successfully cleared all ability logs from all storage locations");
        }
        if (typeof win?.lastLogCount !== "undefined") {
          win.lastLogCount = 0;
        }
        if (updateTabContent) updateTabContent();
        updateAllAbilityLogDisplays2(false, dependencies);
      });
    }
    const exportLogsBtn = ctx.querySelector("#export-logs-btn");
    if (exportLogsBtn && !exportLogsBtn.hasAttribute("data-handler-setup")) {
      exportLogsBtn.setAttribute("data-handler-setup", "true");
      exportLogsBtn.addEventListener("click", () => {
        if (exportAbilityLogs2) {
          exportAbilityLogs2();
        }
      });
    }
    const diagnoseLogsBtn = ctx.querySelector("#diagnose-logs-btn");
    if (diagnoseLogsBtn && !diagnoseLogsBtn.hasAttribute("data-handler-setup")) {
      diagnoseLogsBtn.setAttribute("data-handler-setup", "true");
      diagnoseLogsBtn.addEventListener("click", () => {
        consoleFn.log("\u{1F50D} Running ability logs storage diagnostic...");
        const report = MGA_diagnoseAbilityLogStorage2 ? MGA_diagnoseAbilityLogStorage2() : null;
        if (report) {
          const totalWithLogs = report.summary?.totalLocationsWithLogs || 0;
          if (totalWithLogs === 0) {
            if (showNotificationToast2) {
              showNotificationToast2("\u2705 No ability logs found in any storage location", "success");
            }
          } else {
            if (showNotificationToast2) {
              showNotificationToast2(
                `\u{1F4CA} Found logs in ${totalWithLogs} storage location(s). Check console for details.`,
                "info"
              );
            }
          }
        }
      });
    }
    const detailedTimestampsCheckbox = ctx.querySelector("#detailed-timestamps-checkbox");
    if (detailedTimestampsCheckbox && !detailedTimestampsCheckbox.hasAttribute("data-handler-setup")) {
      detailedTimestampsCheckbox.setAttribute("data-handler-setup", "true");
      detailedTimestampsCheckbox.addEventListener("change", (e) => {
        if (UnifiedState3?.data?.settings) {
          UnifiedState3.data.settings.detailedTimestamps = e.target.checked;
        }
        if (MGA_saveJSON2) {
          MGA_saveJSON2("MGA_data", UnifiedState3?.data);
        }
        if (MGA_AbilityCache) {
          MGA_AbilityCache.timestamps.clear();
        }
        if (UnifiedState3?.data?.popouts?.overlays) {
          UnifiedState3.data.popouts.overlays.forEach((overlay, tabName) => {
            if (tabName === "abilities" && overlay && overlay.offsetParent !== null) {
              updateAbilityLogDisplay2(overlay, dependencies);
              debugLog3("ABILITY_LOGS", "Updated overlay with new timestamp format");
            }
          });
        }
        updateAllAbilityLogDisplays2(true, dependencies);
        productionLog3(`\u{1F550} [ABILITIES] Detailed timestamps: ${e.target.checked ? "enabled" : "disabled"}`);
      });
    }
    const currentMode = UnifiedState3?.data?.filterMode || "categories";
    if (setTimeoutFn) {
      setTimeoutFn(() => populateFilterModeContent(currentMode, dependencies), 100);
    }
  }

  // src/features/abilities/abilities-diagnostics.js
  var abilities_diagnostics_exports = {};
  __export(abilities_diagnostics_exports, {
    MGA_diagnoseAbilityLogStorage: () => MGA_diagnoseAbilityLogStorage
  });
  function MGA_diagnoseAbilityLogStorage(dependencies = {}) {
    const {
      UnifiedState: UnifiedState3 = typeof window !== "undefined" && window.UnifiedState,
      GM_getValue: GM_getValue2,
      // Passed via dependencies - no default to avoid circular reference
      window: win = typeof window !== "undefined" ? window : null,
      targetWindow: targetWindow3 = typeof window !== "undefined" && window.targetWindow ? window.targetWindow : null,
      logDebug: logDebug2 = typeof window !== "undefined" && window.logDebug ? window.logDebug : () => {
      },
      console: consoleFn = typeof console !== "undefined" ? console : { log: () => {
      } },
      Date: DateClass = typeof Date !== "undefined" ? Date : null
    } = dependencies;
    logDebug2("ABILITY-LOGS", "\u{1F50D} Starting comprehensive ability log storage diagnostic...");
    const report = {
      timestamp: new DateClass().toISOString(),
      sources: {}
    };
    const safeGet = (fn, label) => {
      try {
        return fn();
      } catch (e) {
        logDebug2("ABILITY-LOGS", `  \u274C ${label}: Error - ${e.message}`);
        return null;
      }
    };
    const parseAndCount = (raw, _label) => {
      if (!raw) return { exists: false, count: 0, logs: [] };
      try {
        const parsed = typeof raw === "string" ? JSON.parse(raw) : raw;
        const count = Array.isArray(parsed) ? parsed.length : 0;
        if (Array.isArray(parsed)) {
          const logs = parsed.map((l) => {
            const abilityType = l.abilityType || "unknown";
            const normalizedAbility = normalizeAbilityName3(abilityType, dependencies);
            const isKnown = isKnownAbilityType3(normalizedAbility);
            const isMalformed = abilityType !== normalizedAbility;
            return {
              ability: abilityType,
              normalizedAbility: isMalformed ? normalizedAbility : null,
              isKnown,
              isMalformed,
              pet: l.petName || l.petSpecies || "unknown",
              timestamp: l.timestamp,
              time: new DateClass(l.timestamp).toLocaleString(),
              // Create a unique fingerprint for this log
              fingerprint: `${abilityType}_${l.petName}_${l.timestamp}`.substring(0, 50)
            };
          });
          const malformedCount = logs.filter((l) => l.isMalformed).length;
          const unknownCount = logs.filter((l) => !l.isKnown).length;
          return {
            exists: true,
            count,
            logs,
            malformedCount,
            unknownCount
          };
        } else {
          return { exists: true, count: "not-an-array", logs: [] };
        }
      } catch (e) {
        return { exists: true, count: "parse-error", logs: [], error: e.message };
      }
    };
    const gmMain = safeGet(() => GM_getValue2 ? GM_getValue2("MGA_petAbilityLogs", null) : null, "GM Main");
    const gmArchive = safeGet(() => GM_getValue2 ? GM_getValue2("MGA_petAbilityLogs_archive", null) : null, "GM Archive");
    report.sources.gmStorage = {
      main: parseAndCount(gmMain, "GM Main"),
      archive: parseAndCount(gmArchive, "GM Archive")
    };
    const lsMain = safeGet(() => win?.localStorage?.getItem("MGA_petAbilityLogs"), "LS Main");
    const lsArchive = safeGet(() => win?.localStorage?.getItem("MGA_petAbilityLogs_archive"), "LS Archive");
    const lsClearFlag = safeGet(() => win?.localStorage?.getItem("MGA_logs_manually_cleared"), "LS Clear Flag");
    report.sources.windowLocalStorage = {
      main: parseAndCount(lsMain, "LS Main"),
      archive: parseAndCount(lsArchive, "LS Archive"),
      clearFlag: lsClearFlag
    };
    if (targetWindow3 && targetWindow3 !== win) {
      const tgMain = safeGet(() => targetWindow3.localStorage?.getItem("MGA_petAbilityLogs"), "TG Main");
      const tgArchive = safeGet(() => targetWindow3.localStorage?.getItem("MGA_petAbilityLogs_archive"), "TG Archive");
      report.sources.targetWindowLocalStorage = {
        main: parseAndCount(tgMain, "TG Main"),
        archive: parseAndCount(tgArchive, "TG Archive")
      };
    }
    const mgaData = safeGet(() => GM_getValue2 ? GM_getValue2("MGA_data", null) : null, "MGA_data");
    if (mgaData) {
      try {
        const parsed = typeof mgaData === "string" ? JSON.parse(mgaData) : mgaData;
        const nestedLogs = parsed?.petAbilityLogs;
        report.sources.mgaDataNested = {
          logs: parseAndCount(nestedLogs, "MGA_data nested")
        };
      } catch (e) {
        report.sources.mgaDataNested = { error: e.message };
      }
    }
    if (typeof win?.petAbilityLogs !== "undefined") {
      report.sources.compatibilityArray = {
        count: Array.isArray(win.petAbilityLogs) ? win.petAbilityLogs.length : "not-an-array",
        sample: Array.isArray(win.petAbilityLogs) ? win.petAbilityLogs.slice(0, 3) : null
      };
    }
    const memoryLogs = (UnifiedState3?.data?.petAbilityLogs || []).map((l) => {
      const abilityType = l.abilityType || "unknown";
      const normalizedAbility = normalizeAbilityName3(abilityType, dependencies);
      const isKnown = isKnownAbilityType3(normalizedAbility);
      const isMalformed = abilityType !== normalizedAbility;
      return {
        ability: abilityType,
        normalizedAbility: isMalformed ? normalizedAbility : null,
        isKnown,
        isMalformed,
        pet: l.petName || l.petSpecies || "unknown",
        timestamp: l.timestamp,
        time: new DateClass(l.timestamp).toLocaleString(),
        fingerprint: `${abilityType}_${l.petName}_${l.timestamp}`.substring(0, 50)
      };
    });
    report.sources.memory = {
      unifiedState: {
        count: memoryLogs.length,
        sample: memoryLogs
        // Now includes all logs with fingerprints
      }
    };
    const totals = {
      gmMain: report.sources.gmStorage.main.count || 0,
      gmArchive: report.sources.gmStorage.archive.count || 0,
      lsMain: report.sources.windowLocalStorage.main.count || 0,
      lsArchive: report.sources.windowLocalStorage.archive.count || 0,
      memory: report.sources.memory.unifiedState.count
    };
    report.summary = {
      totalLocationsWithLogs: Object.values(totals).filter((c) => c > 0).length,
      totals,
      suspectSources: Object.entries(totals).filter(([_k, v]) => v > 0).map(([k]) => k)
    };
    consoleFn.log("\u{1F50D} ========== ABILITY LOGS STORAGE DIAGNOSTIC ==========");
    consoleFn.log("\u{1F4CA} Summary:", report.summary);
    consoleFn.log("");
    consoleFn.log("\u{1F4C1} GM Storage:");
    consoleFn.log("  Main:", report.sources.gmStorage.main.count, "logs");
    consoleFn.log("  Archive:", report.sources.gmStorage.archive.count, "logs");
    consoleFn.log("\u{1F4C1} Window localStorage:");
    consoleFn.log("  Main:", report.sources.windowLocalStorage.main.count, "logs");
    consoleFn.log("  Archive:", report.sources.windowLocalStorage.archive.count, "logs");
    consoleFn.log("  Clear flag:", report.sources.windowLocalStorage.clearFlag);
    if (report.sources.targetWindowLocalStorage) {
      consoleFn.log("\u{1F4C1} Target Window localStorage:");
      consoleFn.log("  Main:", report.sources.targetWindowLocalStorage.main.count, "logs");
      consoleFn.log("  Archive:", report.sources.targetWindowLocalStorage.archive.count, "logs");
    }
    if (report.sources.mgaDataNested) {
      consoleFn.log("\u{1F4C1} MGA_data nested:", report.sources.mgaDataNested);
    }
    if (report.sources.compatibilityArray) {
      consoleFn.log("\u{1F4C1} Compatibility array:", report.sources.compatibilityArray);
    }
    consoleFn.log("\u{1F4BE} Memory:", report.sources.memory.unifiedState.count, "logs");
    consoleFn.log("");
    consoleFn.log("\u{1F4CB} ========== DETAILED LOG LISTING ==========");
    const showLogs = (title, logs) => {
      if (logs && logs.length > 0) {
        consoleFn.log(`
${title}:`);
        logs.forEach((log, i) => {
          const prefix = log.isMalformed ? "\u26A0\uFE0F MALFORMED" : log.isKnown ? "\u2705" : "\u2753 UNKNOWN";
          consoleFn.log(`  ${i + 1}. ${prefix} [${log.fingerprint}]`);
          consoleFn.log(`     ${log.ability} - ${log.pet}`);
          if (log.isMalformed) {
            consoleFn.log(`     \u2192 Should be: "${log.normalizedAbility}"`);
          }
          consoleFn.log(`     ${log.time}`);
        });
      }
    };
    showLogs("GM Storage (Main)", report.sources.gmStorage.main.logs);
    showLogs("GM Storage (Archive)", report.sources.gmStorage.archive.logs);
    showLogs("Window localStorage (Main)", report.sources.windowLocalStorage.main.logs);
    showLogs("Window localStorage (Archive)", report.sources.windowLocalStorage.archive.logs);
    if (report.sources.targetWindowLocalStorage) {
      showLogs("TargetWindow localStorage (Main)", report.sources.targetWindowLocalStorage.main.logs);
      showLogs("TargetWindow localStorage (Archive)", report.sources.targetWindowLocalStorage.archive.logs);
    }
    if (report.sources.mgaDataNested?.logs?.logs) {
      showLogs("MGA_data nested", report.sources.mgaDataNested.logs.logs);
    }
    showLogs("Memory (UnifiedState)", report.sources.memory.unifiedState.sample);
    const allSources = [
      report.sources.gmStorage.main,
      report.sources.gmStorage.archive,
      report.sources.windowLocalStorage.main,
      report.sources.windowLocalStorage.archive
    ];
    if (report.sources.targetWindowLocalStorage) {
      allSources.push(report.sources.targetWindowLocalStorage.main);
      allSources.push(report.sources.targetWindowLocalStorage.archive);
    }
    const totalMalformed = allSources.reduce((sum, src) => sum + (src.malformedCount || 0), 0);
    const totalUnknown = allSources.reduce((sum, src) => sum + (src.unknownCount || 0), 0);
    consoleFn.log("\n=======================================================");
    consoleFn.log("\u{1F4A1} TIPS:");
    consoleFn.log("  \u2022 Look for logs with identical fingerprints across multiple storage locations");
    consoleFn.log("  \u2022 If a log persists after clear, check which storage still contains it");
    if (totalMalformed > 0) {
      consoleFn.log(`  \u2022 \u26A0\uFE0F Found ${totalMalformed} MALFORMED ability name(s) - missing spaces before roman numerals`);
      consoleFn.log('  \u2022 Malformed logs may not clear properly. Enable Debug Mode and click "Clear Logs".');
    }
    if (totalUnknown > 0) {
      consoleFn.log(`  \u2022 \u2753 Found ${totalUnknown} UNKNOWN ability type(s) - not in known abilities list`);
    }
    consoleFn.log("=======================================================");
    logDebug2("ABILITY-LOGS", "\u2705 Diagnostic complete - see console for full report");
    return report;
  }

  // src/index.js
  console.log("[MGTools DEBUG] *** index.js IIFE executing! ***");
  var MGTools = {
    // Core Infrastructure
    Core: {
      Storage: storage_exports,
      Logging: logging_exports,
      Compat: compat_exports,
      Network: network_exports,
      Atoms: atoms_exports,
      Environment: environment_exports,
      ModalDetection: modal_detection_exports,
      WebSocketManager: websocket_manager_exports,
      StorageRecovery: storage_recovery_exports
    },
    // Configuration & Utilities
    Config: CONFIG,
    Utils: {
      RuntimeUtilities: runtime_utilities_exports,
      MemoryManagement: memory_management_exports,
      PlatformDetection: platform_detection_exports
    },
    // State Management
    State: {
      UnifiedState: unified_state_exports,
      Draggable: draggable_exports
    },
    // UI Framework
    UI: {
      UI: ui_exports,
      VersionBadge: version_badge_exports,
      ConnectionStatus: connection_status_exports,
      Overlay: overlay_exports,
      ThemeSystem: theme_system_exports,
      TooltipSystem: tooltip_system_exports,
      TabContent: tab_content_exports,
      HotkeyHelp: hotkey_help_exports,
      AssetManager: asset_manager_exports
    },
    // Controllers
    Controllers: {
      VersionCheck: version_check_exports,
      Shortcuts: shortcuts_exports,
      RoomPoll: room_poll_exports,
      AppCore: app_core_exports
    },
    // Initialization
    Init: {
      EarlyTraps: early_traps_exports,
      LegacyBootstrap: legacy_bootstrap_exports,
      PublicAPI: public_api_exports,
      Bootstrap: bootstrap_exports,
      EventHandlers: event_handlers_exports
    },
    // Feature Modules
    Features: {
      // Core Features
      Pets: pets_exports,
      Shop: shop_exports,
      Notifications: notifications_exports,
      Hotkeys: hotkeys_exports,
      Protection: protection_exports,
      CropHighlighting: crop_highlighting_exports,
      CropValue: crop_value_exports,
      AutoFavorite: auto_favorite_exports,
      ValueManager: value_manager_exports,
      TimerManager: timer_manager_exports,
      TurtleTimer: turtle_timer_exports,
      RoomManager: room_manager_exports,
      SettingsUI: settings_ui_exports,
      VersionChecker: version_checker_exports,
      MGTPOverlay: mgtp_overlay_exports,
      // Abilities System
      Abilities: {
        Data: abilities_data_exports,
        Utils: abilities_utils_exports,
        UI: abilities_ui_exports,
        Display: abilities_display_exports,
        Handlers: abilities_handlers_exports,
        Diagnostics: abilities_diagnostics_exports
      }
    },
    // Metadata
    _meta: {
      version: "2.0.0",
      buildType: "modular",
      modulesCount: 55,
      phase: "F",
      extractionProgress: "95.1%"
    }
  };
  if (typeof window !== "undefined") {
    window.MGTools = MGTools;
  }
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    let initializationStarted = false;
    const initializeWhenReady = () => {
      if (initializationStarted) {
        return;
      }
      initializationStarted = true;
      try {
        console.log("[MGTools] \u{1F680} Starting v2.0.0 (Modular Architecture)");
        if (early_traps_exports?.installAllEarlyTraps) {
          installAllEarlyTraps({
            unsafeWindow: typeof unsafeWindow !== "undefined" ? unsafeWindow : null,
            window,
            document,
            console
          });
          console.log("[MGTools] \u2705 Early traps installed");
        }
        let attempts = 0;
        const maxAttempts = 20;
        const checkGameReady = () => {
          attempts++;
          const atomCache = window.jotaiAtomCache?.cache || window.jotaiAtomCache;
          const hasAtoms = atomCache && typeof atomCache === "object";
          const hasConnection = window.MagicCircle_RoomConnection && typeof window.MagicCircle_RoomConnection === "object";
          const hasBasicDom = document.body && document.readyState === "complete";
          if (hasAtoms && hasConnection || attempts >= maxAttempts) {
            console.log("[MGTools] \u2705 Game ready, initializing with modular bootstrap...");
            const success = initializeModular({
              targetDocument: document,
              targetWindow: window
            });
            if (!success) {
              console.error("[MGTools] \u274C Initialization failed, see errors above");
            }
            return true;
          }
          if (attempts % 4 === 0) {
            console.log(`[MGTools] \u23F3 Waiting for game... (attempt ${attempts}/${maxAttempts})`);
          }
          return false;
        };
        if (!checkGameReady()) {
          const interval = setInterval(() => {
            if (checkGameReady()) {
              clearInterval(interval);
            }
          }, 500);
        }
      } catch (error) {
        console.error("[MGTools] \u274C Initialization failed:", error);
        console.error("[MGTools] Stack:", error.stack);
      }
    };
    const isDiscordEnv = window.location.href?.includes("discordsays.com");
    const initDelay = isDiscordEnv ? 2e3 : 500;
    try {
      if (document.readyState === "complete" || document.readyState === "interactive") {
        console.log(`[MGTools] Page ready (${document.readyState}), initializing in ${initDelay}ms...`);
        setTimeout(initializeWhenReady, initDelay);
      } else {
        console.log("[MGTools] Waiting for page load...");
        window.addEventListener("load", () => {
          setTimeout(initializeWhenReady, initDelay);
        });
        document.addEventListener("DOMContentLoaded", () => {
          console.log("[MGTools] DOM ready, waiting for complete load...");
        });
      }
    } catch (error) {
      console.error("[MGTools] \u274C Initialization setup failed:", error);
      setTimeout(initializeWhenReady, 1e3);
    }
  }
  return __toCommonJS(index_exports);
})();

You are Claude Opus in “planner” mode.
Your job: produce a step-by-step implementation plan (for Claude Sonnet to execute) to fix specific MGTools issues without introducing regressions.

Repo & Context

Repo: https://github.com/Myke247/MGTools (work from Live-Beta branch; modularization branches exist)

Project: MGTools — large Tampermonkey userscript and modularized build for Magic Garden / Magic Circle.

Style/tooling: Keep existing ESLint + Prettier (Airbnb-ish) exactly as-is. Do not wholesale reformat files; only format changed lines/blocks as needed to satisfy lint. If absolutely necessary, propose tiny config tweaks, but do not make them without explicit approval.

Do not add any co-authors. Do not push to GitHub. Output should be a precise plan + patch/diff instructions Sonnet can follow locally.

We recently completed modularization; leverage it. Keep behavior/UI identical except where fixes require a change.

High-Level Objectives

Create a precise, minimal-risk plan that:

Scopes changes to the correct modules/files (not a monolithic rewrite).

Preserves current behavior and UI, except where explicitly changed.

Includes crisp acceptance tests Sonnet can run (manual + quick automated checks where feasible).

Notes risks, rollback points, and logging/telemetry you want enabled temporarily for verification.

Produces patch-ready diffs (filenames, anchor comments or line ranges) Sonnet can implement exactly.

Issues to Fix (8 items)

Duplicate Notifications control in Settings (redundancy)

Problem: There are two controls (a big button and a checkbox) that toggle the same setting.

Desired: One source of truth in UI + state. Remove redundant control and any duplicate state. Ensure persisted setting remains stable across reloads.

Acceptance: Only one visible Notifications on/off control; toggling it immediately affects behavior and persists; no ghost toggles on refresh.

Multi-harvest slot value fails to update on actual harvest auto-cycle

Problem: When harvesting a multi-harvest crop, the UI auto-cycles but the “slot value” doesn’t update. It does update when scrolling with X/C or clicking.

Desired: The same value update path runs on harvest-triggered auto-cycle.

Acceptance: After harvesting a multi-harvest crop, the displayed slot value matches the newly focused crop slot on the next frame/tick.

Discord environments compatibility pass

Problem: After restructure, uncertain behavior in Discord (browser webview and desktop app).

Desired: Verify and document behavior in both Discord browser and desktop app contexts, accounting for CSP, iframe, and unsafeWindow/scope detection.

Acceptance: Core features (toolbar, hotkeys, rooms, logs, storage) work in both environments. Any required shims (e.g., scope detection) are localized and documented.

Animation toggle in Settings (remove or make it work)

Problem: Toggle historically affected only certain textures; utility questionable; currently not functioning as intended.

Desired: Either (A) remove it cleanly (code + UI + storage key), or (B) fix to match original intent with clear scope.

Acceptance: If removed—no dead code/keys; no UI gaps. If kept—toggling shows a visible effect where applicable; no no-ops.

Ability Logs filters should backfill without refresh

Problem: If “Other” filter is OFF at load, events like Seed Finder still occur but aren’t shown when you later enable the filter until you refresh.

Desired: Logging pipeline always records; filters affect view, not capture. Enabling a filter re-renders prior entries instantly.

Acceptance: Reproduce scenario: trigger events with filter OFF, then enable filter; past events appear immediately with correct timestamps and formatting.

Storage audit & improvements

Problem: Storage layer likely has hygiene/migration/back-compat issues; risk of surprises (e.g., stale keys, quota, Discord contexts).

Desired: Audit keys, versioning, migrations, fallback strategy, error handling. Reduce surprises and clarify persistence invariants.

Acceptance: A short storage map (keys, types, defaults, migrations), code adjustments where needed, and tests showing stable load/save across refresh and environments.

Hotkeys should not trigger while typing in chat (focus gating)

Problem: Pet-preset hotkeys (e.g., preset bound to letter “O”) fire even when typing in the in-game chat (right-side popout). The key should type into chat, not trigger the preset.

Desired: Robust focus gating for hotkeys:

Don’t trigger when event.target or document.activeElement is an INPUT, TEXTAREA, SELECT, or any contenteditable (including shadow DOM).

Consider role="textbox" and elements inside shadow roots; use e.composedPath() to detect text-entry contexts.

If chat lives in an iframe/webview, handle cross-document focus (if feasible) or fall back to a reliable “chat open” signal (mutation/observer) to suspend hotkeys.

Acceptance:

With chat focused, pressing “o” inserts “o” in the chat input; no hotkey runs.

With no text input focused, pressing “O/o” triggers the pet preset normally.

No regressions to other hotkeys; case-insensitive handling remains correct.

Works in the standard browser and Discord app contexts.

Custom Rooms: player count doesn’t update for user-added rooms

Problem: In the Custom Rooms tab, adding a room works, but the player count remains 0/6. Default rooms show counts correctly.

Likely cause: the polling/watch list or data binding excludes user-added entries (e.g., not registered in the tracked set, mismatched keys/casing, or no UI rebind).

Desired: Newly added custom rooms join the same polling/refresh cycle as defaults; counts update on the same cadence and render path.

Acceptance:

Add a custom room; within the normal polling interval, its count matches the live value and continues to update.

Removing the custom room stops polling for it and removes its UI without leaks.

Minimal DOM-update path also refreshes counts for custom rooms.

Modularization Guidance

Prefer updating existing modules over adding new ones. Likely touch points:

Inputs/Hotkeys module for focus gating and event handling.

Settings UI module for notifications/animation toggles and single source of truth.

Logs/Abilities module for capture vs view filtering and re-render behavior.

Seeds/Values or UI Value Renderer for auto-cycle update hook.

Rooms / Room Polling module for custom room registration, polling, and UI update.

Storage module for audit, migrations, and key hygiene.

Keep changes localized. Provide a mapping from each issue to specific files/sections (anchor comments or search tokens), so Sonnet can patch confidently.

Deliverables (what Sonnet needs from you)

Implementation Plan per issue: scope, exact files/modules, step list, and why.

Acceptance Tests per issue: reproducible steps and expected outcomes (include Discord browser + desktop app matrix).

Diff Sketches: for each file, show before/after anchors (function names/comments) and the intended changes at a high level (no need to dump full code).

Risk & Rollback: what to watch in logs, temporary debug flags, and how to revert a change quickly if needed.

Docs Updates: notes for CHANGELOG.md and, if applicable, a short addition to MODULARIZATION_PROGRESS.md explaining touched modules and rationale.

Constraints & Non-Goals

No new UI beyond what’s necessary to fix/remove toggles or wire existing elements.

No broad refactors or formatting churn.

Maintain current behavior everywhere else.

Keep all code changes lint-clean; add targeted eslint-disable comments only when justified and documented.

Now produce the plan in a clear, sectioned format Sonnet can execute directly.

Never push or make any changes to GitHub unless I ask, but the modularization may help you, I just want to not mess up the GitHub, so feel free to check it there too

Also you need to specifically let me know when I am safe to switch to sonnet.

Make the plan in a .txt file

Sonnet needs to know we are only editing or making the fixes withint our claudeprojectrepo folder presently so I can test them.

Nothing should be touched in GitHub... Unless? That's intended or something.

~~~~

2. Yes, and manually approve edits.
Proceed to generate the MGTools_Fix_Implementation_Plan.txt for the 8 issues we outlined.

Guardrails (do not skip):

Keep current ESLint/Prettier setup; no repo-wide reformat. Only touch lines you change.

No co-authors. No GitHub pushes. Local diffs/patches only.

Leverage the existing modularization; scope changes to the right modules; no broad refactors.

Deliverables I need in the plan:

Issue-by-issue steps with precise file paths + anchor comments/search tokens for each edit.

Diff sketches (before/after snippets) sufficient for Sonnet to implement exactly.

Acceptance tests per issue, including a Discord browser + Discord desktop matrix.

Risk/rollback notes and any temporary debug logging to verify fixes.

Docs updates: bullet entries for CHANGELOG.md and notes for MODULARIZATION_PROGRESS.md.

Extra clarity on two items:

Hotkeys vs chat focus: Hotkeys must not fire when focus is in any text entry (INPUT, TEXTAREA, SELECT, contenteditable, shadow DOM, role="textbox"; handle e.composedPath(); account for Discord contexts).

Custom Rooms player count: Newly added rooms must join the same polling/refresh path as defaults and update within the normal interval; unregister cleanly on removal.

When the plan is ready, stop and wait for my review. Don’t apply edits until I approve.

If you’d rather keep them planning a bit more (option 3)

Use this if you want more specificity before any implementation plan:

3. No, keep planning.
Before drafting the full implementation plan, please provide a one-page outline mapping each of the 8 issues to:

target modules/files,

key functions to touch,

the smallest viable change for each fix,

any foreseen risks.
Keep all guardrails from earlier (no reformatting, no pushes, modularization respected). I’ll approve the outline, then you can expand it into the detailed plan.

If you really want them to auto-apply (not recommended right now)

Only if you’re comfortable skipping manual review:

1. Yes, and auto-accept edits.
Follow the previously stated guardrails (no pushes, no co-authors, ESLint/Prettier intact, modularization respected). After generating the plan, proceed to produce patch-ready diffs and apply them locally. Provide a full changelog, acceptance test results (including Discord browser + desktop), and rollback notes. Pause before any Git operations.

~~~

Solid first pass—thanks. Before I approve for Sonnet, please revise the plan with these changes:

Global corrections

Replace approximate line numbers + raw HTML blocks with module/file paths, function names, and anchor comments. Keep changes scoped to our modular structure wherever modules exist.

Replace cp/diff/patch and node -c with Windows-friendly steps: git add -N + git diff, eslint ., and a quick node -e syntax check or run the build.

No version bump or CHANGELOG version/tag yet. Provide proposed notes only.

For the animation toggle, provide Option A (remove) and Option B (fix) with dependencies/risks; wait on my decision.

Issue-specific adjustments

Notifications duplicate: Identify which control is canonical; keep that one. Remove the other plus all associated listeners/state writes. Confirm persistence key remains unchanged.

Multi-harvest update: Do not use setTimeout or DOM pokes. Hook the exact value-update pathway used by X/C navigation or dispatch the same event the X/C handler consumes after auto-cycle completes.

Discord compat: In addition to detection, validate scope bridging (sandbox vs unsafeWindow) and iframe embedding. Document any CSP surface we must respect; keep shims localized.

Animation toggle: Inventory reads/writes first. If removed, include storage migration (with backup/rollback) and no-op shims for any remaining reads.

Ability logs: Fix at the data layer. Ensure events are always captured; when filters change, re-render from the in-memory log (don’t rely on toggling display:none).

Storage audit: Align the schema with our actual Storage adapter (key names, nesting rules). Propose non-destructive migrations with rollback and a one-time “dry-run” log before mutations.

Hotkey focus gating: Implement a pure predicate shouldBlockHotkey(e) using e.composedPath(), activeElement, contenteditable, role="textbox", and shadow-DOM checks; ensure the main handler bails early and avoids preventDefault() when blocked. Include Discord desktop/browser chat focus cases in tests.

Custom rooms counts: Register user-added rooms into the same polling pipeline as defaults, with throttling and dedupe, and unbind on removal. Don’t introduce new one-off timers; reuse the existing poller and UI render path.

Debugging

Use a single temporary flag DEBUG.FIX_VALIDATION (default false). Do not change any “production” flags.

Deliverables

Updated plan with precise module paths/exports, before/after anchors, and Windows-friendly commands.

Confirm that no commits/pushes or version changes will be made until I approve.

Once revised, I’ll approve and hand to Sonnet.


~~

3. No, and here’s what to change before I approve Sonnet execution:

1) Issue 2 (multi-harvest): don’t synthesize a KeyboardEvent.
Call the same internal function/event path the X/C handler uses (e.g., applySlotFocusChange(), selectNextSlot(), or the shared “value refresh” function). Dispatching a DOM keydown risks double-cycling and focus issues across documents. Please identify the exact internal function/event bus the X/C path hits and invoke that directly after auto-cycle completes.

2) Issue 7 (hotkeys): fix preventDefault flow + logging.
Use a guard pattern:

if (shouldBlockHotkey(e)) return;   // no preventDefault, let typing happen
// …only after we actually handle a hotkey:
e.preventDefault();


Your sample currently calls preventDefault() inside the early-return block. Also change the debug to log the real value:

const blocked = shouldBlockHotkey(e);
console.log('[FIX_HOTKEY]', { blocked, el: document.activeElement?.tagName, editable: document.activeElement?.isContentEditable });


3) Issue 6 (storage migration): fix a bug + avoid localStorage-only.
You still have Storage.remove(key) where key is undefined—use the actual key (pattern) there. Don’t iterate localStorage directly; use our Storage adapter’s enumerate/list API (or a safe fallback) so GM storage and Discord contexts are covered. Keep dry-run truly read-only.

4) Discord detection & scope:
Narrow isDiscordBrowser to discord.com/discordsays.com. Also, wherever you reference targetDocument, define it explicitly as the same document the key handlers attach to (e.g., const targetDocument = (typeof unsafeWindow !== 'undefined' ? unsafeWindow.document : window.document);), and use it consistently.

5) Issue 1 (notifications): remove all references to the button.
In addition to the DOM, delete any listeners, CSS selectors, and state writes that mention the button ID, so there are no ghost warnings in console.

6) Issue 8 (custom rooms): don’t introduce window.roomPollingRegistry.
Reuse the existing poller registry in the Rooms module (module-level Set/Map). If one doesn’t exist, add a private module variable—not a global—to track custom rooms. Ensure the main poll loop reads defaults ∪ custom and dedupes.

7) Tests addendum:
Include IME/composition typing in chat for hotkey gating, and verify no double-cycle on harvest (one slot advance only).

Keep everything else as in the revised plan (Windows-friendly commands, no version bump, single DEBUG.FIX_VALIDATION flag). When updated, overwrite the plan file, and I’ll approve for Sonnet.

~~

A) Pin down the exact internal function path for Issue 2 (no synthetic KeyboardEvent)

Locate the X/C navigation path and produce a short call-graph:

Search tokens: handleKeyDown, onKeyDown, case 'x', case 'c', KeyX, KeyC, cycle, nextSlot, prevSlot, select*Slot, apply*Focus, focus*Slot, update*Value, render*Value, refresh*Value.

Show: entry handler → any intermediate helpers → the final function(s) that updates the slot focus/value UI.

Identify the single function/event bus we should invoke when harvest auto-cycle completes (e.g., applySlotFocusChange() or equivalent).

Confirm whether a central “value refresh” exists (e.g., refreshSlotValueUI()), and if the X/C path calls it directly or indirectly.

Prove no double-cycle on harvest:

Instrument the X/C handler with a temporary debug counter under DEBUG.FIX_VALIDATION.

Show that invoking the chosen function once after harvest yields exactly one slot advance and a correct value refresh.

Deliverables for A:

Issue2_FunctionTrace.md:

Function names, modules/files, anchor comments, and a 5–10 line call-graph.

The exact one-liner we will call from the harvest completion path (with parameters).

Any preconditions/postconditions (e.g., state fields that must be set before calling).

B) Produce the final corrected plan incorporating our agreed changes

Apply all corrections we discussed; specifics to include:

Hotkeys focus gating (Issue 7):

Implement a pure predicate shouldBlockHotkey(e) (uses e.composedPath(), activeElement, contenteditable, role="textbox", shadow-DOM aware).

Handler pattern:

if (shouldBlockHotkey(e)) return; // do NOT preventDefault()
// …if we actually handle a hotkey:
e.preventDefault();


Add IME/composition tests in the matrix.

Storage migration (Issue 6):

Fix the undefined variable bug (Storage.remove(pattern) not key).

Use the Storage adapter to enumerate keys (no direct localStorage).

Dry-run is strictly read-only; real run only after my approval.

Discord detection/scope (Issue 3):

Restrict host checks to discord.com and discordsays.com.

Define and reuse targetDocument once (prefer unsafeWindow.document if available).

Note any scope bridging/CSP constraints; keep shims local to the compatibility module.

Notifications duplicate (Issue 1):

Keep the checkbox as canonical; remove all button references (DOM, listeners, selectors, stray state writes).

Persistence key unchanged.

Custom rooms player count (Issue 8):

Reuse the existing poller (module-level Set/Map), no window.* globals.

Ensure main poll loop iterates defaults ∪ custom with dedupe; unregister cleanly on remove.

Ability logs backfill (Issue 5):

Data-layer fix: always capture to an in-memory buffer; filter changes trigger re-render from data, not display:none toggles.

Include a small cap (e.g., MAX_LOG_ENTRIES) and verify performance.

Animation toggle (Issue 4):

Present both options (Remove vs Fix) with dependency inventory and risks.

Do not implement until I choose one.

General constraints:

Windows-friendly commands only; no version bump; no commits/pushes; single DEBUG.FIX_VALIDATION flag.

Use module/file paths + anchor comments (no raw line numbers).

Deliverables for B:

MGTools_Fix_Implementation_Plan.txt (final):

Per-issue steps with module paths and anchors, diff sketches, acceptance tests (browser + Discord browser + Discord desktop + IME), risk/rollback, and proposed doc notes (no version tag).

When both Issue2_FunctionTrace.md and the final plan are ready, stop and wait for my approval.


~~~~

This looks very good—close to “approve,” with just a few surgical tweaks I’d make before handing to Sonnet:

Green lights

✅ Switched from “fake keydown” to absolute sync from the game state.

✅ Clear targetWindow/targetDocument handling for Discord contexts.

✅ Microtask → rAF scheduling (nice and smooth, avoids arbitrary delays).

✅ Guards against double-refresh by comparing indices.

✅ Test matrix + TEMP debug flag are sensible.

Tiny but important edits before approve

Atom lookup robustness (avoid path fragility).
You hard-code the full source path string for the atom. Add a fallback finder that matches by suffix/key name so refactors don’t break us:

function findAtom(cache, names = ['myCurrentGrowSlotIndexAtom']) {
  if (!cache) return null;
  if (cache.get) {
    for (const n of names) {
      if (cache.get(n)) return cache.get(n);
    }
    // suffix match fallback
    for (const [k, v] of cache.entries?.() ?? []) {
      if (names.some(n => k.endsWith(n))) return v;
    }
  } else {
    // plain object fallback
    for (const k of Object.keys(cache)) {
      if (names.some(n => k === n || k.endsWith(n))) return cache[k];
    }
  }
  return null;
}


Then use const slotAtom = findAtom(atomCache);.

Don’t call slotAtom.read directly without the right getter.
That line is brittle (slotAtom.read({ get: ... })). Wrap it so it’s side-effect free and won’t throw if the atom’s API changes:

function readAtomValue(atom) {
  try {
    // Prefer a cached “last seen” value if your atom watcher already tracks it:
    if (typeof atom?.lastValue !== 'undefined') return atom.lastValue;

    // Otherwise, attempt a safe read only if API matches:
    if (typeof atom?.read === 'function' && typeof atom?.init !== 'undefined') {
      const ctx = { get: (a) => (a === atom ? atom.init : undefined) };
      return atom.read(ctx);
    }
  } catch {}
  return undefined;
}


In syncSlotIndexFromGame, use const gameIndex = readAtomValue(slotAtom);.

Centralize state set; avoid direct window._mgtools_currentSlotIndex writes.
If you have a canonical setter (e.g., setSlotIndex(idx) in your Inputs/State module), use that. If not, minimally wrap the assignment so future refactors are one touch:

function setSlotIndex(idx) { window._mgtools_currentSlotIndex = idx; }


Then replace writes with setSlotIndex(gameIndex).

Polyfill queueMicrotask for older embeds.
Some Discord/webview shells miss it:

const qmt = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn);
// then use: qmt(() => requestAnimationFrame(...))


Return value from syncSlotIndexFromGame.
Have it return the new index or null so tests can assert easily:

if (changed) { setSlotIndex(gameIndex); /* refresh */ return gameIndex; }
return null;


IME safety note.
In your tests, explicitly verify that the harvest sync doesn’t interfere with text composition (ties into Issue 7). You listed it—good—just make sure Sonnet includes a quick manual step for IME (“type while harvesting in chat; ensure no slot hop”).

Cleanup
Ensure all console.log under FIX_VALIDATION are removed or gated off by default false before release.

If you fold in those tweaks, I agree with the approach and would approve it for Sonnet.